"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+table@0.35.0";
exports.ids = ["vendor-chunks/@lexical+table@0.35.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@lexical+table@0.35.0/node_modules/@lexical/table/LexicalTable.dev.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+table@0.35.0/node_modules/@lexical/table/LexicalTable.dev.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $computeTableMap: () => (/* binding */ $computeTableMap),\n/* harmony export */   $computeTableMapSkipCellCheck: () => (/* binding */ $computeTableMapSkipCellCheck),\n/* harmony export */   $createTableCellNode: () => (/* binding */ $createTableCellNode),\n/* harmony export */   $createTableNode: () => (/* binding */ $createTableNode),\n/* harmony export */   $createTableNodeWithDimensions: () => (/* binding */ $createTableNodeWithDimensions),\n/* harmony export */   $createTableRowNode: () => (/* binding */ $createTableRowNode),\n/* harmony export */   $createTableSelection: () => (/* binding */ $createTableSelection),\n/* harmony export */   $createTableSelectionFrom: () => (/* binding */ $createTableSelectionFrom),\n/* harmony export */   $deleteTableColumn: () => (/* binding */ $deleteTableColumn),\n/* harmony export */   $deleteTableColumnAtSelection: () => (/* binding */ $deleteTableColumnAtSelection),\n/* harmony export */   $deleteTableColumn__EXPERIMENTAL: () => (/* binding */ $deleteTableColumn__EXPERIMENTAL),\n/* harmony export */   $deleteTableRowAtSelection: () => (/* binding */ $deleteTableRowAtSelection),\n/* harmony export */   $deleteTableRow__EXPERIMENTAL: () => (/* binding */ $deleteTableRow__EXPERIMENTAL),\n/* harmony export */   $findCellNode: () => (/* binding */ $findCellNode),\n/* harmony export */   $findTableNode: () => (/* binding */ $findTableNode),\n/* harmony export */   $getElementForTableNode: () => (/* binding */ $getElementForTableNode),\n/* harmony export */   $getNodeTriplet: () => (/* binding */ $getNodeTriplet),\n/* harmony export */   $getTableAndElementByKey: () => (/* binding */ $getTableAndElementByKey),\n/* harmony export */   $getTableCellNodeFromLexicalNode: () => (/* binding */ $getTableCellNodeFromLexicalNode),\n/* harmony export */   $getTableCellNodeRect: () => (/* binding */ $getTableCellNodeRect),\n/* harmony export */   $getTableColumnIndexFromTableCellNode: () => (/* binding */ $getTableColumnIndexFromTableCellNode),\n/* harmony export */   $getTableNodeFromLexicalNodeOrThrow: () => (/* binding */ $getTableNodeFromLexicalNodeOrThrow),\n/* harmony export */   $getTableRowIndexFromTableCellNode: () => (/* binding */ $getTableRowIndexFromTableCellNode),\n/* harmony export */   $getTableRowNodeFromTableCellNodeOrThrow: () => (/* binding */ $getTableRowNodeFromTableCellNodeOrThrow),\n/* harmony export */   $insertTableColumn: () => (/* binding */ $insertTableColumn),\n/* harmony export */   $insertTableColumnAtSelection: () => (/* binding */ $insertTableColumnAtSelection),\n/* harmony export */   $insertTableColumn__EXPERIMENTAL: () => (/* binding */ $insertTableColumn__EXPERIMENTAL),\n/* harmony export */   $insertTableRow: () => (/* binding */ $insertTableRow),\n/* harmony export */   $insertTableRowAtSelection: () => (/* binding */ $insertTableRowAtSelection),\n/* harmony export */   $insertTableRow__EXPERIMENTAL: () => (/* binding */ $insertTableRow__EXPERIMENTAL),\n/* harmony export */   $isScrollableTablesActive: () => (/* binding */ $isScrollableTablesActive),\n/* harmony export */   $isTableCellNode: () => (/* binding */ $isTableCellNode),\n/* harmony export */   $isTableNode: () => (/* binding */ $isTableNode),\n/* harmony export */   $isTableRowNode: () => (/* binding */ $isTableRowNode),\n/* harmony export */   $isTableSelection: () => (/* binding */ $isTableSelection),\n/* harmony export */   $mergeCells: () => (/* binding */ $mergeCells),\n/* harmony export */   $removeTableRowAtIndex: () => (/* binding */ $removeTableRowAtIndex),\n/* harmony export */   $unmergeCell: () => (/* binding */ $unmergeCell),\n/* harmony export */   INSERT_TABLE_COMMAND: () => (/* binding */ INSERT_TABLE_COMMAND),\n/* harmony export */   TableCellHeaderStates: () => (/* binding */ TableCellHeaderStates),\n/* harmony export */   TableCellNode: () => (/* binding */ TableCellNode),\n/* harmony export */   TableNode: () => (/* binding */ TableNode),\n/* harmony export */   TableObserver: () => (/* binding */ TableObserver),\n/* harmony export */   TableRowNode: () => (/* binding */ TableRowNode),\n/* harmony export */   applyTableHandlers: () => (/* binding */ applyTableHandlers),\n/* harmony export */   getDOMCellFromTarget: () => (/* binding */ getDOMCellFromTarget),\n/* harmony export */   getTableElement: () => (/* binding */ getTableElement),\n/* harmony export */   getTableObserverFromTableElement: () => (/* binding */ getTableObserverFromTableElement),\n/* harmony export */   registerTableCellUnmergeTransform: () => (/* binding */ registerTableCellUnmergeTransform),\n/* harmony export */   registerTablePlugin: () => (/* binding */ registerTablePlugin),\n/* harmony export */   registerTableSelectionObserver: () => (/* binding */ registerTableSelectionObserver),\n/* harmony export */   setScrollableTablesActive: () => (/* binding */ setScrollableTablesActive)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(rsc)/./node_modules/.pnpm/@lexical+utils@0.35.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/clipboard */ \"(rsc)/./node_modules/.pnpm/@lexical+clipboard@0.35.0/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    return new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n  }\n  afterCloneFrom(node) {\n    super.afterCloneFrom(node);\n    this.__rowSpan = node.__rowSpan;\n    this.__backgroundColor = node.__backgroundColor;\n    this.__verticalAlign = node.__verticalAlign;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableCellNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeaderStyles(serializedNode.headerState).setColSpan(serializedNode.colSpan || 1).setRowSpan(serializedNode.rowSpan || 1).setWidth(serializedNode.width || undefined).setBackgroundColor(serializedNode.backgroundColor || null).setVerticalAlign(serializedNode.verticalAlign || undefined);\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n    this.__verticalAlign = undefined;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    if (isValidVerticalAlign(this.__verticalAlign)) {\n      element.style.verticalAlign = this.__verticalAlign;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const output = super.exportDOM(editor);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(output.element)) {\n      const element = output.element;\n      element.setAttribute('data-temporary-table-cell-lexical-key', this.getKey());\n      element.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element.rowSpan = this.__rowSpan;\n      }\n      element.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element.style.verticalAlign = this.getVerticalAlign() || 'top';\n      element.style.textAlign = 'start';\n      if (this.__backgroundColor === null && this.hasHeader()) {\n        element.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return output;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ...(isValidVerticalAlign(this.__verticalAlign) && {\n        verticalAlign: this.__verticalAlign\n      }),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.getLatest().__colSpan;\n  }\n  setColSpan(colSpan) {\n    const self = this.getWritable();\n    self.__colSpan = colSpan;\n    return self;\n  }\n  getRowSpan() {\n    return this.getLatest().__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    const self = this.getWritable();\n    self.__rowSpan = rowSpan;\n    return self;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {\n    const self = this.getWritable();\n    self.__headerState = headerState & mask | self.__headerState & ~mask;\n    return self;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return self;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    const self = this.getWritable();\n    self.__backgroundColor = newBackgroundColor;\n    return self;\n  }\n  getVerticalAlign() {\n    return this.getLatest().__verticalAlign;\n  }\n  setVerticalAlign(newVerticalAlign) {\n    const self = this.getWritable();\n    self.__verticalAlign = newVerticalAlign || undefined;\n    return self;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor || prevNode.__verticalAlign !== this.__verticalAlign;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction isValidVerticalAlign(verticalAlign) {\n  return verticalAlign === 'middle' || verticalAlign === 'bottom';\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const verticalAlign = domNode_.style.verticalAlign;\n  if (isValidVerticalAlign(verticalAlign)) {\n    tableCellNode.__verticalAlign = verticalAlign;\n  }\n  const style = domNode_.style;\n  const textDecoration = (style && style.textDecoration || '').split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      const result = [];\n      let paragraphNode = null;\n      const removeSingleLineBreakNode = () => {\n        if (paragraphNode) {\n          const firstChild = paragraphNode.getFirstChild();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(firstChild) && paragraphNode.getChildrenSize() === 1) {\n            firstChild.remove();\n          }\n        }\n      };\n      for (const child of childLexicalNodes) {\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isInlineElementOrDecoratorNode)(child) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(child)) {\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n            if (hasBoldFontWeight) {\n              child.toggleFormat('bold');\n            }\n            if (hasLinethroughTextDecoration) {\n              child.toggleFormat('strikethrough');\n            }\n            if (hasItalicFontStyle) {\n              child.toggleFormat('italic');\n            }\n            if (hasUnderlineTextDecoration) {\n              child.toggleFormat('underline');\n            }\n          }\n          if (paragraphNode) {\n            paragraphNode.append(child);\n          } else {\n            paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)().append(child);\n            result.push(paragraphNode);\n          }\n        } else {\n          result.push(child);\n          removeSingleLineBreakNode();\n          paragraphNode = null;\n        }\n      }\n      removeSingleLineBreakNode();\n      if (result.length === 0) {\n        result.push((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n      }\n      return result;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeight(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    const height = this.getHeight();\n    return {\n      ...super.exportJSON(),\n      ...(height === undefined ? undefined : {\n        height\n      })\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.tableRow);\n    return element;\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return self;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    after: children => (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$descendantsMatching)(children, $isTableCellNode),\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n      paragraphNode.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $insertTableRowAtSelection} or {@link $insertTableRowAtNode} instead.\n */\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          formatDevErrorMessage(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\n\n/**\n * Inserts a table row before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRowAtSelection(insertAfter = true) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  if (insertAfter) {\n    return $insertTableRowAtNode(anchorStartRow + anchorCell.__rowSpan > focusStartRow + focusCell.__rowSpan ? anchorCell : focusCell, true);\n  } else {\n    return $insertTableRowAtNode(focusStartRow < anchorStartRow ? focusCell : anchorCell, false);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $insertTableRowAtSelection}\n */\nconst $insertTableRow__EXPERIMENTAL = $insertTableRowAtSelection;\n\n/**\n * Inserts a table row before or after the given cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRowAtNode(cellNode, insertAfter = true) {\n  const [,, grid] = $getNodeTriplet(cellNode);\n  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: cellStartRow\n  } = cellMap;\n  let insertedRow = null;\n  if (insertAfter) {\n    const insertAfterEndRow = cellStartRow + cellNode.__rowSpan - 1;\n    const insertAfterEndRowMap = gridMap[insertAfterEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertAfterEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= insertAfterEndRow) {\n        const currentCell = insertAfterEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertAfterEndRowNode = grid.getChildAtIndex(insertAfterEndRow);\n    if (!$isTableRowNode(insertAfterEndRowNode)) {\n      formatDevErrorMessage(`insertAfterEndRow is not a TableRowNode`);\n    }\n    insertAfterEndRowNode.insertAfter(newRow);\n    insertedRow = newRow;\n  } else {\n    const insertBeforeStartRow = cellStartRow;\n    const insertBeforeStartRowMap = gridMap[insertBeforeStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertBeforeStartRowMap[i];\n      if (startRow === insertBeforeStartRow) {\n        const currentCell = insertBeforeStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertBeforeStartRowNode = grid.getChildAtIndex(insertBeforeStartRow);\n    if (!$isTableRowNode(insertBeforeStartRowNode)) {\n      formatDevErrorMessage(`insertBeforeStartRow is not a TableRowNode`);\n    }\n    insertBeforeStartRowNode.insertBefore(newRow);\n    insertedRow = newRow;\n  }\n  return insertedRow;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $insertTableColumnAtSelection} or {@link $insertTableColumnAtNode} instead.\n */\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          formatDevErrorMessage(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\n\n/**\n * Inserts a column before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumnAtSelection(insertAfter = true) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  if (insertAfter) {\n    return $insertTableColumnAtNode(anchorStartColumn + anchorCell.__colSpan > focusStartColumn + focusCell.__colSpan ? anchorCell : focusCell, true);\n  } else {\n    return $insertTableColumnAtNode(focusStartColumn < anchorStartColumn ? focusCell : anchorCell, false);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $insertTableColumnAtSelection}\n */\nconst $insertTableColumn__EXPERIMENTAL = $insertTableColumnAtSelection;\n\n/**\n * Inserts a column before or after the given cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumnAtNode(cellNode, insertAfter = true, shouldSetSelection = true) {\n  const [,, grid] = $getNodeTriplet(cellNode);\n  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);\n  const rowCount = gridMap.length;\n  const {\n    startColumn\n  } = cellMap;\n  const insertAfterColumn = insertAfter ? startColumn + cellNode.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    formatDevErrorMessage(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        formatDevErrorMessage(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null && shouldSetSelection) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    const columnIndex = insertAfterColumn < 0 ? 0 : insertAfterColumn;\n    const newWidth = newColWidths[columnIndex];\n    newColWidths.splice(columnIndex, 0, newWidth);\n    grid.setColWidths(newColWidths);\n  }\n  return firstInsertedCell;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $deleteTableColumnAtSelection} instead.\n */\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRowAtSelection() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const [anchor, focus] = selection.isBackward() ? [selection.focus.getNode(), selection.anchor.getNode()] : [selection.anchor.getNode(), selection.focus.getNode()];\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top or bottom have to be trimmed\n      if (cellStartRow < anchorStartRow || cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        const intersectionStart = Math.max(cellStartRow, anchorStartRow);\n        const intersectionEnd = Math.min(cell.__rowSpan + cellStartRow - 1, focusEndRow);\n        const overflowRowsCount = intersectionStart <= intersectionEnd ? intersectionEnd - intersectionStart + 1 : 0;\n        cell.setRowSpan(cell.__rowSpan - overflowRowsCount);\n      }\n      // Rows overflowing bottom have to be moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow &&\n      // Handle overflow only once\n      row === focusEndRow) {\n        if (!(nextRowNode !== null)) {\n          formatDevErrorMessage(`Expected nextRowNode not to be null`);\n        }\n        let insertAfterCell = null;\n        for (let columnIndex = 0; columnIndex < column; columnIndex++) {\n          const currentCellMap = nextRow[columnIndex];\n          const currentCell = currentCellMap.cell;\n          // Checking the cell having startRow as same as nextRow\n          if (currentCellMap.startRow === row + 1) {\n            insertAfterCell = currentCell;\n          }\n          if (currentCell.__colSpan > 1) {\n            columnIndex += currentCell.__colSpan - 1;\n          }\n        }\n        if (insertAfterCell === null) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          insertAfterCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`Expected TableNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $deleteTableRowAtSelection}\n */\nconst $deleteTableRow__EXPERIMENTAL = $deleteTableRowAtSelection;\nfunction $deleteTableColumnAtSelection() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    newColWidths.splice(startColumn, selectedColumnCount);\n    grid.setColWidths(newColWidths);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $deleteTableColumnAtSelection}\n */\nconst $deleteTableColumn__EXPERIMENTAL = $deleteTableColumnAtSelection;\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $mergeCells(cellNodes) {\n  if (cellNodes.length === 0) {\n    return null;\n  }\n\n  // Find the table node\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(cellNodes[0]);\n  const [gridMap] = $computeTableMapSkipCellCheck(tableNode, null, null);\n\n  // Find the boundaries of the selection including merged cells\n  let minRow = Infinity;\n  let maxRow = -Infinity;\n  let minCol = Infinity;\n  let maxCol = -Infinity;\n\n  // First pass: find the actual boundaries considering merged cells\n  const processedCells = new Set();\n  for (const row of gridMap) {\n    for (const mapCell of row) {\n      if (!mapCell || !mapCell.cell) {\n        continue;\n      }\n      const cellKey = mapCell.cell.getKey();\n      if (processedCells.has(cellKey)) {\n        continue;\n      }\n      if (cellNodes.some(cell => cell.is(mapCell.cell))) {\n        processedCells.add(cellKey);\n        // Get the actual position of this cell in the grid\n        const cellStartRow = mapCell.startRow;\n        const cellStartCol = mapCell.startColumn;\n        const cellRowSpan = mapCell.cell.__rowSpan || 1;\n        const cellColSpan = mapCell.cell.__colSpan || 1;\n\n        // Update boundaries considering the cell's actual position and span\n        minRow = Math.min(minRow, cellStartRow);\n        maxRow = Math.max(maxRow, cellStartRow + cellRowSpan - 1);\n        minCol = Math.min(minCol, cellStartCol);\n        maxCol = Math.max(maxCol, cellStartCol + cellColSpan - 1);\n      }\n    }\n  }\n\n  // Validate boundaries\n  if (minRow === Infinity || minCol === Infinity) {\n    return null;\n  }\n\n  // The total span of the merged cell\n  const totalRowSpan = maxRow - minRow + 1;\n  const totalColSpan = maxCol - minCol + 1;\n\n  // Use the top-left cell as the target cell\n  const targetCellMap = gridMap[minRow][minCol];\n  if (!targetCellMap.cell) {\n    return null;\n  }\n  const targetCell = targetCellMap.cell;\n\n  // Set the spans for the target cell\n  targetCell.setColSpan(totalColSpan);\n  targetCell.setRowSpan(totalRowSpan);\n\n  // Move content from other cells to the target cell\n  const seenCells = new Set([targetCell.getKey()]);\n\n  // Second pass: merge content and remove other cells\n  for (let row = minRow; row <= maxRow; row++) {\n    for (let col = minCol; col <= maxCol; col++) {\n      const mapCell = gridMap[row][col];\n      if (!mapCell.cell) {\n        continue;\n      }\n      const currentCell = mapCell.cell;\n      const key = currentCell.getKey();\n      if (!seenCells.has(key)) {\n        seenCells.add(key);\n        const isEmpty = $cellContainsEmptyParagraph(currentCell);\n        if (!isEmpty) {\n          targetCell.append(...currentCell.getChildren());\n        }\n        currentCell.remove();\n      }\n    }\n  }\n\n  // Ensure target cell has content\n  if (targetCell.getChildrenSize() === 0) {\n    targetCell.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n  }\n  return targetCell;\n}\nfunction $cellContainsEmptyParagraph(cell) {\n  if (cell.getChildrenSize() !== 1) {\n    return false;\n  }\n  const firstChild = cell.getFirstChildOrThrow();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(firstChild) || !firstChild.isEmpty()) {\n    return false;\n  }\n  return true;\n}\nfunction $unmergeCell() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const cellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor, $isTableCellNode);\n  if (!$isTableCellNode(cellNode)) {\n    formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n  }\n  return $unmergeCellNode(cellNode);\n}\nfunction $unmergeCellNode(cellNode) {\n  const [cell, row, grid] = $getNodeTriplet(cellNode);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan === 1 && rowSpan === 1) {\n    return;\n  }\n  const [map, cellMap] = $computeTableMap(grid, cell, cell);\n  const {\n    startColumn,\n    startRow\n  } = cellMap;\n  // Create a heuristic for what the style of the unmerged cells should be\n  // based on whether every row or column already had that state before the\n  // unmerge.\n  const baseColStyle = cell.__headerState & TableCellHeaderStates.COLUMN;\n  const colStyles = Array.from({\n    length: colSpan\n  }, (_v, i) => {\n    let colStyle = baseColStyle;\n    for (let rowIdx = 0; colStyle !== 0 && rowIdx < map.length; rowIdx++) {\n      colStyle &= map[rowIdx][i + startColumn].cell.__headerState;\n    }\n    return colStyle;\n  });\n  const baseRowStyle = cell.__headerState & TableCellHeaderStates.ROW;\n  const rowStyles = Array.from({\n    length: rowSpan\n  }, (_v, i) => {\n    let rowStyle = baseRowStyle;\n    for (let colIdx = 0; rowStyle !== 0 && colIdx < map[0].length; colIdx++) {\n      rowStyle &= map[i + startRow][colIdx].cell.__headerState;\n    }\n    return rowStyle;\n  });\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(colStyles[i] | rowStyles[0]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        formatDevErrorMessage(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          $insertFirst(currentRowNode, $createTableCellNode(colStyles[j] | rowStyles[i]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n        }\n      } else {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          insertAfterCell.insertAfter($createTableCellNode(colStyles[j] | rowStyles[i]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(tableNode, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(tableNode, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    formatDevErrorMessage(`Anchor not found in Table`);\n  }\n  if (!(cellBValue !== null)) {\n    formatDevErrorMessage(`Focus not found in Table`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(tableNode, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function getMapRow(i) {\n    let row = tableMap[i];\n    if (row === undefined) {\n      tableMap[i] = row = [];\n    }\n    return row;\n  }\n  const gridChildren = tableNode.getChildren();\n  for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {\n    const row = gridChildren[rowIdx];\n    if (!$isTableRowNode(row)) {\n      formatDevErrorMessage(`Expected TableNode children to be TableRowNode`);\n    }\n    const startMapRow = getMapRow(rowIdx);\n    for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {\n      if (!$isTableCellNode(cell)) {\n        formatDevErrorMessage(`Expected TableRowNode children to be TableCellNode`);\n      } // Skip past any columns that were merged from a higher row\n      while (startMapRow[colIdx] !== undefined) {\n        colIdx++;\n      }\n      const value = {\n        cell,\n        startColumn: colIdx,\n        startRow: rowIdx\n      };\n      const {\n        __rowSpan: rowSpan,\n        __colSpan: colSpan\n      } = cell;\n      for (let j = 0; j < rowSpan; j++) {\n        if (rowIdx + j >= gridChildren.length) {\n          // The table is non-rectangular with a rowSpan\n          // below the last <tr> in the table.\n          // We should probably handle this with a node transform\n          // to ensure that tables are always rectangular but this\n          // will avoid crashes such as #6584\n          // Note that there are probably still latent bugs\n          // regarding colSpan or general cell count mismatches.\n          break;\n        }\n        const mapRow = getMapRow(rowIdx + j);\n        for (let i = 0; i < colSpan; i++) {\n          mapRow[colIdx + i] = value;\n        }\n      }\n      if (cellA !== null && cellAValue === null && cellA.is(cell)) {\n        cellAValue = value;\n      }\n      if (cellB !== null && cellBValue === null && cellB.is(cell)) {\n        cellBValue = value;\n      }\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    formatDevErrorMessage(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    formatDevErrorMessage(`Expected TableRowNode to have a parent TableNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $computeTableCellRectSpans(map, boundary) {\n  const {\n    minColumn,\n    maxColumn,\n    minRow,\n    maxRow\n  } = boundary;\n  let topSpan = 1;\n  let leftSpan = 1;\n  let rightSpan = 1;\n  let bottomSpan = 1;\n  const topRow = map[minRow];\n  const bottomRow = map[maxRow];\n  for (let col = minColumn; col <= maxColumn; col++) {\n    topSpan = Math.max(topSpan, topRow[col].cell.__rowSpan);\n    bottomSpan = Math.max(bottomSpan, bottomRow[col].cell.__rowSpan);\n  }\n  for (let row = minRow; row <= maxRow; row++) {\n    leftSpan = Math.max(leftSpan, map[row][minColumn].cell.__colSpan);\n    rightSpan = Math.max(rightSpan, map[row][maxColumn].cell.__colSpan);\n  }\n  return {\n    bottomSpan,\n    leftSpan,\n    rightSpan,\n    topSpan\n  };\n}\nfunction $computeTableCellRectBoundary(map, cellAMap, cellBMap) {\n  // Initial boundaries based on the anchor and focus cells\n  let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n  let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n  let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n  let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n\n  // Keep expanding until we have a complete rectangle\n  let hasChanges;\n  do {\n    hasChanges = false;\n\n    // Check all cells in the table\n    for (let row = 0; row < map.length; row++) {\n      for (let col = 0; col < map[0].length; col++) {\n        const cell = map[row][col];\n        if (!cell) {\n          continue;\n        }\n        const cellEndCol = cell.startColumn + cell.cell.__colSpan - 1;\n        const cellEndRow = cell.startRow + cell.cell.__rowSpan - 1;\n\n        // Check if this cell intersects with our current selection rectangle\n        const intersectsHorizontally = cell.startColumn <= maxColumn && cellEndCol >= minColumn;\n        const intersectsVertically = cell.startRow <= maxRow && cellEndRow >= minRow;\n\n        // If the cell intersects either horizontally or vertically\n        if (intersectsHorizontally && intersectsVertically) {\n          // Expand boundaries to include this cell completely\n          const newMinColumn = Math.min(minColumn, cell.startColumn);\n          const newMaxColumn = Math.max(maxColumn, cellEndCol);\n          const newMinRow = Math.min(minRow, cell.startRow);\n          const newMaxRow = Math.max(maxRow, cellEndRow);\n\n          // Check if boundaries changed\n          if (newMinColumn !== minColumn || newMaxColumn !== maxColumn || newMinRow !== minRow || newMaxRow !== maxRow) {\n            minColumn = newMinColumn;\n            maxColumn = newMaxColumn;\n            minRow = newMinRow;\n            maxRow = newMaxRow;\n            hasChanges = true;\n          }\n        }\n      }\n    }\n  } while (hasChanges);\n  return {\n    maxColumn,\n    maxRow,\n    minColumn,\n    minRow\n  };\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\nfunction $getCellNodes(tableSelection) {\n  const [[anchorNode, anchorCell, anchorRow, anchorTable], [focusNode, focusCell, focusRow, focusTable]] = ['anchor', 'focus'].map(k => {\n    const node = tableSelection[k].getNode();\n    const cellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableCellNode);\n    if (!$isTableCellNode(cellNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} to be (or a child of) TableCellNode, got key ${node.getKey()} of type ${node.getType()}`);\n    }\n    const rowNode = cellNode.getParent();\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} cell parent to be a TableRowNode`);\n    }\n    const tableNode = rowNode.getParent();\n    if (!$isTableNode(tableNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} row parent to be a TableNode`);\n    }\n    return [node, cellNode, rowNode, tableNode];\n  });\n  // TODO: nested tables may violate this\n  if (!anchorTable.is(focusTable)) {\n    formatDevErrorMessage(`Expected TableSelection anchor and focus to be in the same table`);\n  }\n  return {\n    anchorCell,\n    anchorNode,\n    anchorRow,\n    anchorTable,\n    focusCell,\n    focusNode,\n    focusRow,\n    focusTable\n  };\n}\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * {@link $createTableSelection} unfortunately makes it very easy to create\n   * nonsense selections, so we have a method to see if the selection probably\n   * makes sense.\n   *\n   * @returns true if the TableSelection is (probably) valid\n   */\n  isValid() {\n    return this.tableKey !== 'root' && this.anchor.key !== 'root' && this.anchor.type === 'element' && this.focus.key !== 'root' && this.focus.type === 'element';\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    return $isTableSelection(selection) && this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    // note: closure compiler's acorn does not support ||=\n    this.dirty = this.dirty || tableKey !== this.tableKey || anchorCellKey !== this.anchor.key || focusCellKey !== this.focus.key;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)(this.anchor.key, this.anchor.offset, this.anchor.type), (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)(this.focus.key, this.focus.offset, this.focus.type));\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection.\n   * This will be true if any paragraph in table cells has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    let format = 0;\n    const cellNodes = this.getNodes().filter($isTableCellNode);\n    cellNodes.forEach(cellNode => {\n      const paragraph = cellNode.getFirstChild();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(paragraph)) {\n        format |= paragraph.getTextFormat();\n      }\n    });\n    const formatFlag = lexical__WEBPACK_IMPORTED_MODULE_0__.TEXT_TYPE_TO_FORMAT[type];\n    return (format & formatFlag) !== 0;\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(focusNode)) {\n      formatDevErrorMessage(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const {\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCell);\n    if (!(anchorCellNodeRect !== null)) {\n      formatDevErrorMessage(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCell);\n    if (!(focusCellNodeRect !== null)) {\n      formatDevErrorMessage(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    if (!this.isValid()) {\n      return [];\n    }\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const {\n      anchorTable: tableNode,\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          formatDevErrorMessage(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          formatDevErrorMessage(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    const {\n      minColumn,\n      maxColumn,\n      minRow,\n      maxRow\n    } = $computeTableCellRectBoundary(map, cellAMap, cellBMap);\n\n    // We use a Map here because merged cells in the grid would otherwise\n    // show up multiple times in the nodes array\n    const nodeMap = new Map([[tableNode.getKey(), tableNode]]);\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          formatDevErrorMessage(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodeMap.set(currentRow.getKey(), currentRow);\n          lastRow = currentRow;\n        }\n        if (!nodeMap.has(cell.getKey())) {\n          $visitRecursively(cell, childNode => {\n            nodeMap.set(childNode.getKey(), childNode);\n          });\n        }\n      }\n    }\n    const nodes = Array.from(nodeMap.values());\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isCurrentlyReadOnlyMode)()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes().filter(node => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  // TODO this is a suboptimal design, it doesn't make sense to have\n  // a table selection that isn't associated with a table. This\n  // constructor should have required arguments and in true we\n  // should check that they point to a table and are element points to\n  // cell nodes of that table.\n  const anchor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)('root', 0, 'element');\n  const focus = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $createTableSelectionFrom(tableNode, anchorCell, focusCell) {\n  const tableNodeKey = tableNode.getKey();\n  const anchorCellKey = anchorCell.getKey();\n  const focusCellKey = focusCell.getKey();\n  {\n    if (!tableNode.isAttached()) {\n      formatDevErrorMessage(`$createTableSelectionFrom: tableNode ${tableNodeKey} is not attached`);\n    }\n    if (!tableNode.is($findTableNode(anchorCell))) {\n      formatDevErrorMessage(`$createTableSelectionFrom: anchorCell ${anchorCellKey} is not in table ${tableNodeKey}`);\n    }\n    if (!tableNode.is($findTableNode(focusCell))) {\n      formatDevErrorMessage(`$createTableSelectionFrom: focusCell ${focusCellKey} is not in table ${tableNodeKey}`);\n    } // TODO: Check for rectangular grid\n  }\n  const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  const nextSelection = $isTableSelection(prevSelection) ? prevSelection.clone() : $createTableSelection();\n  nextSelection.set(tableNode.getKey(), anchorCell.getKey(), focusCell.getKey());\n  return nextSelection;\n}\n\n/**\n * Depth first visitor\n * @param node The starting node\n * @param $visit The function to call for each node. If the function returns false, then children of this node will not be explored\n */\nfunction $visitRecursively(node, $visit) {\n  const stack = [[node]];\n  for (let currentArray = stack.at(-1); currentArray !== undefined && stack.length > 0; currentArray = stack.at(-1)) {\n    const currentNode = currentArray.pop();\n    if (currentNode === undefined) {\n      stack.pop();\n    } else if ($visit(currentNode) !== false && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      stack.push(currentNode.getChildren());\n    }\n  }\n}\n\nfunction $getTableAndElementByKey(tableNodeKey, editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)()) {\n  const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(tableNodeKey);\n  if (!$isTableNode(tableNode)) {\n    formatDevErrorMessage(`TableObserver: Expected tableNodeKey ${tableNodeKey} to be a TableNode`);\n  }\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNodeKey));\n  if (!(tableElement !== null)) {\n    formatDevErrorMessage(`TableObserver: Expected to find TableElement in DOM for key ${tableNodeKey}`);\n  }\n  return {\n    tableElement,\n    tableNode\n  };\n}\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.isSelecting = false;\n    this.pointerType = null;\n    this.shouldCheckSelection = false;\n    this.abortController = new AbortController();\n    this.listenerOptions = {\n      signal: this.abortController.signal\n    };\n    this.nextFocus = null;\n    this.trackTable();\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    this.abortController.abort('removeListeners');\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n    this.listenersToRemove.clear();\n  }\n  $lookup() {\n    return $getTableAndElementByKey(this.tableNodeKey, this.editor);\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.getEditorState().read(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const {\n          tableNode,\n          tableElement\n        } = this.$lookup();\n        this.table = getTable(tableNode, tableElement);\n      }, {\n        editor: this.editor\n      });\n    });\n    this.editor.getEditorState().read(() => {\n      const {\n        tableNode,\n        tableElement\n      } = this.$lookup();\n      this.table = getTable(tableNode, tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    }, {\n      editor: this.editor\n    });\n  }\n  $clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.$enableHighlightStyle();\n    const {\n      tableNode,\n      tableElement\n    } = this.$lookup();\n    const grid = getTable(tableNode, tableElement);\n    $updateDOMForSelection(editor, grid, null);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() !== null) {\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(null);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n    }\n  }\n  $enableHighlightStyle() {\n    const editor = this.editor;\n    const {\n      tableElement\n    } = this.$lookup();\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(tableElement, editor._config.theme.tableSelection);\n    tableElement.classList.remove('disable-selection');\n    this.hasHijackedSelectionStyles = false;\n  }\n  $disableHighlightStyle() {\n    const {\n      tableElement\n    } = this.$lookup();\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(tableElement, this.editor._config.theme.tableSelection);\n    this.hasHijackedSelectionStyles = true;\n  }\n  $updateTableTableSelection(selection) {\n    if (selection !== null) {\n      if (!(selection.tableKey === this.tableNodeKey)) {\n        formatDevErrorMessage(`TableObserver.$updateTableTableSelection: selection.tableKey !== this.tableNodeKey ('${selection.tableKey}' !== '${this.tableNodeKey}')`);\n      }\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n      this.updateDOMSelection();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else {\n      this.$clearHighlight();\n    }\n  }\n\n  /**\n   * @internal\n   * Firefox has a strange behavior where pressing the down arrow key from\n   * above the table will move the caret after the table and then lexical\n   * will select the last cell instead of the first.\n   * We do still want to let the browser handle caret movement but we will\n   * use this property to \"tag\" the update so that we can recheck the\n   * selection after the event is processed.\n   */\n  setShouldCheckSelection() {\n    this.shouldCheckSelection = true;\n  }\n  /**\n   * @internal\n   */\n  getAndClearShouldCheckSelection() {\n    if (this.shouldCheckSelection) {\n      this.shouldCheckSelection = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @internal\n   * When handling mousemove events we track what the focus cell should be, but\n   * the DOM selection may end up somewhere else entirely. We don't have an elegant\n   * way to handle this after the DOM selection has been resolved in a\n   * SELECTION_CHANGE_COMMAND callback.\n   */\n  setNextFocus(nextFocus) {\n    this.nextFocus = nextFocus;\n  }\n\n  /** @internal */\n  getAndClearNextFocus() {\n    const {\n      nextFocus\n    } = this;\n    if (nextFocus !== null) {\n      this.nextFocus = null;\n    }\n    return nextFocus;\n  }\n\n  /** @internal */\n  updateDOMSelection() {\n    if (this.anchorCell !== null && this.focusCell !== null) {\n      const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(this.editor._window);\n      // We are not using a native selection for tables, and if we\n      // set one then the reconciler will undo it.\n      // TODO - it would make sense to have one so that native\n      //        copy/paste worked. Right now we have to emulate with\n      //        keyboard events but it won't fire if triggered from the menu\n      if (domSelection && domSelection.rangeCount > 0) {\n        domSelection.removeAllRanges();\n      }\n    }\n  }\n  $setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    const {\n      tableNode\n    } = this.$lookup();\n    const cellX = cell.x;\n    const cellY = cell.y;\n    this.focusCell = cell;\n    if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n    } else if (cellX === this.focusX && cellY === this.focusY) {\n      return false;\n    }\n    this.focusX = cellX;\n    this.focusY = cellY;\n    if (this.isHighlightingCells) {\n      const focusTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n      if (this.tableSelection != null && this.anchorCellNodeKey != null && focusTableCellNode !== null) {\n        this.focusCellNodeKey = focusTableCellNode.getKey();\n        this.tableSelection = $createTableSelectionFrom(tableNode, this.$getAnchorTableCellOrThrow(), focusTableCellNode);\n        (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(this.tableSelection);\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n        $updateDOMForSelection(editor, this.table, this.tableSelection);\n        return true;\n      }\n    }\n    return false;\n  }\n  $getAnchorTableCell() {\n    return this.anchorCellNodeKey ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.anchorCellNodeKey) : null;\n  }\n  $getAnchorTableCellOrThrow() {\n    const anchorTableCell = this.$getAnchorTableCell();\n    if (!(anchorTableCell !== null)) {\n      formatDevErrorMessage(`TableObserver anchorTableCell is null`);\n    }\n    return anchorTableCell;\n  }\n  $getFocusTableCell() {\n    return this.focusCellNodeKey ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.focusCellNodeKey) : null;\n  }\n  $getFocusTableCellOrThrow() {\n    const focusTableCell = this.$getFocusTableCell();\n    if (!(focusTableCell !== null)) {\n      formatDevErrorMessage(`TableObserver focusTableCell is null`);\n    }\n    return focusTableCell;\n  }\n  $setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    const {\n      tableNode\n    } = this.$lookup();\n    const anchorTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n    if (anchorTableCellNode !== null) {\n      const anchorNodeKey = anchorTableCellNode.getKey();\n      this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n      this.anchorCellNodeKey = anchorNodeKey;\n    }\n  }\n  $formatCells(type) {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isTableSelection(selection)) {\n      formatDevErrorMessage(`Expected Table selection`);\n    }\n    const formatSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n    const anchor = formatSelection.anchor;\n    const focus = formatSelection.focus;\n    const cellNodes = selection.getNodes().filter($isTableCellNode);\n    if (!(cellNodes.length > 0)) {\n      formatDevErrorMessage(`No table cells present`);\n    }\n    const paragraph = cellNodes[0].getFirstChild();\n    const alignFormatWith = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(paragraph) ? paragraph.getFormatFlags(type, null) : null;\n    cellNodes.forEach(cellNode => {\n      anchor.set(cellNode.getKey(), 0, 'element');\n      focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n      formatSelection.formatText(type, alignFormatWith);\n    });\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection);\n    this.editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n  }\n  $clearText() {\n    const {\n      editor\n    } = this;\n    const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.tableNodeKey);\n    if (!$isTableNode(tableNode)) {\n      throw new Error('Expected TableNode.');\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isTableSelection(selection)) {\n      formatDevErrorMessage(`Expected TableSelection`);\n    }\n    const selectedNodes = selection.getNodes().filter($isTableCellNode);\n\n    // Check if the entire table is selected by verifying first and last cells\n    const firstRow = tableNode.getFirstChild();\n    const lastRow = tableNode.getLastChild();\n    const isEntireTableSelected = selectedNodes.length > 0 && firstRow !== null && lastRow !== null && $isTableRowNode(firstRow) && $isTableRowNode(lastRow) && selectedNodes[0] === firstRow.getFirstChild() && selectedNodes[selectedNodes.length - 1] === lastRow.getLastChild();\n    if (isEntireTableSelected) {\n      tableNode.selectPrevious();\n      const parent = tableNode.getParent();\n      // Delete entire table\n      tableNode.remove();\n      // Handle case when table was the only node\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(parent) && parent.isEmpty()) {\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, undefined);\n      }\n      return;\n    }\n    selectedNodes.forEach(cellNode => {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(cellNode)) {\n        const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n        const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)();\n        paragraphNode.append(textNode);\n        cellNode.append(paragraphNode);\n        cellNode.getChildren().forEach(child => {\n          if (child !== paragraphNode) {\n            child.remove();\n          }\n        });\n      }\n    });\n    $updateDOMForSelection(editor, this.table, null);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(null);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst isPointerDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction isHTMLTableElement(el) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(el) && el.nodeName === 'TABLE';\n}\nfunction getTableElement(tableNode, dom) {\n  if (!dom) {\n    return dom;\n  }\n  const element = isHTMLTableElement(dom) ? dom : tableNode.getDOMSlot(dom).element;\n  if (!(element.nodeName === 'TABLE')) {\n    formatDevErrorMessage(`getTableElement: Expecting table in as DOM node for TableNode, not ${dom.nodeName}`);\n  }\n  return element;\n}\nfunction getEditorWindow(editor) {\n  return editor._window;\n}\nfunction $findParentTableCellNodeInTable(tableNode, node) {\n  for (let currentNode = node, lastTableCellNode = null; currentNode !== null; currentNode = currentNode.getParent()) {\n    if (tableNode.is(currentNode)) {\n      return lastTableCellNode;\n    } else if ($isTableCellNode(currentNode)) {\n      lastTableCellNode = currentNode;\n    }\n  }\n  return null;\n}\nconst ARROW_KEY_COMMANDS_WITH_DIRECTION = [[lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, 'down'], [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, 'up'], [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, 'backward'], [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_RIGHT_COMMAND, 'forward']];\nconst DELETE_TEXT_COMMANDS = [lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_WORD_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND];\nconst DELETE_KEY_COMMANDS = [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_BACKSPACE_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_DELETE_COMMAND];\nfunction applyTableHandlers(tableNode, element, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  const editorWindow = getEditorWindow(editor);\n  if (!(rootElement !== null && editorWindow !== null)) {\n    formatDevErrorMessage(`applyTableHandlers: editor has no root element set`);\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const tableElement = getTableElement(tableNode, element);\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  tableObserver.listenersToRemove.add(() => detachTableObserverFromTableElement(tableElement, tableObserver));\n  const createPointerHandlers = () => {\n    if (tableObserver.isSelecting) {\n      return;\n    }\n    const onPointerUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('pointerup', onPointerUp);\n      editorWindow.removeEventListener('pointermove', onPointerMove);\n    };\n    const onPointerMove = moveEvent => {\n      if (!isPointerDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n        tableObserver.isSelecting = false;\n        editorWindow.removeEventListener('pointerup', onPointerUp);\n        editorWindow.removeEventListener('pointermove', onPointerMove);\n        return;\n      }\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(moveEvent.target)) {\n        return;\n      }\n      let focusCell = null;\n      // In firefox the moveEvent.target may be captured so we must always\n      // consult the coordinates #7245\n      const override = !(IS_FIREFOX || tableElement.contains(moveEvent.target));\n      if (override) {\n        focusCell = getDOMCellInTableFromTarget(tableElement, moveEvent.target);\n      } else {\n        for (const el of document.elementsFromPoint(moveEvent.clientX, moveEvent.clientY)) {\n          focusCell = getDOMCellInTableFromTarget(tableElement, el);\n          if (focusCell) {\n            break;\n          }\n        }\n      }\n      if (focusCell && (tableObserver.focusCell === null || focusCell.elem !== tableObserver.focusCell.elem)) {\n        tableObserver.setNextFocus({\n          focusCell,\n          override\n        });\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n      }\n    };\n    tableObserver.isSelecting = true;\n    editorWindow.addEventListener('pointerup', onPointerUp, tableObserver.listenerOptions);\n    editorWindow.addEventListener('pointermove', onPointerMove, tableObserver.listenerOptions);\n  };\n  const onPointerDown = event => {\n    tableObserver.pointerType = event.pointerType;\n    if (event.button !== 0 || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(event.target) || !editorWindow) {\n      return;\n    }\n    const targetCell = getDOMCellFromTarget(event.target);\n    if (targetCell !== null) {\n      editor.update(() => {\n        const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n        // We can't trust Firefox to do the right thing with the selection and\n        // we don't have a proper state machine to do this \"correctly\" but\n        // if we go ahead and make the table selection now it will work\n        if (IS_FIREFOX && event.shiftKey && $isSelectionInTable(prevSelection, tableNode) && ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) || $isTableSelection(prevSelection))) {\n          const prevAnchorNode = prevSelection.anchor.getNode();\n          const prevAnchorCell = $findParentTableCellNodeInTable(tableNode, prevSelection.anchor.getNode());\n          if (prevAnchorCell) {\n            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCell));\n            tableObserver.$setFocusCellForSelection(targetCell);\n            stopEvent(event);\n          } else {\n            const newSelection = tableNode.isBefore(prevAnchorNode) ? tableNode.selectStart() : tableNode.selectEnd();\n            newSelection.anchor.set(prevSelection.anchor.key, prevSelection.anchor.offset, prevSelection.anchor.type);\n          }\n        } else {\n          // Only set anchor cell for selection if this is not a simple touch tap\n          // Touch taps should not initiate table selection mode\n          if (event.pointerType !== 'touch') {\n            tableObserver.$setAnchorCellForSelection(targetCell);\n          }\n        }\n      });\n    }\n    createPointerHandlers();\n  };\n  tableElement.addEventListener('pointerdown', onPointerDown, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    tableElement.removeEventListener('pointerdown', onPointerDown);\n  });\n  const onTripleClick = event => {\n    if (event.detail >= 3 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(event.target)) {\n      const targetCell = getDOMCellFromTarget(event.target);\n      if (targetCell !== null) {\n        event.preventDefault();\n      }\n    }\n  };\n  tableElement.addEventListener('mousedown', onTripleClick, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    tableElement.removeEventListener('mousedown', onTripleClick);\n  });\n\n  // Clear selection when clicking outside of dom.\n  const pointerDownCallback = event => {\n    const target = event.target;\n    if (event.button !== 0 || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(target)) {\n      return;\n    }\n    editor.update(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.$clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('pointerdown', pointerDownCallback, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    editorWindow.removeEventListener('pointerdown', pointerDownCallback);\n  });\n  for (const [command, direction] of ARROW_KEY_COMMANDS_WITH_DIRECTION) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, event => $handleArrowKey(editor, event, direction, tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = $findParentTableCellNodeInTable(tableNode, selection.focus.getNode());\n      if (focusCellNode !== null) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearText();\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = $findParentTableCellNodeInTable(tableNode, selection.anchor.getNode());\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.$clearText();\n        return true;\n      }\n      const nearestElementNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n));\n      const topLevelCellElementNode = nearestElementNode && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(nearestElementNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && $isTableCellNode(n.getParent()));\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(topLevelCellElementNode) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(nearestElementNode)) {\n        return false;\n      }\n      if (command === lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  for (const command of DELETE_TEXT_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  }\n  const $deleteCellHandler = event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!($isTableSelection(selection) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection))) {\n      return false;\n    }\n\n    // If the selection is inside the table but should remove the whole table\n    // we expand the selection so that both the anchor and focus are outside\n    // the table and the editor's command listener will handle the delete\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    if (isAnchorInside !== isFocusInside) {\n      const tablePoint = isAnchorInside ? 'anchor' : 'focus';\n      const outerPoint = isAnchorInside ? 'focus' : 'anchor';\n      // Preserve the outer point\n      const {\n        key,\n        offset,\n        type\n      } = selection[outerPoint];\n      // Expand the selection around the table\n      const newSelection = tableNode[selection[tablePoint].isBefore(selection[outerPoint]) ? 'selectPrevious' : 'selectNext']();\n      // Restore the outer point of the selection\n      newSelection[outerPoint].set(key, offset, type);\n      // Let the base implementation handle the rest\n      return false;\n    }\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.$clearText();\n      return true;\n    }\n    return false;\n  };\n  for (const command of DELETE_KEY_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, $deleteCellHandler, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CUT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection) {\n      if (!($isTableSelection(selection) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection))) {\n        return false;\n      }\n      // Copying to the clipboard is async so we must capture the data\n      // before we delete it\n      void (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.copyToClipboard)(editor, (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent) ? event : null, (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$getClipboardDataFromSelection)(selection));\n      const intercepted = $deleteCellHandler(event);\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        selection.removeText();\n        return true;\n      }\n      return intercepted;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_TEXT_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$formatCells(payload);\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n\n    // Align the table if the entire table is selected\n    if ($isFullTableSelection(selection, tableNode)) {\n      tableNode.setFormat(formatType);\n      return true;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow + anchorCell.cell.__rowSpan - 1, focusCell.startRow + focusCell.cell.__rowSpan - 1);\n    const maxColumn = Math.max(anchorCell.startColumn + anchorCell.cell.__colSpan - 1, focusCell.startColumn + focusCell.cell.__colSpan - 1);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    const visited = new Set();\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        if (visited.has(cell)) {\n          continue;\n        }\n        visited.add(cell);\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearHighlight();\n      return false;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_TAB_COMMAND, event => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null || !tableNode.is($findTableNode(tableCellNode))) {\n        return false;\n      }\n      stopEvent(event);\n      $selectAdjacentCell(tableCellNode, event.shiftKey ? 'previous' : 'next');\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, (selectionPayload, dispatchEditor) => {\n    if (editor !== dispatchEditor) {\n      return false;\n    }\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor, focus] = anchorAndFocus;\n    const [anchorCellNode, anchorRowNode, gridNode] = $getNodeTriplet(anchor);\n    const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), n => $isTableCellNode(n));\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableRowNode(anchorRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const templateGrid = nodes[0];\n    const [initialGridMap, anchorCellMap, focusCellMap] = $computeTableMap(gridNode, anchorCellNode, focusCellNode);\n    const [templateGridMap] = $computeTableMapSkipCellCheck(templateGrid, null, null);\n    const initialRowCount = initialGridMap.length;\n    const initialColCount = initialRowCount > 0 ? initialGridMap[0].length : 0;\n\n    // If we have a range selection, we'll fit the template grid into the\n    // table, growing the table if necessary.\n    let startRow = anchorCellMap.startRow;\n    let startCol = anchorCellMap.startColumn;\n    let affectedRowCount = templateGridMap.length;\n    let affectedColCount = affectedRowCount > 0 ? templateGridMap[0].length : 0;\n    if (isTableSelection) {\n      // If we have a table selection, we'll only modify the cells within\n      // the selection boundary.\n      const selectionBoundary = $computeTableCellRectBoundary(initialGridMap, anchorCellMap, focusCellMap);\n      const selectionRowCount = selectionBoundary.maxRow - selectionBoundary.minRow + 1;\n      const selectionColCount = selectionBoundary.maxColumn - selectionBoundary.minColumn + 1;\n      startRow = selectionBoundary.minRow;\n      startCol = selectionBoundary.minColumn;\n      affectedRowCount = Math.min(affectedRowCount, selectionRowCount);\n      affectedColCount = Math.min(affectedColCount, selectionColCount);\n    }\n\n    // Step 1: Unmerge all merged cells within the affected area\n    let didPerformMergeOperations = false;\n    const lastRowForUnmerge = Math.min(initialRowCount, startRow + affectedRowCount) - 1;\n    const lastColForUnmerge = Math.min(initialColCount, startCol + affectedColCount) - 1;\n    const unmergedKeys = new Set();\n    for (let row = startRow; row <= lastRowForUnmerge; row++) {\n      for (let col = startCol; col <= lastColForUnmerge; col++) {\n        const cellMap = initialGridMap[row][col];\n        if (unmergedKeys.has(cellMap.cell.getKey())) {\n          continue; // cell was a merged cell that was already handled\n        }\n        if (cellMap.cell.__rowSpan === 1 && cellMap.cell.__colSpan === 1) {\n          continue; // cell is not a merged cell\n        }\n        $unmergeCellNode(cellMap.cell);\n        unmergedKeys.add(cellMap.cell.getKey());\n        didPerformMergeOperations = true;\n      }\n    }\n    let [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n\n    // Step 2: Expand current table (if needed)\n    const rowsToInsert = affectedRowCount - initialRowCount + startRow;\n    for (let i = 0; i < rowsToInsert; i++) {\n      const cellMap = interimGridMap[initialRowCount - 1][0];\n      $insertTableRowAtNode(cellMap.cell);\n    }\n    const colsToInsert = affectedColCount - initialColCount + startCol;\n    for (let i = 0; i < colsToInsert; i++) {\n      const cellMap = interimGridMap[0][initialColCount - 1];\n      $insertTableColumnAtNode(cellMap.cell, true, false);\n    }\n    [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n\n    // Step 3: Merge cells and set cell content, to match template grid\n    for (let row = startRow; row < startRow + affectedRowCount; row++) {\n      for (let col = startCol; col < startCol + affectedColCount; col++) {\n        const templateRow = row - startRow;\n        const templateCol = col - startCol;\n        const templateCellMap = templateGridMap[templateRow][templateCol];\n        if (templateCellMap.startRow !== templateRow || templateCellMap.startColumn !== templateCol) {\n          continue; // cell is a merged cell that was already handled\n        }\n        const templateCell = templateCellMap.cell;\n        if (templateCell.__rowSpan !== 1 || templateCell.__colSpan !== 1) {\n          const cellsToMerge = [];\n          const lastRowForMerge = Math.min(row + templateCell.__rowSpan, startRow + affectedRowCount) - 1;\n          const lastColForMerge = Math.min(col + templateCell.__colSpan, startCol + affectedColCount) - 1;\n          for (let r = row; r <= lastRowForMerge; r++) {\n            for (let c = col; c <= lastColForMerge; c++) {\n              const cellMap = interimGridMap[r][c];\n              cellsToMerge.push(cellMap.cell);\n            }\n          }\n          $mergeCells(cellsToMerge);\n          didPerformMergeOperations = true;\n        }\n        const {\n          cell\n        } = interimGridMap[row][col];\n        const originalChildren = cell.getChildren();\n        templateCell.getChildren().forEach(child => {\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n            const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n            paragraphNode.append(child);\n            cell.append(child);\n          } else {\n            cell.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n      }\n    }\n    if (isTableSelection && didPerformMergeOperations) {\n      // reset the table selection in case the anchor or focus cell was\n      // removed via merge operations\n      const [finalGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n      const newAnchorCellMap = finalGridMap[anchorCellMap.startRow][anchorCellMap.startColumn];\n      newAnchorCellMap.cell.selectEnd();\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n    const nextFocus = tableObserver.getAndClearNextFocus();\n    if (nextFocus !== null) {\n      const {\n        focusCell\n      } = nextFocus;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        if (focusCell.x === tableObserver.focusX && focusCell.y === tableObserver.focusY) {\n          // The selection is already the correct table selection\n          return false;\n        } else {\n          tableObserver.$setFocusCellForSelection(focusCell);\n          return true;\n        }\n      } else if (focusCell !== tableObserver.anchorCell && $isSelectionInTable(selection, tableNode)) {\n        // The selection has crossed cells\n        tableObserver.$setFocusCellForSelection(focusCell);\n        return true;\n      }\n    }\n    const shouldCheckSelection = tableObserver.getAndClearShouldCheckSelection();\n    // If they pressed the down arrow with the selection outside of the\n    // table, and then the selection ends up in the table but not in the\n    // first cell, then move the selection to the first cell.\n    if (shouldCheckSelection && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n      const anchor = selection.anchor.getNode();\n      const firstRow = tableNode.getFirstChild();\n      const anchorCell = $findCellNode(anchor);\n      if (anchorCell !== null && $isTableRowNode(firstRow)) {\n        const firstCell = firstRow.getFirstChild();\n        if ($isTableCellNode(firstCell) && tableNode.is((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorCell, node => node.is(tableNode) || node.is(firstCell)))) {\n          // The selection moved to the table, but not in the first cell\n          firstCell.selectStart();\n          return true;\n        }\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartiallyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartiallyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), 'element');\n        } else if (isAnchorInside) {\n          const [tableMap] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          /**\n           * If isBackward, set the anchor to be at the end of the table so that when the cursor moves outside of\n           * the table in the backward direction, the entire table will be selected from its end.\n           * Otherwise, if forward, set the anchor to be at the start of the table so that when the focus is dragged\n           * outside th end of the table, it will start from the beginning of the table.\n           */\n          newSelection.anchor.set(isBackward ? lastCell.getKey() : firstCell.getKey(), isBackward ? lastCell.getChildrenSize() : 0, 'element');\n        }\n        (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into table selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, anchorCellNode));\n          tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);\n        }\n\n        // Handle case when the pointer type is touch and the current and\n        // previous selection are collapsed, and the previous anchor and current\n        // focus cell nodes are different, then we convert it into table selection\n        // However, only do this if the table observer is actively selecting (user dragging)\n        // to prevent unwanted selections when simply tapping between cells on mobile\n        if (tableObserver.pointerType === 'touch' && tableObserver.isSelecting && selection.isCollapsed() && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && prevSelection.isCollapsed()) {\n          const prevAnchorCellNode = $findCellNode(prevSelection.anchor.getNode());\n          if (prevAnchorCellNode && !prevAnchorCellNode.is(focusCellNode)) {\n            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCellNode));\n            tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);\n            tableObserver.pointerType = null;\n          }\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(editorWindow);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.isParentOf(focusNode);\n        const anchorNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.isParentOf(anchorNode);\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelectionFromDom)(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction detachTableObserverFromTableElement(tableElement, tableObserver) {\n  if (getTableObserverFromTableElement(tableElement) === tableObserver) {\n    delete tableElement[LEXICAL_ELEMENT_KEY];\n  }\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  if (!(getTableObserverFromTableElement(tableElement) === null)) {\n    formatDevErrorMessage(`tableElement already has an attached TableObserver`);\n  }\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY] || null;\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getDOMCellInTableFromTarget(table, node) {\n  if (!table.contains(node)) {\n    return null;\n  }\n  let cell = null;\n  for (let currentNode = node; currentNode != null; currentNode = currentNode.parentNode) {\n    if (currentNode === table) {\n      return cell;\n    }\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      cell = currentNode._cell || null;\n    }\n  }\n  return null;\n}\nfunction getTable(tableNode, dom) {\n  const tableElement = getTableElement(tableNode, dom);\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.querySelector('tr');\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.$disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.$enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nfunction $selectAdjacentCell(tableCellNode, direction) {\n  const siblingMethod = direction === 'next' ? 'getNextSibling' : 'getPreviousSibling';\n  const childMethod = direction === 'next' ? 'getFirstChild' : 'getLastChild';\n  const sibling = tableCellNode[siblingMethod]();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n    return sibling.selectEnd();\n  }\n  const parentRow = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(tableCellNode, $isTableRowNode);\n  if (!(parentRow !== null)) {\n    formatDevErrorMessage(`selectAdjacentCell: Cell not in table row`);\n  }\n  for (let nextRow = parentRow[siblingMethod](); $isTableRowNode(nextRow); nextRow = nextRow[siblingMethod]()) {\n    const child = nextRow[childMethod]();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n      return child.selectEnd();\n    }\n  }\n  const parentTable = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(parentRow, $isTableNode);\n  if (!(parentTable !== null)) {\n    formatDevErrorMessage(`selectAdjacentCell: Row not in table`);\n  }\n  return direction === 'next' ? parentTable.selectNext() : parentTable.selectPrevious();\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nfunction getCorner(rect, cellValue) {\n  let colName;\n  let rowName;\n  if (cellValue.startColumn === rect.minColumn) {\n    colName = 'minColumn';\n  } else if (cellValue.startColumn + cellValue.cell.__colSpan - 1 === rect.maxColumn) {\n    colName = 'maxColumn';\n  } else {\n    return null;\n  }\n  if (cellValue.startRow === rect.minRow) {\n    rowName = 'minRow';\n  } else if (cellValue.startRow + cellValue.cell.__rowSpan - 1 === rect.maxRow) {\n    rowName = 'maxRow';\n  } else {\n    return null;\n  }\n  return [colName, rowName];\n}\nfunction getCornerOrThrow(rect, cellValue) {\n  const corner = getCorner(rect, cellValue);\n  if (!(corner !== null)) {\n    formatDevErrorMessage(`getCornerOrThrow: cell ${cellValue.cell.getKey()} is not at a corner of rect`);\n  }\n  return corner;\n}\nfunction oppositeCorner([colName, rowName]) {\n  return [colName === 'minColumn' ? 'maxColumn' : 'minColumn', rowName === 'minRow' ? 'maxRow' : 'minRow'];\n}\nfunction cellAtCornerOrThrow(tableMap, rect, [colName, rowName]) {\n  const rowNum = rect[rowName];\n  const rowMap = tableMap[rowNum];\n  if (!(rowMap !== undefined)) {\n    formatDevErrorMessage(`cellAtCornerOrThrow: ${rowName} = ${String(rowNum)} missing in tableMap`);\n  }\n  const colNum = rect[colName];\n  const cell = rowMap[colNum];\n  if (!(cell !== undefined)) {\n    formatDevErrorMessage(`cellAtCornerOrThrow: ${colName} = ${String(colNum)} missing in tableMap`);\n  }\n  return cell;\n}\nfunction $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue) {\n  // We are sure that the focus now either contracts or expands the rect\n  // but both the anchor and focus might be moved to ensure a rectangle\n  // given a potentially ragged merge shape\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorCorner = getCorner(rect, anchorCellValue);\n  if (anchorCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, anchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(anchorCorner))];\n  }\n  const newFocusCorner = getCorner(rect, newFocusCellValue);\n  if (newFocusCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newFocusCorner)), cellAtCornerOrThrow(tableMap, rect, newFocusCorner)];\n  }\n  // TODO this doesn't have to be arbitrary, use the closest corner instead\n  const newAnchorCorner = ['minColumn', 'minRow'];\n  return [cellAtCornerOrThrow(tableMap, rect, newAnchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newAnchorCorner))];\n}\nfunction $adjustFocusInDirection(tableObserver, tableMap, anchorCellValue, focusCellValue, direction) {\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, focusCellValue);\n  const spans = $computeTableCellRectSpans(tableMap, rect);\n  const {\n    topSpan,\n    leftSpan,\n    bottomSpan,\n    rightSpan\n  } = spans;\n  const anchorCorner = getCornerOrThrow(rect, anchorCellValue);\n  const [focusColumn, focusRow] = oppositeCorner(anchorCorner);\n  let fCol = rect[focusColumn];\n  let fRow = rect[focusRow];\n  if (direction === 'forward') {\n    fCol += focusColumn === 'maxColumn' ? 1 : leftSpan;\n  } else if (direction === 'backward') {\n    fCol -= focusColumn === 'minColumn' ? 1 : rightSpan;\n  } else if (direction === 'down') {\n    fRow += focusRow === 'maxRow' ? 1 : topSpan;\n  } else if (direction === 'up') {\n    fRow -= focusRow === 'minRow' ? 1 : bottomSpan;\n  }\n  const targetRowMap = tableMap[fRow];\n  if (targetRowMap === undefined) {\n    return false;\n  }\n  const newFocusCellValue = targetRowMap[fCol];\n  if (newFocusCellValue === undefined) {\n    return false;\n  }\n  // We can be certain that anchorCellValue and newFocusCellValue are\n  // contained within the desired selection, but we are not certain if\n  // they need to be expanded or not to maintain a rectangular shape\n  const [finalAnchorCell, finalFocusCell] = $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalAnchorCell.cell);\n  const focusDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalFocusCell.cell);\n  tableObserver.$setAnchorCellForSelection(anchorDOM);\n  tableObserver.$setFocusCellForSelection(focusDOM, true);\n  return true;\n}\nfunction $isSelectionInTable(selection, tableNode) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection)) {\n    // TODO this should probably return false if there's an unrelated\n    //      shadow root between the node and the table (e.g. another table,\n    //      collapsible, etc.)\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction $isFullTableSelection(selection, tableNode) {\n  if ($isTableSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (tableNode && anchorNode && focusNode) {\n      const [map] = $computeTableMap(tableNode, anchorNode, focusNode);\n      return anchorNode.getKey() === map[0][0].cell.getKey() && focusNode.getKey() === map[map.length - 1].at(-1).cell.getKey();\n    }\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const editorThemeClasses = editor._config.theme;\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(element);\n  if (!$isTableCellNode(node)) {\n    formatDevErrorMessage(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, editorThemeClasses.tableCellSelected);\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(element);\n  if (!$isTableCellNode(node)) {\n    formatDevErrorMessage(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const editorThemeClasses = editor._config.theme;\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(element, editorThemeClasses.tableCellSelected);\n}\nfunction $findCellNode(node) {\n  const cellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $getBlockParentIfFirstNode(node) {\n  for (let prevNode = node, currentNode = node; currentNode !== null; prevNode = currentNode, currentNode = currentNode.getParent()) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      if (currentNode !== prevNode && currentNode.getFirstChild() !== prevNode) {\n        // Not the first child or the initial node\n        return null;\n      } else if (!currentNode.isInline()) {\n        return currentNode;\n      }\n    }\n  }\n  return null;\n}\nfunction $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, isBackward, tableNode, tableObserver) {\n  const initialFocus = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$caretFromPoint)(selection.focus, isBackward ? 'previous' : 'next');\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isExtendableTextPointCaret)(initialFocus)) {\n    return false;\n  }\n  let lastCaret = initialFocus;\n  // TableCellNode is the only shadow root we are interested in piercing so\n  // we find the last internal caret and then check its parent\n  for (const nextCaret of (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$extendCaretToRange)(initialFocus).iterNodeCarets('shadowRoot')) {\n    if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isSiblingCaret)(nextCaret) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(nextCaret.origin))) {\n      return false;\n    }\n    lastCaret = nextCaret;\n  }\n  const lastCaretParent = lastCaret.getParentAtCaret();\n  if (!$isTableCellNode(lastCaretParent)) {\n    return false;\n  }\n  const anchorCell = lastCaretParent;\n  const focusCaret = $findNextTableCell((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(anchorCell, lastCaret.direction));\n  const anchorCellTable = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorCell, $isTableNode);\n  if (!(anchorCellTable && anchorCellTable.is(tableNode))) {\n    return false;\n  }\n  const anchorCellDOM = editor.getElementByKey(anchorCell.getKey());\n  const anchorDOMCell = getDOMCellFromTarget(anchorCellDOM);\n  if (!anchorCellDOM || !anchorDOMCell) {\n    return false;\n  }\n  const anchorCellTableElement = $getElementForTableNode(editor, anchorCellTable);\n  tableObserver.table = anchorCellTableElement;\n  if (!focusCaret) {\n    if (alter === 'extend') {\n      // extend the selection from a range inside the cell to a table selection of the cell\n      tableObserver.$setAnchorCellForSelection(anchorDOMCell);\n      tableObserver.$setFocusCellForSelection(anchorDOMCell, true);\n    } else {\n      // exit the table\n      const outerFocusCaret = $getTableExitCaret((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(anchorCellTable, initialFocus.direction));\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.anchor, outerFocusCaret);\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.focus, outerFocusCaret);\n    }\n  } else if (alter === 'extend') {\n    const focusDOMCell = getDOMCellFromTarget(editor.getElementByKey(focusCaret.origin.getKey()));\n    if (!focusDOMCell) {\n      return false;\n    }\n    tableObserver.$setAnchorCellForSelection(anchorDOMCell);\n    tableObserver.$setFocusCellForSelection(focusDOMCell, true);\n  } else {\n    // alter === 'move'\n    const innerFocusCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)(focusCaret);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.anchor, innerFocusCaret);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.focus, innerFocusCaret);\n  }\n  stopEvent(event);\n  return true;\n}\nfunction $getTableExitCaret(initialCaret) {\n  const adjacent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(initialCaret);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(adjacent) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)(adjacent) : initialCaret;\n}\nfunction $findNextTableCell(initialCaret) {\n  for (const nextCaret of (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$extendCaretToRange)(initialCaret).iterNodeCarets('root')) {\n    const {\n      origin\n    } = nextCaret;\n    if ($isTableCellNode(origin)) {\n      // not sure why ts isn't narrowing here (even if the guard is on nextCaret.origin)\n      // but returning a new caret is fine\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(nextCaret)) {\n        return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(origin, initialCaret.direction);\n      }\n    } else if (!$isTableRowNode(origin)) {\n      break;\n    }\n  }\n  return null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      if (direction === 'backward') {\n        if (selection.focus.offset > 0) {\n          return false;\n        }\n        const parentNode = $getBlockParentIfFirstNode(selection.focus.getNode());\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        if (event.shiftKey) {\n          selection.focus.set(siblingNode.getParentOrThrow().getKey(), siblingNode.getIndexWithinParent(), 'element');\n        } else {\n          siblingNode.selectEnd();\n        }\n        return true;\n      } else if (event.shiftKey && (direction === 'up' || direction === 'down')) {\n        const focusNode = selection.focus.getNode();\n        const isTableUnselect = !selection.isCollapsed() && (direction === 'up' && !selection.isBackward() || direction === 'down' && selection.isBackward());\n        if (isTableUnselect) {\n          let focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusNode, n => $isTableNode(n));\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusParentNode, $isTableNode);\n          }\n          if (focusParentNode !== tableNode) {\n            return false;\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if (!sibling) {\n            return false;\n          }\n          let newOffset = 0;\n          if (direction === 'up') {\n            if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n              newOffset = sibling.getChildrenSize();\n            }\n          }\n          let newFocusNode = sibling;\n          if (direction === 'up') {\n            if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n              const lastCell = sibling.getLastChild();\n              newFocusNode = lastCell ? lastCell : sibling;\n              newOffset = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(newFocusNode) ? newFocusNode.getTextContentSize() : 0;\n            }\n          }\n          const newSelection = selection.clone();\n          newSelection.focus.set(newFocusNode.getKey(), newOffset, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(newFocusNode) ? 'text' : 'element');\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n          stopEvent(event);\n          return true;\n        } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(focusNode)) {\n          const selectedNode = direction === 'up' ? selection.getNodes()[selection.getNodes().length - 1] : selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = $findParentTableCellNodeInTable(tableNode, selectedNode);\n            if (tableCellNode !== null) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);\n              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);\n              tableObserver.$setAnchorCellForSelection(firstCellDOM);\n              tableObserver.$setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          let focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && !n.isInline());\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusParentNode, $isTableNode);\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set((direction === 'up' ? firstCellNode : lastCellNode).getKey(), direction === 'up' ? 0 : lastCellNode.getChildrenSize(), 'element');\n            stopEvent(event);\n            (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    if (direction === 'down' && $isScrollableTablesActive(editor)) {\n      // Enable Firefox workaround\n      tableObserver.setShouldCheckSelection();\n    }\n    return false;\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    if (direction === 'backward' || direction === 'forward') {\n      const alter = event.shiftKey ? 'extend' : 'move';\n      return $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, direction === 'backward', tableNode, tableObserver);\n    }\n    if (selection.isCollapsed()) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), $isTableCellNode);\n      const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), $isTableCellNode);\n      if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n        return false;\n      }\n      const anchorCellTable = $findTableNode(anchorCellNode);\n      if (anchorCellTable !== tableNode && anchorCellTable != null) {\n        const anchorCellTableElement = getTableElement(anchorCellTable, editor.getElementByKey(anchorCellTable.getKey()));\n        if (anchorCellTableElement != null) {\n          tableObserver.table = getTable(anchorCellTable, anchorCellTableElement);\n          return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n        }\n      }\n      const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n      const anchorDOM = editor.getElementByKey(anchor.key);\n      if (anchorDOM == null || anchorCellDom == null) {\n        return false;\n      }\n      let edgeSelectionRect;\n      if (anchor.type === 'element') {\n        edgeSelectionRect = anchorDOM.getBoundingClientRect();\n      } else {\n        const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(getEditorWindow(editor));\n        if (domSelection === null || domSelection.rangeCount === 0) {\n          return false;\n        }\n        const range = domSelection.getRangeAt(0);\n        edgeSelectionRect = range.getBoundingClientRect();\n      }\n      const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n      if (edgeChild == null) {\n        return false;\n      }\n      const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n      if (edgeChildDOM == null) {\n        return false;\n      }\n      const edgeRect = edgeChildDOM.getBoundingClientRect();\n      const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n      if (isExiting) {\n        stopEvent(event);\n        const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n        if (event.shiftKey) {\n          const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n          tableObserver.$setAnchorCellForSelection(cell);\n          tableObserver.$setFocusCellForSelection(cell, true);\n        } else {\n          return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n        }\n        return true;\n      }\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    if (!$isTableNode(tableNodeFromSelection)) {\n      formatDevErrorMessage(`$handleArrowKey: TableSelection.getNodes()[0] expected to be TableNode`);\n    }\n    const tableElement = getTableElement(tableNodeFromSelection, editor.getElementByKey(tableNodeFromSelection.getKey()));\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.$updateTableTableSelection(selection);\n    const grid = getTable(tableNodeFromSelection, tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.$setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const [tableMap, anchorValue, focusValue] = $computeTableMap(tableNode, anchorCellNode, focusCellNode);\n      return $adjustFocusInDirection(tableObserver, tableMap, anchorValue, focusValue, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(getEditorWindow(editor));\n  if (!domSelection) {\n    return undefined;\n  }\n  const domAnchorNode = domSelection.anchorNode;\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()));\n  // We are only interested in the scenario where the\n  // native selection anchor is:\n  // - at or inside the table's parent DOM\n  // - and NOT at or inside the table DOM\n  // It may be adjacent to the table DOM (e.g. in a wrapper)\n  if (!domAnchorNode || !tableNodeParentDOM || !tableElement || !tableNodeParentDOM.contains(domAnchorNode) || tableElement.contains(domAnchorNode)) {\n    return undefined;\n  }\n  const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\nfunction $getObserverCellFromCellNodeOrThrow(tableObserver, tableCellNode) {\n  const {\n    tableNode\n  } = tableObserver.$lookup();\n  const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n  return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n}\nfunction $getNearestTableCellInTableFromDOMNode(tableNode, startingDOM, editorState) {\n  return $findParentTableCellNodeInTable(tableNode, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(startingDOM, editorState));\n}\n\nfunction isHTMLDivElement(element) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) && element.nodeName === 'DIV';\n}\nfunction updateColgroup(dom, config, colCount, colWidths) {\n  const colGroup = dom.querySelector('colgroup');\n  if (!colGroup) {\n    return;\n  }\n  const cols = [];\n  for (let i = 0; i < colCount; i++) {\n    const col = document.createElement('col');\n    const width = colWidths && colWidths[i];\n    if (width) {\n      col.style.width = `${width}px`;\n    }\n    cols.push(col);\n  }\n  colGroup.replaceChildren(...cols);\n}\nfunction setRowStriping(dom, config, rowStriping) {\n  if (rowStriping) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, config.theme.tableRowStriping);\n    dom.setAttribute('data-lexical-row-striping', 'true');\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, config.theme.tableRowStriping);\n    dom.removeAttribute('data-lexical-row-striping');\n  }\n}\nfunction setFrozenColumns(dom, tableElement, config, frozenColumnCount) {\n  if (frozenColumnCount > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, config.theme.tableFrozenColumn);\n    tableElement.setAttribute('data-lexical-frozen-column', 'true');\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, config.theme.tableFrozenColumn);\n    tableElement.removeAttribute('data-lexical-frozen-column');\n  }\n}\nfunction setFrozenRows(dom, tableElement, config, frozenRowCount) {\n  if (frozenRowCount > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, config.theme.tableFrozenRow);\n    tableElement.setAttribute('data-lexical-frozen-row', 'true');\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, config.theme.tableFrozenRow);\n    tableElement.removeAttribute('data-lexical-frozen-row');\n  }\n}\nfunction alignTableElement(dom, config, formatType) {\n  if (!config.theme.tableAlignment) {\n    return;\n  }\n  const removeClasses = [];\n  const addClasses = [];\n  for (const format of ['center', 'right']) {\n    const classes = config.theme.tableAlignment[format];\n    if (!classes) {\n      continue;\n    }\n    (format === formatType ? addClasses : removeClasses).push(classes);\n  }\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...removeClasses);\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...addClasses);\n}\nconst scrollableEditors = new WeakSet();\nfunction $isScrollableTablesActive(editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)()) {\n  return scrollableEditors.has(editor);\n}\nfunction setScrollableTablesActive(editor, active) {\n  if (active) {\n    if (!editor._config.theme.tableScrollableWrapper) {\n      console.warn('TableNode: hasHorizontalScroll is active but theme.tableScrollableWrapper is not defined.');\n    }\n    scrollableEditors.add(editor);\n  } else {\n    scrollableEditors.delete(editor);\n  }\n}\n\n/** @noInheritDoc */\nclass TableNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'table';\n  }\n  getColWidths() {\n    const self = this.getLatest();\n    return self.__colWidths;\n  }\n  setColWidths(colWidths) {\n    const self = this.getWritable();\n    // NOTE: Node properties should be immutable. Freeze to prevent accidental mutation.\n    self.__colWidths = colWidths !== undefined && true ? Object.freeze(colWidths) : colWidths;\n    return self;\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__colWidths = prevNode.__colWidths;\n    this.__rowStriping = prevNode.__rowStriping;\n    this.__frozenColumnCount = prevNode.__frozenColumnCount;\n    this.__frozenRowCount = prevNode.__frozenRowCount;\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setRowStriping(serializedNode.rowStriping || false).setFrozenColumns(serializedNode.frozenColumnCount || 0).setFrozenRows(serializedNode.frozenRowCount || 0).setColWidths(serializedNode.colWidths);\n  }\n  constructor(key) {\n    super(key);\n    this.__rowStriping = false;\n    this.__frozenColumnCount = 0;\n    this.__frozenRowCount = 0;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colWidths: this.getColWidths(),\n      frozenColumnCount: this.__frozenColumnCount ? this.__frozenColumnCount : undefined,\n      frozenRowCount: this.__frozenRowCount ? this.__frozenRowCount : undefined,\n      rowStriping: this.__rowStriping ? this.__rowStriping : undefined\n    };\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  getDOMSlot(element) {\n    const tableElement = !isHTMLTableElement(element) ? element.querySelector('table') : element;\n    if (!isHTMLTableElement(tableElement)) {\n      formatDevErrorMessage(`TableNode.getDOMSlot: createDOM() did not return a table`);\n    }\n    return super.getDOMSlot(element).withElement(tableElement).withAfter(tableElement.querySelector('colgroup'));\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    if (this.__style) {\n      tableElement.style.cssText = this.__style;\n    }\n    const colGroup = document.createElement('colgroup');\n    tableElement.appendChild(colGroup);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.setDOMUnmanaged)(colGroup);\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(tableElement, config.theme.table);\n    this.updateTableElement(null, tableElement, config);\n    if ($isScrollableTablesActive(editor)) {\n      const wrapperElement = document.createElement('div');\n      const classes = config.theme.tableScrollableWrapper;\n      if (classes) {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(wrapperElement, classes);\n      } else {\n        wrapperElement.style.cssText = 'overflow-x: auto;';\n      }\n      wrapperElement.appendChild(tableElement);\n      this.updateTableWrapper(null, wrapperElement, tableElement, config);\n      return wrapperElement;\n    }\n    return tableElement;\n  }\n  updateTableWrapper(prevNode, tableWrapper, tableElement, config) {\n    if (this.__frozenColumnCount !== (prevNode ? prevNode.__frozenColumnCount : 0)) {\n      setFrozenColumns(tableWrapper, tableElement, config, this.__frozenColumnCount);\n    }\n    if (this.__frozenRowCount !== (prevNode ? prevNode.__frozenRowCount : 0)) {\n      setFrozenRows(tableWrapper, tableElement, config, this.__frozenRowCount);\n    }\n  }\n  updateTableElement(prevNode, tableElement, config) {\n    if (this.__style !== (prevNode ? prevNode.__style : '')) {\n      tableElement.style.cssText = this.__style;\n    }\n    if (this.__rowStriping !== (prevNode ? prevNode.__rowStriping : false)) {\n      setRowStriping(tableElement, config, this.__rowStriping);\n    }\n    updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());\n    alignTableElement(tableElement, config, this.getFormatType());\n  }\n  updateDOM(prevNode, dom, config) {\n    const slot = this.getDOMSlot(dom);\n    const tableElement = slot.element;\n    if (dom === tableElement === $isScrollableTablesActive()) {\n      return true;\n    }\n    if (isHTMLDivElement(dom)) {\n      this.updateTableWrapper(prevNode, dom, tableElement, config);\n    }\n    this.updateTableElement(prevNode, tableElement, config);\n    return false;\n  }\n  exportDOM(editor) {\n    const superExport = super.exportDOM(editor);\n    const {\n      element\n    } = superExport;\n    return {\n      after: tableElement => {\n        if (superExport.after) {\n          tableElement = superExport.after(tableElement);\n        }\n        if (!isHTMLTableElement(tableElement) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(tableElement)) {\n          tableElement = tableElement.querySelector('table');\n        }\n        if (!isHTMLTableElement(tableElement)) {\n          return null;\n        }\n        alignTableElement(tableElement, editor._config, this.getFormatType());\n\n        // Scan the table map to build a map of table cell key to the columns it needs\n        const [tableMap] = $computeTableMapSkipCellCheck(this, null, null);\n        const cellValues = new Map();\n        for (const mapRow of tableMap) {\n          for (const mapValue of mapRow) {\n            const key = mapValue.cell.getKey();\n            if (!cellValues.has(key)) {\n              cellValues.set(key, {\n                colSpan: mapValue.cell.getColSpan(),\n                startColumn: mapValue.startColumn\n              });\n            }\n          }\n        }\n\n        // scan the DOM to find the table cell keys that were used and mark those columns\n        const knownColumns = new Set();\n        for (const cellDOM of tableElement.querySelectorAll(':scope > tr > [data-temporary-table-cell-lexical-key]')) {\n          const key = cellDOM.getAttribute('data-temporary-table-cell-lexical-key');\n          if (key) {\n            const cellSpan = cellValues.get(key);\n            cellDOM.removeAttribute('data-temporary-table-cell-lexical-key');\n            if (cellSpan) {\n              cellValues.delete(key);\n              for (let i = 0; i < cellSpan.colSpan; i++) {\n                knownColumns.add(i + cellSpan.startColumn);\n              }\n            }\n          }\n        }\n\n        // Compute the colgroup and columns in the export\n        const colGroup = tableElement.querySelector(':scope > colgroup');\n        if (colGroup) {\n          // Only include the <col /> for rows that are in the output\n          const cols = Array.from(tableElement.querySelectorAll(':scope > colgroup > col')).filter((dom, i) => knownColumns.has(i));\n          colGroup.replaceChildren(...cols);\n        }\n\n        // Wrap direct descendant rows in a tbody for export\n        const rows = tableElement.querySelectorAll(':scope > tr');\n        if (rows.length > 0) {\n          const tBody = document.createElement('tbody');\n          for (const row of rows) {\n            tBody.appendChild(row);\n          }\n          tableElement.append(tBody);\n        }\n        return tableElement;\n      },\n      element: !isHTMLTableElement(element) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) ? element.querySelector('table') : element\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      for (let x = 0; x < row.length; x++) {\n        const cell = row[x];\n        if (cell == null) {\n          continue;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = $getNearestTableCellInTableFromDOMNode(this, elem);\n        if (cellNode !== null && tableCellNode.is(cellNode)) {\n          return {\n            x,\n            y\n          };\n        }\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const index = x < row.length ? x : row.length - 1;\n    const cell = row[index];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  getRowStriping() {\n    return Boolean(this.getLatest().__rowStriping);\n  }\n  setRowStriping(newRowStriping) {\n    const self = this.getWritable();\n    self.__rowStriping = newRowStriping;\n    return self;\n  }\n  setFrozenColumns(columnCount) {\n    const self = this.getWritable();\n    self.__frozenColumnCount = columnCount;\n    return self;\n  }\n  getFrozenColumns() {\n    return this.getLatest().__frozenColumnCount;\n  }\n  setFrozenRows(rowCount) {\n    const self = this.getWritable();\n    self.__frozenRowCount = rowCount;\n    return self;\n  }\n  getFrozenRows() {\n    return this.getLatest().__frozenRowCount;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n  getColumnCount() {\n    const firstRow = this.getFirstChild();\n    if (!firstRow) {\n      return 0;\n    }\n    let columnCount = 0;\n    firstRow.getChildren().forEach(cell => {\n      if ($isTableCellNode(cell)) {\n        columnCount += cell.getColSpan();\n      }\n    });\n    return columnCount;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (!(tableElement !== null)) {\n    formatDevErrorMessage(`$getElementForTableNode: Table Element Not Found`);\n  }\n  return getTable(tableNode, tableElement);\n}\nfunction $convertTableElement(domNode) {\n  const tableNode = $createTableNode();\n  if (domNode.hasAttribute('data-lexical-row-striping')) {\n    tableNode.setRowStriping(true);\n  }\n  if (domNode.hasAttribute('data-lexical-frozen-column')) {\n    tableNode.setFrozenColumns(1);\n  }\n  if (domNode.hasAttribute('data-lexical-frozen-row')) {\n    tableNode.setFrozenRows(1);\n  }\n  const colGroup = domNode.querySelector(':scope > colgroup');\n  if (colGroup) {\n    let columns = [];\n    for (const col of colGroup.querySelectorAll(':scope > col')) {\n      let width = col.style.width || '';\n      if (!PIXEL_VALUE_REG_EXP.test(width)) {\n        // Also support deprecated width attribute for google docs\n        width = col.getAttribute('width') || '';\n        if (!/^\\d+$/.test(width)) {\n          columns = undefined;\n          break;\n        }\n      }\n      columns.push(parseFloat(width));\n    }\n    if (columns) {\n      tableNode.setColWidths(columns);\n    }\n  }\n  return {\n    after: children => (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$descendantsMatching)(children, $isTableRowNode),\n    node: tableNode\n  };\n}\nfunction $createTableNode() {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\nfunction $insertTableCommandListener({\n  rows,\n  columns,\n  includeHeaders\n}) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if (!selection || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    return false;\n  }\n\n  // Prevent nested tables by checking if we're already inside a table\n  if ($findTableNode(selection.anchor.getNode())) {\n    return false;\n  }\n  const tableNode = $createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$insertNodeToNearestRoot)(tableNode);\n  const firstDescendant = tableNode.getFirstDescendant();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstDescendant)) {\n    firstDescendant.select();\n  }\n  return true;\n}\nfunction $tableCellTransform(node) {\n  if (!$isTableRowNode(node.getParent())) {\n    // TableCellNode must be a child of TableRowNode.\n    node.remove();\n  } else if (node.isEmpty()) {\n    // TableCellNode should never be empty\n    node.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n  }\n}\nfunction $tableRowTransform(node) {\n  if (!$isTableNode(node.getParent())) {\n    // TableRowNode must be a child of TableNode.\n    // TODO: Future support of tbody/thead/tfoot may change this\n    node.remove();\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$unwrapAndFilterDescendants)(node, $isTableCellNode);\n  }\n}\nfunction $tableTransform(node) {\n  // TableRowNode is the only valid child for TableNode\n  // TODO: Future support of tbody/thead/tfoot/caption may change this\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$unwrapAndFilterDescendants)(node, $isTableRowNode);\n  const [gridMap] = $computeTableMapSkipCellCheck(node, null, null);\n  const maxRowLength = gridMap.reduce((curLength, row) => {\n    return Math.max(curLength, row.length);\n  }, 0);\n  const rowNodes = node.getChildren();\n  for (let i = 0; i < gridMap.length; ++i) {\n    const rowNode = rowNodes[i];\n    if (!rowNode) {\n      continue;\n    }\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`TablePlugin: Expecting all children of TableNode to be TableRowNode, found ${rowNode.constructor.name} (type ${rowNode.getType()})`);\n    }\n    const rowLength = gridMap[i].reduce((acc, cell) => cell ? 1 + acc : acc, 0);\n    if (rowLength === maxRowLength) {\n      continue;\n    }\n    for (let j = rowLength; j < maxRowLength; ++j) {\n      // TODO: inherit header state from another header or body\n      const newCell = $createTableCellNode();\n      newCell.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n      rowNode.append(newCell);\n    }\n  }\n}\nfunction $tableClickCommand(event) {\n  if (event.detail < 3 || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(event.target)) {\n    return false;\n  }\n  const startNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(event.target);\n  if (startNode === null) {\n    return false;\n  }\n  const blockNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n  if (blockNode === null) {\n    return false;\n  }\n  const rootNode = blockNode.getParent();\n  if (!$isTableCellNode(rootNode)) {\n    return false;\n  }\n  blockNode.select(0);\n  return true;\n}\n\n/**\n * Register a transform to ensure that all TableCellNode have a colSpan and rowSpan of 1.\n * This should only be registered when you do not want to support merged cells.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTableCellUnmergeTransform(editor) {\n  return editor.registerNodeTransform(TableCellNode, node => {\n    if (node.getColSpan() > 1 || node.getRowSpan() > 1) {\n      // When we have rowSpan we have to map the entire Table to understand where the new Cells\n      // fit best; let's analyze all Cells at once to save us from further transform iterations\n      const [,, gridNode] = $getNodeTriplet(node);\n      const [gridMap] = $computeTableMap(gridNode, node, node);\n      // TODO this function expects Tables to be normalized. Look into this once it exists\n      const rowsCount = gridMap.length;\n      const columnsCount = gridMap[0].length;\n      let row = gridNode.getFirstChild();\n      if (!$isTableRowNode(row)) {\n        formatDevErrorMessage(`Expected TableNode first child to be a RowNode`);\n      }\n      const unmerged = [];\n      for (let i = 0; i < rowsCount; i++) {\n        if (i !== 0) {\n          row = row.getNextSibling();\n          if (!$isTableRowNode(row)) {\n            formatDevErrorMessage(`Expected TableNode first child to be a RowNode`);\n          }\n        }\n        let lastRowCell = null;\n        for (let j = 0; j < columnsCount; j++) {\n          const cellMap = gridMap[i][j];\n          const cell = cellMap.cell;\n          if (cellMap.startRow === i && cellMap.startColumn === j) {\n            lastRowCell = cell;\n            unmerged.push(cell);\n          } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {\n            if (!$isTableCellNode(cell)) {\n              formatDevErrorMessage(`Expected TableNode cell to be a TableCellNode`);\n            }\n            const newCell = $createTableCellNode(cell.__headerState);\n            if (lastRowCell !== null) {\n              lastRowCell.insertAfter(newCell);\n            } else {\n              (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$insertFirst)(row, newCell);\n            }\n          }\n        }\n      }\n      for (const cell of unmerged) {\n        cell.setColSpan(1);\n        cell.setRowSpan(1);\n      }\n    }\n  });\n}\nfunction registerTableSelectionObserver(editor, hasTabHandler = true) {\n  const tableSelections = new Map();\n  const initializeTableNode = (tableNode, nodeKey, dom) => {\n    const tableElement = getTableElement(tableNode, dom);\n    const tableSelection = applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);\n    tableSelections.set(nodeKey, [tableSelection, tableElement]);\n  };\n  const unregisterMutationListener = editor.registerMutationListener(TableNode, nodeMutations => {\n    editor.getEditorState().read(() => {\n      for (const [nodeKey, mutation] of nodeMutations) {\n        const tableSelection = tableSelections.get(nodeKey);\n        if (mutation === 'created' || mutation === 'updated') {\n          const {\n            tableNode,\n            tableElement\n          } = $getTableAndElementByKey(nodeKey);\n          if (tableSelection === undefined) {\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          } else if (tableElement !== tableSelection[1]) {\n            // The update created a new DOM node, destroy the existing TableObserver\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          }\n        } else if (mutation === 'destroyed') {\n          if (tableSelection !== undefined) {\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n          }\n        }\n      }\n    }, {\n      editor\n    });\n  }, {\n    skipInitialization: false\n  });\n  return () => {\n    unregisterMutationListener();\n    // Hook might be called multiple times so cleaning up tables listeners as well,\n    // as it'll be reinitialized during recurring call\n    for (const [, [tableSelection]] of tableSelections) {\n      tableSelection.removeListeners();\n    }\n  };\n}\n\n/**\n * Register the INSERT_TABLE_COMMAND listener and the table integrity transforms. The\n * table selection observer should be registered separately after this with\n * {@link registerTableSelectionObserver}.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTablePlugin(editor) {\n  if (!editor.hasNodes([TableNode])) {\n    {\n      formatDevErrorMessage(`TablePlugin: TableNode is not registered on editor`);\n    }\n  }\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(INSERT_TABLE_COMMAND, $insertTableCommandListener, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, ({\n    nodes,\n    selection\n  }, dispatchEditor) => {\n    if (editor !== dispatchEditor || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const isInsideTableCell = $findTableNode(selection.anchor.getNode()) !== null;\n    return isInsideTableCell && nodes.some($isTableNode);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLICK_COMMAND, $tableClickCommand, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerNodeTransform(TableNode, $tableTransform), editor.registerNodeTransform(TableRowNode, $tableRowTransform), editor.registerNodeTransform(TableCellNode, $tableCellTransform));\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrdGFibGVAMC4zNS4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90YWJsZS9MZXhpY2FsVGFibGUuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJSO0FBQ29nQztBQUMxc0M7O0FBRXJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBVztBQUN2Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0EsdURBQXVELEdBQUc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEdBQUc7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sNkJBQTZCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxREFBWSx5REFBeUQscURBQVk7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5REFBZ0I7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsd0RBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1REFBYztBQUN2QjtBQUNBO0FBQ0Esc0JBQXNCLDBFQUFpQztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FB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QUFDUCwrQ0FBK0Msc0RBQWU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1FQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9FQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOERBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQixzREFBYSxNQUFNLDhEQUFxQjtBQUM1RCxxQkFBcUIsMERBQWlCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsd0VBQXdCO0FBQzFCO0FBQ0EsTUFBTSxvREFBVztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZ0JBQWdCLDZEQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJLDJFQUEyQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyRUFBMkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLDBCQUEwQixRQUFRLGtCQUFrQjtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0EscUJBQXFCLDZEQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtEQUFTO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBb0IsbUVBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtRUFBbUIsb0JBQW9CLHVEQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYyw0REFBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUNBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2REFBYSwyRUFBMkUsNERBQXVCLDBCQUEwQiw2RUFBd0M7QUFDMUw7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQ0FBc0MsMERBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsa0RBQWEsc0JBQXNCLDREQUF1QjtBQUNoSDs7QUFFdXZDIiwic291cmNlcyI6WyIvVXNlcnMvbGF1cmFnYXJjaWEva2lzc2xhYnMvcGF5bG9hZC9hc3Ryby1wYXlsb2FkL25vZGVfbW9kdWxlcy8ucG5wbS9AbGV4aWNhbCt0YWJsZUAwLjM1LjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3RhYmxlL0xleGljYWxUYWJsZS5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCwgJGRlc2NlbmRhbnRzTWF0Y2hpbmcsICRmaW5kTWF0Y2hpbmdQYXJlbnQsIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudCwgb2JqZWN0S2xhc3NFcXVhbHMsIGlzSFRNTEVsZW1lbnQgYXMgaXNIVE1MRWxlbWVudCQxLCAkaW5zZXJ0Rmlyc3QgYXMgJGluc2VydEZpcnN0JDEsIG1lcmdlUmVnaXN0ZXIsICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdCwgJHVud3JhcEFuZEZpbHRlckRlc2NlbmRhbnRzIH0gZnJvbSAnQGxleGljYWwvdXRpbHMnO1xuaW1wb3J0IHsgRWxlbWVudE5vZGUsIGlzSFRNTEVsZW1lbnQsICRpc0lubGluZUVsZW1lbnRPckRlY29yYXRvck5vZGUsICRpc1RleHROb2RlLCAkaXNMaW5lQnJlYWtOb2RlLCAkY3JlYXRlUGFyYWdyYXBoTm9kZSwgJGFwcGx5Tm9kZVJlcGxhY2VtZW50LCBjcmVhdGVDb21tYW5kLCAkY3JlYXRlVGV4dE5vZGUsICRnZXRTZWxlY3Rpb24sICRpc1JhbmdlU2VsZWN0aW9uLCAkaXNQYXJhZ3JhcGhOb2RlLCAkY3JlYXRlUG9pbnQsICRpc0VsZW1lbnROb2RlLCAkbm9ybWFsaXplU2VsZWN0aW9uX19FWFBFUklNRU5UQUwsIGlzQ3VycmVudGx5UmVhZE9ubHlNb2RlLCBURVhUX1RZUEVfVE9fRk9STUFULCAkZ2V0Tm9kZUJ5S2V5LCAkZ2V0RWRpdG9yLCAkc2V0U2VsZWN0aW9uLCBTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIGdldERPTVNlbGVjdGlvbiwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uLCAkaXNSb290Tm9kZSwgSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCBDT01NQU5EX1BSSU9SSVRZX0hJR0gsIEtFWV9FU0NBUEVfQ09NTUFORCwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCwgQ1VUX0NPTU1BTkQsIEZPUk1BVF9URVhUX0NPTU1BTkQsIEZPUk1BVF9FTEVNRU5UX0NPTU1BTkQsIENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgS0VZX1RBQl9DT01NQU5ELCBGT0NVU19DT01NQU5ELCBTRUxFQ1RJT05fSU5TRVJUX0NMSVBCT0FSRF9OT0RFU19DT01NQU5ELCAkZ2V0UHJldmlvdXNTZWxlY3Rpb24sICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlLCAkY3JlYXRlUmFuZ2VTZWxlY3Rpb25Gcm9tRG9tLCAkaXNSb290T3JTaGFkb3dSb290LCBLRVlfQVJST1dfRE9XTl9DT01NQU5ELCBLRVlfQVJST1dfVVBfQ09NTUFORCwgS0VZX0FSUk9XX0xFRlRfQ09NTUFORCwgS0VZX0FSUk9XX1JJR0hUX0NPTU1BTkQsIERFTEVURV9XT1JEX0NPTU1BTkQsIERFTEVURV9MSU5FX0NPTU1BTkQsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORCwgS0VZX0JBQ0tTUEFDRV9DT01NQU5ELCBLRVlfREVMRVRFX0NPTU1BTkQsIGlzRE9NTm9kZSwgJGNhcmV0RnJvbVBvaW50LCAkaXNFeHRlbmRhYmxlVGV4dFBvaW50Q2FyZXQsICRleHRlbmRDYXJldFRvUmFuZ2UsICRpc1NpYmxpbmdDYXJldCwgJGdldFNpYmxpbmdDYXJldCwgJHNldFBvaW50RnJvbUNhcmV0LCAkbm9ybWFsaXplQ2FyZXQsICRnZXRBZGphY2VudENoaWxkQ2FyZXQsICRpc0NoaWxkQ2FyZXQsICRnZXRDaGlsZENhcmV0LCBzZXRET01Vbm1hbmFnZWQsIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SLCBDTElDS19DT01NQU5EIH0gZnJvbSAnbGV4aWNhbCc7XG5pbXBvcnQgeyBjb3B5VG9DbGlwYm9hcmQsICRnZXRDbGlwYm9hcmREYXRhRnJvbVNlbGVjdGlvbiB9IGZyb20gJ0BsZXhpY2FsL2NsaXBib2FyZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgUElYRUxfVkFMVUVfUkVHX0VYUCA9IC9eKFxcZCsoPzpcXC5cXGQrKT8pcHgkLztcblxuLy8gLlBsYXlncm91bmRFZGl0b3JUaGVtZV9fdGFibGVDZWxsIHdpZHRoIHZhbHVlIGZyb21cbi8vIHBhY2thZ2VzL2xleGljYWwtcGxheWdyb3VuZC9zcmMvdGhlbWVzL1BsYXlncm91bmRFZGl0b3JUaGVtZS5jc3NcbmNvbnN0IENPTFVNTl9XSURUSCA9IDc1O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IFRhYmxlQ2VsbEhlYWRlclN0YXRlcyA9IHtcbiAgQk9USDogMyxcbiAgQ09MVU1OOiAyLFxuICBOT19TVEFUVVM6IDAsXG4gIFJPVzogMVxufTtcbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBUYWJsZUNlbGxOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3RhYmxlY2VsbCc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFRhYmxlQ2VsbE5vZGUobm9kZS5fX2hlYWRlclN0YXRlLCBub2RlLl9fY29sU3Bhbiwgbm9kZS5fX3dpZHRoLCBub2RlLl9fa2V5KTtcbiAgfVxuICBhZnRlckNsb25lRnJvbShub2RlKSB7XG4gICAgc3VwZXIuYWZ0ZXJDbG9uZUZyb20obm9kZSk7XG4gICAgdGhpcy5fX3Jvd1NwYW4gPSBub2RlLl9fcm93U3BhbjtcbiAgICB0aGlzLl9fYmFja2dyb3VuZENvbG9yID0gbm9kZS5fX2JhY2tncm91bmRDb2xvcjtcbiAgICB0aGlzLl9fdmVydGljYWxBbGlnbiA9IG5vZGUuX192ZXJ0aWNhbEFsaWduO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRkOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGFibGVDZWxsTm9kZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KSxcbiAgICAgIHRoOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGFibGVDZWxsTm9kZUVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoKS51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSk7XG4gIH1cbiAgdXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpLnNldEhlYWRlclN0eWxlcyhzZXJpYWxpemVkTm9kZS5oZWFkZXJTdGF0ZSkuc2V0Q29sU3BhbihzZXJpYWxpemVkTm9kZS5jb2xTcGFuIHx8IDEpLnNldFJvd1NwYW4oc2VyaWFsaXplZE5vZGUucm93U3BhbiB8fCAxKS5zZXRXaWR0aChzZXJpYWxpemVkTm9kZS53aWR0aCB8fCB1bmRlZmluZWQpLnNldEJhY2tncm91bmRDb2xvcihzZXJpYWxpemVkTm9kZS5iYWNrZ3JvdW5kQ29sb3IgfHwgbnVsbCkuc2V0VmVydGljYWxBbGlnbihzZXJpYWxpemVkTm9kZS52ZXJ0aWNhbEFsaWduIHx8IHVuZGVmaW5lZCk7XG4gIH1cbiAgY29uc3RydWN0b3IoaGVhZGVyU3RhdGUgPSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTLCBjb2xTcGFuID0gMSwgd2lkdGgsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX2NvbFNwYW4gPSBjb2xTcGFuO1xuICAgIHRoaXMuX19yb3dTcGFuID0gMTtcbiAgICB0aGlzLl9faGVhZGVyU3RhdGUgPSBoZWFkZXJTdGF0ZTtcbiAgICB0aGlzLl9fd2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLl9fYmFja2dyb3VuZENvbG9yID0gbnVsbDtcbiAgICB0aGlzLl9fdmVydGljYWxBbGlnbiA9IHVuZGVmaW5lZDtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5nZXRUYWcoKSk7XG4gICAgaWYgKHRoaXMuX193aWR0aCkge1xuICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IGAke3RoaXMuX193aWR0aH1weGA7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fY29sU3BhbiA+IDEpIHtcbiAgICAgIGVsZW1lbnQuY29sU3BhbiA9IHRoaXMuX19jb2xTcGFuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX3Jvd1NwYW4gPiAxKSB7XG4gICAgICBlbGVtZW50LnJvd1NwYW4gPSB0aGlzLl9fcm93U3BhbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX19iYWNrZ3JvdW5kQ29sb3IgIT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5fX2JhY2tncm91bmRDb2xvcjtcbiAgICB9XG4gICAgaWYgKGlzVmFsaWRWZXJ0aWNhbEFsaWduKHRoaXMuX192ZXJ0aWNhbEFsaWduKSkge1xuICAgICAgZWxlbWVudC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gdGhpcy5fX3ZlcnRpY2FsQWxpZ247XG4gICAgfVxuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLnRhYmxlQ2VsbCwgdGhpcy5oYXNIZWFkZXIoKSAmJiBjb25maWcudGhlbWUudGFibGVDZWxsSGVhZGVyKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gc3VwZXIuZXhwb3J0RE9NKGVkaXRvcik7XG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob3V0cHV0LmVsZW1lbnQpKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gb3V0cHV0LmVsZW1lbnQ7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS10ZW1wb3JhcnktdGFibGUtY2VsbC1sZXhpY2FsLWtleScsIHRoaXMuZ2V0S2V5KCkpO1xuICAgICAgZWxlbWVudC5zdHlsZS5ib3JkZXIgPSAnMXB4IHNvbGlkIGJsYWNrJztcbiAgICAgIGlmICh0aGlzLl9fY29sU3BhbiA+IDEpIHtcbiAgICAgICAgZWxlbWVudC5jb2xTcGFuID0gdGhpcy5fX2NvbFNwYW47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX3Jvd1NwYW4gPiAxKSB7XG4gICAgICAgIGVsZW1lbnQucm93U3BhbiA9IHRoaXMuX19yb3dTcGFuO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IGAke3RoaXMuZ2V0V2lkdGgoKSB8fCBDT0xVTU5fV0lEVEh9cHhgO1xuICAgICAgZWxlbWVudC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gdGhpcy5nZXRWZXJ0aWNhbEFsaWduKCkgfHwgJ3RvcCc7XG4gICAgICBlbGVtZW50LnN0eWxlLnRleHRBbGlnbiA9ICdzdGFydCc7XG4gICAgICBpZiAodGhpcy5fX2JhY2tncm91bmRDb2xvciA9PT0gbnVsbCAmJiB0aGlzLmhhc0hlYWRlcigpKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNmMmYzZjUnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIC4uLihpc1ZhbGlkVmVydGljYWxBbGlnbih0aGlzLl9fdmVydGljYWxBbGlnbikgJiYge1xuICAgICAgICB2ZXJ0aWNhbEFsaWduOiB0aGlzLl9fdmVydGljYWxBbGlnblxuICAgICAgfSksXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuZ2V0QmFja2dyb3VuZENvbG9yKCksXG4gICAgICBjb2xTcGFuOiB0aGlzLl9fY29sU3BhbixcbiAgICAgIGhlYWRlclN0YXRlOiB0aGlzLl9faGVhZGVyU3RhdGUsXG4gICAgICByb3dTcGFuOiB0aGlzLl9fcm93U3BhbixcbiAgICAgIHdpZHRoOiB0aGlzLmdldFdpZHRoKClcbiAgICB9O1xuICB9XG4gIGdldENvbFNwYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19jb2xTcGFuO1xuICB9XG4gIHNldENvbFNwYW4oY29sU3Bhbikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2NvbFNwYW4gPSBjb2xTcGFuO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGdldFJvd1NwYW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19yb3dTcGFuO1xuICB9XG4gIHNldFJvd1NwYW4ocm93U3Bhbikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3Jvd1NwYW4gPSByb3dTcGFuO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGdldFRhZygpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNIZWFkZXIoKSA/ICd0aCcgOiAndGQnO1xuICB9XG4gIHNldEhlYWRlclN0eWxlcyhoZWFkZXJTdGF0ZSwgbWFzayA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5CT1RIKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9faGVhZGVyU3RhdGUgPSBoZWFkZXJTdGF0ZSAmIG1hc2sgfCBzZWxmLl9faGVhZGVyU3RhdGUgJiB+bWFzaztcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBnZXRIZWFkZXJTdHlsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19oZWFkZXJTdGF0ZTtcbiAgfVxuICBzZXRXaWR0aCh3aWR0aCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3dpZHRoID0gd2lkdGg7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0V2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX193aWR0aDtcbiAgfVxuICBnZXRCYWNrZ3JvdW5kQ29sb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19iYWNrZ3JvdW5kQ29sb3I7XG4gIH1cbiAgc2V0QmFja2dyb3VuZENvbG9yKG5ld0JhY2tncm91bmRDb2xvcikge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2JhY2tncm91bmRDb2xvciA9IG5ld0JhY2tncm91bmRDb2xvcjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBnZXRWZXJ0aWNhbEFsaWduKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fdmVydGljYWxBbGlnbjtcbiAgfVxuICBzZXRWZXJ0aWNhbEFsaWduKG5ld1ZlcnRpY2FsQWxpZ24pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX192ZXJ0aWNhbEFsaWduID0gbmV3VmVydGljYWxBbGlnbiB8fCB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgdG9nZ2xlSGVhZGVyU3R5bGUoaGVhZGVyU3RhdGVUb1RvZ2dsZSkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgaWYgKChzZWxmLl9faGVhZGVyU3RhdGUgJiBoZWFkZXJTdGF0ZVRvVG9nZ2xlKSA9PT0gaGVhZGVyU3RhdGVUb1RvZ2dsZSkge1xuICAgICAgc2VsZi5fX2hlYWRlclN0YXRlIC09IGhlYWRlclN0YXRlVG9Ub2dnbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuX19oZWFkZXJTdGF0ZSArPSBoZWFkZXJTdGF0ZVRvVG9nZ2xlO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBoYXNIZWFkZXJTdGF0ZShoZWFkZXJTdGF0ZSkge1xuICAgIHJldHVybiAodGhpcy5nZXRIZWFkZXJTdHlsZXMoKSAmIGhlYWRlclN0YXRlKSA9PT0gaGVhZGVyU3RhdGU7XG4gIH1cbiAgaGFzSGVhZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faGVhZGVyU3RhdGUgIT09IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlKSB7XG4gICAgcmV0dXJuIHByZXZOb2RlLl9faGVhZGVyU3RhdGUgIT09IHRoaXMuX19oZWFkZXJTdGF0ZSB8fCBwcmV2Tm9kZS5fX3dpZHRoICE9PSB0aGlzLl9fd2lkdGggfHwgcHJldk5vZGUuX19jb2xTcGFuICE9PSB0aGlzLl9fY29sU3BhbiB8fCBwcmV2Tm9kZS5fX3Jvd1NwYW4gIT09IHRoaXMuX19yb3dTcGFuIHx8IHByZXZOb2RlLl9fYmFja2dyb3VuZENvbG9yICE9PSB0aGlzLl9fYmFja2dyb3VuZENvbG9yIHx8IHByZXZOb2RlLl9fdmVydGljYWxBbGlnbiAhPT0gdGhpcy5fX3ZlcnRpY2FsQWxpZ247XG4gIH1cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbGxhcHNlQXRTdGFydCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkVmVydGljYWxBbGlnbih2ZXJ0aWNhbEFsaWduKSB7XG4gIHJldHVybiB2ZXJ0aWNhbEFsaWduID09PSAnbWlkZGxlJyB8fCB2ZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJztcbn1cbmZ1bmN0aW9uICRjb252ZXJ0VGFibGVDZWxsTm9kZUVsZW1lbnQoZG9tTm9kZSkge1xuICBjb25zdCBkb21Ob2RlXyA9IGRvbU5vZGU7XG4gIGNvbnN0IG5vZGVOYW1lID0gZG9tTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBsZXQgd2lkdGggPSB1bmRlZmluZWQ7XG4gIGlmIChQSVhFTF9WQUxVRV9SRUdfRVhQLnRlc3QoZG9tTm9kZV8uc3R5bGUud2lkdGgpKSB7XG4gICAgd2lkdGggPSBwYXJzZUZsb2F0KGRvbU5vZGVfLnN0eWxlLndpZHRoKTtcbiAgfVxuICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUobm9kZU5hbWUgPT09ICd0aCcgPyBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XIDogVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUywgZG9tTm9kZV8uY29sU3Bhbiwgd2lkdGgpO1xuICB0YWJsZUNlbGxOb2RlLl9fcm93U3BhbiA9IGRvbU5vZGVfLnJvd1NwYW47XG4gIGNvbnN0IGJhY2tncm91bmRDb2xvciA9IGRvbU5vZGVfLnN0eWxlLmJhY2tncm91bmRDb2xvcjtcbiAgaWYgKGJhY2tncm91bmRDb2xvciAhPT0gJycpIHtcbiAgICB0YWJsZUNlbGxOb2RlLl9fYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yO1xuICB9XG4gIGNvbnN0IHZlcnRpY2FsQWxpZ24gPSBkb21Ob2RlXy5zdHlsZS52ZXJ0aWNhbEFsaWduO1xuICBpZiAoaXNWYWxpZFZlcnRpY2FsQWxpZ24odmVydGljYWxBbGlnbikpIHtcbiAgICB0YWJsZUNlbGxOb2RlLl9fdmVydGljYWxBbGlnbiA9IHZlcnRpY2FsQWxpZ247XG4gIH1cbiAgY29uc3Qgc3R5bGUgPSBkb21Ob2RlXy5zdHlsZTtcbiAgY29uc3QgdGV4dERlY29yYXRpb24gPSAoc3R5bGUgJiYgc3R5bGUudGV4dERlY29yYXRpb24gfHwgJycpLnNwbGl0KCcgJyk7XG4gIGNvbnN0IGhhc0JvbGRGb250V2VpZ2h0ID0gc3R5bGUuZm9udFdlaWdodCA9PT0gJzcwMCcgfHwgc3R5bGUuZm9udFdlaWdodCA9PT0gJ2JvbGQnO1xuICBjb25zdCBoYXNMaW5ldGhyb3VnaFRleHREZWNvcmF0aW9uID0gdGV4dERlY29yYXRpb24uaW5jbHVkZXMoJ2xpbmUtdGhyb3VnaCcpO1xuICBjb25zdCBoYXNJdGFsaWNGb250U3R5bGUgPSBzdHlsZS5mb250U3R5bGUgPT09ICdpdGFsaWMnO1xuICBjb25zdCBoYXNVbmRlcmxpbmVUZXh0RGVjb3JhdGlvbiA9IHRleHREZWNvcmF0aW9uLmluY2x1ZGVzKCd1bmRlcmxpbmUnKTtcbiAgcmV0dXJuIHtcbiAgICBhZnRlcjogY2hpbGRMZXhpY2FsTm9kZXMgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICBsZXQgcGFyYWdyYXBoTm9kZSA9IG51bGw7XG4gICAgICBjb25zdCByZW1vdmVTaW5nbGVMaW5lQnJlYWtOb2RlID0gKCkgPT4ge1xuICAgICAgICBpZiAocGFyYWdyYXBoTm9kZSkge1xuICAgICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBwYXJhZ3JhcGhOb2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICBpZiAoJGlzTGluZUJyZWFrTm9kZShmaXJzdENoaWxkKSAmJiBwYXJhZ3JhcGhOb2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAxKSB7XG4gICAgICAgICAgICBmaXJzdENoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRMZXhpY2FsTm9kZXMpIHtcbiAgICAgICAgaWYgKCRpc0lubGluZUVsZW1lbnRPckRlY29yYXRvck5vZGUoY2hpbGQpIHx8ICRpc1RleHROb2RlKGNoaWxkKSB8fCAkaXNMaW5lQnJlYWtOb2RlKGNoaWxkKSkge1xuICAgICAgICAgIGlmICgkaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgICAgIGlmIChoYXNCb2xkRm9udFdlaWdodCkge1xuICAgICAgICAgICAgICBjaGlsZC50b2dnbGVGb3JtYXQoJ2JvbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNMaW5ldGhyb3VnaFRleHREZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnRvZ2dsZUZvcm1hdCgnc3RyaWtldGhyb3VnaCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0l0YWxpY0ZvbnRTdHlsZSkge1xuICAgICAgICAgICAgICBjaGlsZC50b2dnbGVGb3JtYXQoJ2l0YWxpYycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1VuZGVybGluZVRleHREZWNvcmF0aW9uKSB7XG4gICAgICAgICAgICAgIGNoaWxkLnRvZ2dsZUZvcm1hdCgndW5kZXJsaW5lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJhZ3JhcGhOb2RlKSB7XG4gICAgICAgICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZChjaGlsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFncmFwaE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpLmFwcGVuZChjaGlsZCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXJhZ3JhcGhOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgIHJlbW92ZVNpbmdsZUxpbmVCcmVha05vZGUoKTtcbiAgICAgICAgICBwYXJhZ3JhcGhOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVtb3ZlU2luZ2xlTGluZUJyZWFrTm9kZSgpO1xuICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgbm9kZTogdGFibGVDZWxsTm9kZVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUgPSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTLCBjb2xTcGFuID0gMSwgd2lkdGgpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSwgY29sU3Bhbiwgd2lkdGgpKTtcbn1cbmZ1bmN0aW9uICRpc1RhYmxlQ2VsbE5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRhYmxlQ2VsbE5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgSU5TRVJUX1RBQkxFX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTlNFUlRfVEFCTEVfQ09NTUFORCcpO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzLlxuXG5mdW5jdGlvbiBmb3JtYXREZXZFcnJvck1lc3NhZ2UobWVzc2FnZSkge1xuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIFRhYmxlUm93Tm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIHN0YXRpYyBnZXRUeXBlKCkge1xuICAgIHJldHVybiAndGFibGVyb3cnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZVJvd05vZGUobm9kZS5fX2hlaWdodCwgbm9kZS5fX2tleSk7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHI6IG5vZGUgPT4gKHtcbiAgICAgICAgY29udmVyc2lvbjogJGNvbnZlcnRUYWJsZVJvd0VsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAwXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZVRhYmxlUm93Tm9kZSgpLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKTtcbiAgfVxuICB1cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiBzdXBlci51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkuc2V0SGVpZ2h0KHNlcmlhbGl6ZWROb2RlLmhlaWdodCk7XG4gIH1cbiAgY29uc3RydWN0b3IoaGVpZ2h0LCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX19oZWlnaHQgPSBoZWlnaHQ7XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmdldEhlaWdodCgpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICAuLi4oaGVpZ2h0ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiB7XG4gICAgICAgIGhlaWdodFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcbiAgICBpZiAodGhpcy5fX2hlaWdodCkge1xuICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSBgJHt0aGlzLl9faGVpZ2h0fXB4YDtcbiAgICB9XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjb25maWcudGhlbWUudGFibGVSb3cpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIGV4dHJhY3RXaXRoQ2hpbGQoY2hpbGQsIHNlbGVjdGlvbiwgZGVzdGluYXRpb24pIHtcbiAgICByZXR1cm4gZGVzdGluYXRpb24gPT09ICdodG1sJztcbiAgfVxuICBpc1NoYWRvd1Jvb3QoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgc2V0SGVpZ2h0KGhlaWdodCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2hlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBnZXRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19oZWlnaHQ7XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlKSB7XG4gICAgcmV0dXJuIHByZXZOb2RlLl9faGVpZ2h0ICE9PSB0aGlzLl9faGVpZ2h0O1xuICB9XG4gIGNhbkJlRW1wdHkoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNhbkluZGVudCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uICRjb252ZXJ0VGFibGVSb3dFbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgZG9tTm9kZV8gPSBkb21Ob2RlO1xuICBsZXQgaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICBpZiAoUElYRUxfVkFMVUVfUkVHX0VYUC50ZXN0KGRvbU5vZGVfLnN0eWxlLmhlaWdodCkpIHtcbiAgICBoZWlnaHQgPSBwYXJzZUZsb2F0KGRvbU5vZGVfLnN0eWxlLmhlaWdodCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhZnRlcjogY2hpbGRyZW4gPT4gJGRlc2NlbmRhbnRzTWF0Y2hpbmcoY2hpbGRyZW4sICRpc1RhYmxlQ2VsbE5vZGUpLFxuICAgIG5vZGU6ICRjcmVhdGVUYWJsZVJvd05vZGUoaGVpZ2h0KVxuICB9O1xufVxuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlUm93Tm9kZShoZWlnaHQpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgVGFibGVSb3dOb2RlKGhlaWdodCkpO1xufVxuZnVuY3Rpb24gJGlzVGFibGVSb3dOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUYWJsZVJvd05vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgQ0FOX1VTRV9ET00gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IGRvY3VtZW50TW9kZSA9IENBTl9VU0VfRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDogbnVsbDtcbmNvbnN0IElTX0ZJUkVGT1ggPSBDQU5fVVNFX0RPTSAmJiAvXig/IS4qU2VhbW9ua2V5KSg/PS4qRmlyZWZveCkuKi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5DQU5fVVNFX0RPTSAmJiAnSW5wdXRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgPyAnZ2V0VGFyZ2V0UmFuZ2VzJyBpbiBuZXcgd2luZG93LklucHV0RXZlbnQoJ2lucHV0JykgOiBmYWxzZTtcblxuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlTm9kZVdpdGhEaW1lbnNpb25zKHJvd0NvdW50LCBjb2x1bW5Db3VudCwgaW5jbHVkZUhlYWRlcnMgPSB0cnVlKSB7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRjcmVhdGVUYWJsZU5vZGUoKTtcbiAgZm9yIChsZXQgaVJvdyA9IDA7IGlSb3cgPCByb3dDb3VudDsgaVJvdysrKSB7XG4gICAgY29uc3QgdGFibGVSb3dOb2RlID0gJGNyZWF0ZVRhYmxlUm93Tm9kZSgpO1xuICAgIGZvciAobGV0IGlDb2x1bW4gPSAwOyBpQ29sdW1uIDwgY29sdW1uQ291bnQ7IGlDb2x1bW4rKykge1xuICAgICAgbGV0IGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUztcbiAgICAgIGlmICh0eXBlb2YgaW5jbHVkZUhlYWRlcnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChpUm93ID09PSAwICYmIGluY2x1ZGVIZWFkZXJzLnJvd3MpIHtcbiAgICAgICAgICBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpQ29sdW1uID09PSAwICYmIGluY2x1ZGVIZWFkZXJzLmNvbHVtbnMpIHtcbiAgICAgICAgICBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGluY2x1ZGVIZWFkZXJzKSB7XG4gICAgICAgIGlmIChpUm93ID09PSAwKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaUNvbHVtbiA9PT0gMCkge1xuICAgICAgICAgIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSAkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSk7XG4gICAgICBjb25zdCBwYXJhZ3JhcGhOb2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgIHBhcmFncmFwaE5vZGUuYXBwZW5kKCRjcmVhdGVUZXh0Tm9kZSgpKTtcbiAgICAgIHRhYmxlQ2VsbE5vZGUuYXBwZW5kKHBhcmFncmFwaE5vZGUpO1xuICAgICAgdGFibGVSb3dOb2RlLmFwcGVuZCh0YWJsZUNlbGxOb2RlKTtcbiAgICB9XG4gICAgdGFibGVOb2RlLmFwcGVuZCh0YWJsZVJvd05vZGUpO1xuICB9XG4gIHJldHVybiB0YWJsZU5vZGU7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVDZWxsTm9kZUZyb21MZXhpY2FsTm9kZShzdGFydGluZ05vZGUpIHtcbiAgY29uc3Qgbm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnRpbmdOb2RlLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpO1xuICBpZiAoJGlzVGFibGVDZWxsTm9kZShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlUm93Tm9kZUZyb21UYWJsZUNlbGxOb2RlT3JUaHJvdyhzdGFydGluZ05vZGUpIHtcbiAgY29uc3Qgbm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnRpbmdOb2RlLCBuID0+ICRpc1RhYmxlUm93Tm9kZShuKSk7XG4gIGlmICgkaXNUYWJsZVJvd05vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRhYmxlIGNlbGwgdG8gYmUgaW5zaWRlIG9mIHRhYmxlIHJvdy4nKTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KHN0YXJ0aW5nTm9kZSkge1xuICBjb25zdCBub2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzdGFydGluZ05vZGUsIG4gPT4gJGlzVGFibGVOb2RlKG4pKTtcbiAgaWYgKCRpc1RhYmxlTm9kZShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGFibGUgY2VsbCB0byBiZSBpbnNpZGUgb2YgdGFibGUuJyk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVSb3dJbmRleEZyb21UYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpIHtcbiAgY29uc3QgdGFibGVSb3dOb2RlID0gJGdldFRhYmxlUm93Tm9kZUZyb21UYWJsZUNlbGxOb2RlT3JUaHJvdyh0YWJsZUNlbGxOb2RlKTtcbiAgY29uc3QgdGFibGVOb2RlID0gJGdldFRhYmxlTm9kZUZyb21MZXhpY2FsTm9kZU9yVGhyb3codGFibGVSb3dOb2RlKTtcbiAgcmV0dXJuIHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpLmZpbmRJbmRleChuID0+IG4uaXModGFibGVSb3dOb2RlKSk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVDb2x1bW5JbmRleEZyb21UYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpIHtcbiAgY29uc3QgdGFibGVSb3dOb2RlID0gJGdldFRhYmxlUm93Tm9kZUZyb21UYWJsZUNlbGxOb2RlT3JUaHJvdyh0YWJsZUNlbGxOb2RlKTtcbiAgcmV0dXJuIHRhYmxlUm93Tm9kZS5nZXRDaGlsZHJlbigpLmZpbmRJbmRleChuID0+IG4uaXModGFibGVDZWxsTm9kZSkpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ2VsbFNpYmxpbmdzRnJvbVRhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSwgdGFibGUpIHtcbiAgY29uc3QgdGFibGVOb2RlID0gJGdldFRhYmxlTm9kZUZyb21MZXhpY2FsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHlcbiAgfSA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZSk7XG4gIHJldHVybiB7XG4gICAgYWJvdmU6IHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkcyh4LCB5IC0gMSwgdGFibGUpLFxuICAgIGJlbG93OiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCwgeSArIDEsIHRhYmxlKSxcbiAgICBsZWZ0OiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCAtIDEsIHksIHRhYmxlKSxcbiAgICByaWdodDogdGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzKHggKyAxLCB5LCB0YWJsZSlcbiAgfTtcbn1cbmZ1bmN0aW9uICRyZW1vdmVUYWJsZVJvd0F0SW5kZXgodGFibGVOb2RlLCBpbmRleFRvRGVsZXRlKSB7XG4gIGNvbnN0IHRhYmxlUm93cyA9IHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpO1xuICBpZiAoaW5kZXhUb0RlbGV0ZSA+PSB0YWJsZVJvd3MubGVuZ3RoIHx8IGluZGV4VG9EZWxldGUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0YWJsZSBjZWxsIHRvIGJlIGluc2lkZSBvZiB0YWJsZSByb3cuJyk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0Um93Tm9kZSA9IHRhYmxlUm93c1tpbmRleFRvRGVsZXRlXTtcbiAgdGFyZ2V0Um93Tm9kZS5yZW1vdmUoKTtcbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgbWVyZ2VkIGNlbGxzLiBVc2Uge0BsaW5rICRpbnNlcnRUYWJsZVJvd0F0U2VsZWN0aW9ufSBvciB7QGxpbmsgJGluc2VydFRhYmxlUm93QXROb2RlfSBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVSb3codGFibGVOb2RlLCB0YXJnZXRJbmRleCwgc2hvdWxkSW5zZXJ0QWZ0ZXIgPSB0cnVlLCByb3dDb3VudCwgdGFibGUpIHtcbiAgY29uc3QgdGFibGVSb3dzID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG4gIGlmICh0YXJnZXRJbmRleCA+PSB0YWJsZVJvd3MubGVuZ3RoIHx8IHRhcmdldEluZGV4IDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGFibGUgcm93IHRhcmdldCBpbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgfVxuICBjb25zdCB0YXJnZXRSb3dOb2RlID0gdGFibGVSb3dzW3RhcmdldEluZGV4XTtcbiAgaWYgKCRpc1RhYmxlUm93Tm9kZSh0YXJnZXRSb3dOb2RlKSkge1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgcm93Q291bnQ7IHIrKykge1xuICAgICAgY29uc3QgdGFibGVSb3dDZWxscyA9IHRhcmdldFJvd05vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgIGNvbnN0IHRhYmxlQ29sdW1uQ291bnQgPSB0YWJsZVJvd0NlbGxzLmxlbmd0aDtcbiAgICAgIGNvbnN0IG5ld1RhYmxlUm93Tm9kZSA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdGFibGVDb2x1bW5Db3VudDsgYysrKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlQ2VsbEZyb21UYXJnZXRSb3cgPSB0YWJsZVJvd0NlbGxzW2NdO1xuICAgICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsRnJvbVRhcmdldFJvdykpIHtcbiAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIHRhYmxlIGNlbGxgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYWJvdmUsXG4gICAgICAgICAgYmVsb3dcbiAgICAgICAgfSA9ICRnZXRUYWJsZUNlbGxTaWJsaW5nc0Zyb21UYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbEZyb21UYXJnZXRSb3csIHRhYmxlKTtcbiAgICAgICAgbGV0IGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUztcbiAgICAgICAgY29uc3Qgd2lkdGggPSBhYm92ZSAmJiBhYm92ZS5nZXRXaWR0aCgpIHx8IGJlbG93ICYmIGJlbG93LmdldFdpZHRoKCkgfHwgdW5kZWZpbmVkO1xuICAgICAgICBpZiAoYWJvdmUgJiYgYWJvdmUuaGFzSGVhZGVyU3RhdGUoVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTikgfHwgYmVsb3cgJiYgYmVsb3cuaGFzSGVhZGVyU3RhdGUoVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTikpIHtcbiAgICAgICAgICBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSAkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSwgMSwgd2lkdGgpO1xuICAgICAgICB0YWJsZUNlbGxOb2RlLmFwcGVuZCgkY3JlYXRlUGFyYWdyYXBoTm9kZSgpKTtcbiAgICAgICAgbmV3VGFibGVSb3dOb2RlLmFwcGVuZCh0YWJsZUNlbGxOb2RlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRJbnNlcnRBZnRlcikge1xuICAgICAgICB0YXJnZXRSb3dOb2RlLmluc2VydEFmdGVyKG5ld1RhYmxlUm93Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRSb3dOb2RlLmluc2VydEJlZm9yZShuZXdUYWJsZVJvd05vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvdyBiZWZvcmUgaW5zZXJ0aW9uIGluZGV4IGRvZXMgbm90IGV4aXN0LicpO1xuICB9XG4gIHJldHVybiB0YWJsZU5vZGU7XG59XG5jb25zdCBnZXRIZWFkZXJTdGF0ZSA9IChjdXJyZW50U3RhdGUsIHBvc3NpYmxlU3RhdGUpID0+IHtcbiAgaWYgKGN1cnJlbnRTdGF0ZSA9PT0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLkJPVEggfHwgY3VycmVudFN0YXRlID09PSBwb3NzaWJsZVN0YXRlKSB7XG4gICAgcmV0dXJuIHBvc3NpYmxlU3RhdGU7XG4gIH1cbiAgcmV0dXJuIFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG59O1xuXG4vKipcbiAqIEluc2VydHMgYSB0YWJsZSByb3cgYmVmb3JlIG9yIGFmdGVyIHRoZSBjdXJyZW50IGZvY3VzIGNlbGwgbm9kZSxcbiAqIHRha2luZyBpbnRvIGFjY291bnQgYW55IHNwYW5zLiBJZiBzdWNjZXNzZnVsLCByZXR1cm5zIHRoZVxuICogaW5zZXJ0ZWQgdGFibGUgcm93IG5vZGUuXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnRUYWJsZVJvd0F0U2VsZWN0aW9uKGluc2VydEFmdGVyID0gdHJ1ZSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIGEgUmFuZ2VTZWxlY3Rpb24gb3IgVGFibGVTZWxlY3Rpb25gKTtcbiAgfVxuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgZm9jdXMgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICBjb25zdCBbYW5jaG9yQ2VsbF0gPSAkZ2V0Tm9kZVRyaXBsZXQoYW5jaG9yKTtcbiAgY29uc3QgW2ZvY3VzQ2VsbCwsIGdyaWRdID0gJGdldE5vZGVUcmlwbGV0KGZvY3VzKTtcbiAgY29uc3QgWywgZm9jdXNDZWxsTWFwLCBhbmNob3JDZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgZm9jdXNDZWxsLCBhbmNob3JDZWxsKTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBhbmNob3JTdGFydFJvd1xuICB9ID0gYW5jaG9yQ2VsbE1hcDtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBmb2N1c1N0YXJ0Um93XG4gIH0gPSBmb2N1c0NlbGxNYXA7XG4gIGlmIChpbnNlcnRBZnRlcikge1xuICAgIHJldHVybiAkaW5zZXJ0VGFibGVSb3dBdE5vZGUoYW5jaG9yU3RhcnRSb3cgKyBhbmNob3JDZWxsLl9fcm93U3BhbiA+IGZvY3VzU3RhcnRSb3cgKyBmb2N1c0NlbGwuX19yb3dTcGFuID8gYW5jaG9yQ2VsbCA6IGZvY3VzQ2VsbCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICRpbnNlcnRUYWJsZVJvd0F0Tm9kZShmb2N1c1N0YXJ0Um93IDwgYW5jaG9yU3RhcnRSb3cgPyBmb2N1c0NlbGwgOiBhbmNob3JDZWxsLCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIHtAbGluayAkaW5zZXJ0VGFibGVSb3dBdFNlbGVjdGlvbn1cbiAqL1xuY29uc3QgJGluc2VydFRhYmxlUm93X19FWFBFUklNRU5UQUwgPSAkaW5zZXJ0VGFibGVSb3dBdFNlbGVjdGlvbjtcblxuLyoqXG4gKiBJbnNlcnRzIGEgdGFibGUgcm93IGJlZm9yZSBvciBhZnRlciB0aGUgZ2l2ZW4gY2VsbCBub2RlLFxuICogdGFraW5nIGludG8gYWNjb3VudCBhbnkgc3BhbnMuIElmIHN1Y2Nlc3NmdWwsIHJldHVybnMgdGhlXG4gKiBpbnNlcnRlZCB0YWJsZSByb3cgbm9kZS5cbiAqL1xuZnVuY3Rpb24gJGluc2VydFRhYmxlUm93QXROb2RlKGNlbGxOb2RlLCBpbnNlcnRBZnRlciA9IHRydWUpIHtcbiAgY29uc3QgWywsIGdyaWRdID0gJGdldE5vZGVUcmlwbGV0KGNlbGxOb2RlKTtcbiAgY29uc3QgW2dyaWRNYXAsIGNlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkLCBjZWxsTm9kZSwgY2VsbE5vZGUpO1xuICBjb25zdCBjb2x1bW5Db3VudCA9IGdyaWRNYXBbMF0ubGVuZ3RoO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3c6IGNlbGxTdGFydFJvd1xuICB9ID0gY2VsbE1hcDtcbiAgbGV0IGluc2VydGVkUm93ID0gbnVsbDtcbiAgaWYgKGluc2VydEFmdGVyKSB7XG4gICAgY29uc3QgaW5zZXJ0QWZ0ZXJFbmRSb3cgPSBjZWxsU3RhcnRSb3cgKyBjZWxsTm9kZS5fX3Jvd1NwYW4gLSAxO1xuICAgIGNvbnN0IGluc2VydEFmdGVyRW5kUm93TWFwID0gZ3JpZE1hcFtpbnNlcnRBZnRlckVuZFJvd107XG4gICAgY29uc3QgbmV3Um93ID0gJGNyZWF0ZVRhYmxlUm93Tm9kZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydFJvd1xuICAgICAgfSA9IGluc2VydEFmdGVyRW5kUm93TWFwW2ldO1xuICAgICAgaWYgKHN0YXJ0Um93ICsgY2VsbC5fX3Jvd1NwYW4gLSAxIDw9IGluc2VydEFmdGVyRW5kUm93KSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsID0gaW5zZXJ0QWZ0ZXJFbmRSb3dNYXBbaV0uY2VsbDtcbiAgICAgICAgY29uc3QgY3VycmVudENlbGxIZWFkZXJTdGF0ZSA9IGN1cnJlbnRDZWxsLl9faGVhZGVyU3RhdGU7XG4gICAgICAgIGNvbnN0IGhlYWRlclN0YXRlID0gZ2V0SGVhZGVyU3RhdGUoY3VycmVudENlbGxIZWFkZXJTdGF0ZSwgVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTik7XG4gICAgICAgIG5ld1Jvdy5hcHBlbmQoJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUpLmFwcGVuZCgkY3JlYXRlUGFyYWdyYXBoTm9kZSgpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjZWxsLnNldFJvd1NwYW4oY2VsbC5fX3Jvd1NwYW4gKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW5zZXJ0QWZ0ZXJFbmRSb3dOb2RlID0gZ3JpZC5nZXRDaGlsZEF0SW5kZXgoaW5zZXJ0QWZ0ZXJFbmRSb3cpO1xuICAgIGlmICghJGlzVGFibGVSb3dOb2RlKGluc2VydEFmdGVyRW5kUm93Tm9kZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgaW5zZXJ0QWZ0ZXJFbmRSb3cgaXMgbm90IGEgVGFibGVSb3dOb2RlYCk7XG4gICAgfVxuICAgIGluc2VydEFmdGVyRW5kUm93Tm9kZS5pbnNlcnRBZnRlcihuZXdSb3cpO1xuICAgIGluc2VydGVkUm93ID0gbmV3Um93O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGluc2VydEJlZm9yZVN0YXJ0Um93ID0gY2VsbFN0YXJ0Um93O1xuICAgIGNvbnN0IGluc2VydEJlZm9yZVN0YXJ0Um93TWFwID0gZ3JpZE1hcFtpbnNlcnRCZWZvcmVTdGFydFJvd107XG4gICAgY29uc3QgbmV3Um93ID0gJGNyZWF0ZVRhYmxlUm93Tm9kZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uQ291bnQ7IGkrKykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydFJvd1xuICAgICAgfSA9IGluc2VydEJlZm9yZVN0YXJ0Um93TWFwW2ldO1xuICAgICAgaWYgKHN0YXJ0Um93ID09PSBpbnNlcnRCZWZvcmVTdGFydFJvdykge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGluc2VydEJlZm9yZVN0YXJ0Um93TWFwW2ldLmNlbGw7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUgPSBjdXJyZW50Q2VsbC5fX2hlYWRlclN0YXRlO1xuICAgICAgICBjb25zdCBoZWFkZXJTdGF0ZSA9IGdldEhlYWRlclN0YXRlKGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUsIFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU4pO1xuICAgICAgICBuZXdSb3cuYXBwZW5kKCRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2VsbC5zZXRSb3dTcGFuKGNlbGwuX19yb3dTcGFuICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluc2VydEJlZm9yZVN0YXJ0Um93Tm9kZSA9IGdyaWQuZ2V0Q2hpbGRBdEluZGV4KGluc2VydEJlZm9yZVN0YXJ0Um93KTtcbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShpbnNlcnRCZWZvcmVTdGFydFJvd05vZGUpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGluc2VydEJlZm9yZVN0YXJ0Um93IGlzIG5vdCBhIFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBpbnNlcnRCZWZvcmVTdGFydFJvd05vZGUuaW5zZXJ0QmVmb3JlKG5ld1Jvdyk7XG4gICAgaW5zZXJ0ZWRSb3cgPSBuZXdSb3c7XG4gIH1cbiAgcmV0dXJuIGluc2VydGVkUm93O1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFRoaXMgZnVuY3Rpb24gZG9lcyBub3Qgc3VwcG9ydCBtZXJnZWQgY2VsbHMuIFVzZSB7QGxpbmsgJGluc2VydFRhYmxlQ29sdW1uQXRTZWxlY3Rpb259IG9yIHtAbGluayAkaW5zZXJ0VGFibGVDb2x1bW5BdE5vZGV9IGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnRUYWJsZUNvbHVtbih0YWJsZU5vZGUsIHRhcmdldEluZGV4LCBzaG91bGRJbnNlcnRBZnRlciA9IHRydWUsIGNvbHVtbkNvdW50LCB0YWJsZSkge1xuICBjb25zdCB0YWJsZVJvd3MgPSB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgY29uc3QgdGFibGVDZWxsc1RvQmVJbnNlcnRlZCA9IFtdO1xuICBmb3IgKGxldCByID0gMDsgciA8IHRhYmxlUm93cy5sZW5ndGg7IHIrKykge1xuICAgIGNvbnN0IGN1cnJlbnRUYWJsZVJvd05vZGUgPSB0YWJsZVJvd3Nbcl07XG4gICAgaWYgKCRpc1RhYmxlUm93Tm9kZShjdXJyZW50VGFibGVSb3dOb2RlKSkge1xuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBjb2x1bW5Db3VudDsgYysrKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlUm93Q2hpbGRyZW4gPSBjdXJyZW50VGFibGVSb3dOb2RlLmdldENoaWxkcmVuKCk7XG4gICAgICAgIGlmICh0YXJnZXRJbmRleCA+PSB0YWJsZVJvd0NoaWxkcmVuLmxlbmd0aCB8fCB0YXJnZXRJbmRleCA8IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIGNvbHVtbiB0YXJnZXQgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0Q2VsbCA9IHRhYmxlUm93Q2hpbGRyZW5bdGFyZ2V0SW5kZXhdO1xuICAgICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFyZ2V0Q2VsbCkpIHtcbiAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIHRhYmxlIGNlbGxgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICByaWdodFxuICAgICAgICB9ID0gJGdldFRhYmxlQ2VsbFNpYmxpbmdzRnJvbVRhYmxlQ2VsbE5vZGUodGFyZ2V0Q2VsbCwgdGFibGUpO1xuICAgICAgICBsZXQgaGVhZGVyU3RhdGUgPSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTO1xuICAgICAgICBpZiAobGVmdCAmJiBsZWZ0Lmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1cpIHx8IHJpZ2h0ICYmIHJpZ2h0Lmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1cpKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdUYWJsZUNlbGwgPSAkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSk7XG4gICAgICAgIG5ld1RhYmxlQ2VsbC5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgICAgIHRhYmxlQ2VsbHNUb0JlSW5zZXJ0ZWQucHVzaCh7XG4gICAgICAgICAgbmV3VGFibGVDZWxsLFxuICAgICAgICAgIHRhcmdldENlbGxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHRhYmxlQ2VsbHNUb0JlSW5zZXJ0ZWQuZm9yRWFjaCgoe1xuICAgIG5ld1RhYmxlQ2VsbCxcbiAgICB0YXJnZXRDZWxsXG4gIH0pID0+IHtcbiAgICBpZiAoc2hvdWxkSW5zZXJ0QWZ0ZXIpIHtcbiAgICAgIHRhcmdldENlbGwuaW5zZXJ0QWZ0ZXIobmV3VGFibGVDZWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0Q2VsbC5pbnNlcnRCZWZvcmUobmV3VGFibGVDZWxsKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGFibGVOb2RlO1xufVxuXG4vKipcbiAqIEluc2VydHMgYSBjb2x1bW4gYmVmb3JlIG9yIGFmdGVyIHRoZSBjdXJyZW50IGZvY3VzIGNlbGwgbm9kZSxcbiAqIHRha2luZyBpbnRvIGFjY291bnQgYW55IHNwYW5zLiBJZiBzdWNjZXNzZnVsLCByZXR1cm5zIHRoZVxuICogZmlyc3QgaW5zZXJ0ZWQgY2VsbCBub2RlLlxuICovXG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVDb2x1bW5BdFNlbGVjdGlvbihpbnNlcnRBZnRlciA9IHRydWUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIFRhYmxlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgW2FuY2hvckNlbGxdID0gJGdldE5vZGVUcmlwbGV0KGFuY2hvcik7XG4gIGNvbnN0IFtmb2N1c0NlbGwsLCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChmb2N1cyk7XG4gIGNvbnN0IFssIGZvY3VzQ2VsbE1hcCwgYW5jaG9yQ2VsbE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKGdyaWQsIGZvY3VzQ2VsbCwgYW5jaG9yQ2VsbCk7XG4gIGNvbnN0IHtcbiAgICBzdGFydENvbHVtbjogYW5jaG9yU3RhcnRDb2x1bW5cbiAgfSA9IGFuY2hvckNlbGxNYXA7XG4gIGNvbnN0IHtcbiAgICBzdGFydENvbHVtbjogZm9jdXNTdGFydENvbHVtblxuICB9ID0gZm9jdXNDZWxsTWFwO1xuICBpZiAoaW5zZXJ0QWZ0ZXIpIHtcbiAgICByZXR1cm4gJGluc2VydFRhYmxlQ29sdW1uQXROb2RlKGFuY2hvclN0YXJ0Q29sdW1uICsgYW5jaG9yQ2VsbC5fX2NvbFNwYW4gPiBmb2N1c1N0YXJ0Q29sdW1uICsgZm9jdXNDZWxsLl9fY29sU3BhbiA/IGFuY2hvckNlbGwgOiBmb2N1c0NlbGwsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAkaW5zZXJ0VGFibGVDb2x1bW5BdE5vZGUoZm9jdXNTdGFydENvbHVtbiA8IGFuY2hvclN0YXJ0Q29sdW1uID8gZm9jdXNDZWxsIDogYW5jaG9yQ2VsbCwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byB7QGxpbmsgJGluc2VydFRhYmxlQ29sdW1uQXRTZWxlY3Rpb259XG4gKi9cbmNvbnN0ICRpbnNlcnRUYWJsZUNvbHVtbl9fRVhQRVJJTUVOVEFMID0gJGluc2VydFRhYmxlQ29sdW1uQXRTZWxlY3Rpb247XG5cbi8qKlxuICogSW5zZXJ0cyBhIGNvbHVtbiBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGdpdmVuIGNlbGwgbm9kZSxcbiAqIHRha2luZyBpbnRvIGFjY291bnQgYW55IHNwYW5zLiBJZiBzdWNjZXNzZnVsLCByZXR1cm5zIHRoZVxuICogZmlyc3QgaW5zZXJ0ZWQgY2VsbCBub2RlLlxuICovXG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVDb2x1bW5BdE5vZGUoY2VsbE5vZGUsIGluc2VydEFmdGVyID0gdHJ1ZSwgc2hvdWxkU2V0U2VsZWN0aW9uID0gdHJ1ZSkge1xuICBjb25zdCBbLCwgZ3JpZF0gPSAkZ2V0Tm9kZVRyaXBsZXQoY2VsbE5vZGUpO1xuICBjb25zdCBbZ3JpZE1hcCwgY2VsbE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKGdyaWQsIGNlbGxOb2RlLCBjZWxsTm9kZSk7XG4gIGNvbnN0IHJvd0NvdW50ID0gZ3JpZE1hcC5sZW5ndGg7XG4gIGNvbnN0IHtcbiAgICBzdGFydENvbHVtblxuICB9ID0gY2VsbE1hcDtcbiAgY29uc3QgaW5zZXJ0QWZ0ZXJDb2x1bW4gPSBpbnNlcnRBZnRlciA/IHN0YXJ0Q29sdW1uICsgY2VsbE5vZGUuX19jb2xTcGFuIC0gMSA6IHN0YXJ0Q29sdW1uIC0gMTtcbiAgY29uc3QgZ3JpZEZpcnN0Q2hpbGQgPSBncmlkLmdldEZpcnN0Q2hpbGQoKTtcbiAgaWYgKCEkaXNUYWJsZVJvd05vZGUoZ3JpZEZpcnN0Q2hpbGQpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBmaXJzdFRhYmxlIGNoaWxkIHRvIGJlIGEgcm93YCk7XG4gIH1cbiAgbGV0IGZpcnN0SW5zZXJ0ZWRDZWxsID0gbnVsbDtcbiAgZnVuY3Rpb24gJGNyZWF0ZVRhYmxlQ2VsbE5vZGVGb3JJbnNlcnRUYWJsZUNvbHVtbihoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVMpIHtcbiAgICBjb25zdCBjZWxsID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUpLmFwcGVuZCgkY3JlYXRlUGFyYWdyYXBoTm9kZSgpKTtcbiAgICBpZiAoZmlyc3RJbnNlcnRlZENlbGwgPT09IG51bGwpIHtcbiAgICAgIGZpcnN0SW5zZXJ0ZWRDZWxsID0gY2VsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGw7XG4gIH1cbiAgbGV0IGxvb3BSb3cgPSBncmlkRmlyc3RDaGlsZDtcbiAgcm93TG9vcDogZm9yIChsZXQgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgaWYgKGkgIT09IDApIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRSb3cgPSBsb29wUm93LmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShjdXJyZW50Um93KSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIHJvdyBuZXh0U2libGluZyB0byBiZSBhIHJvd2ApO1xuICAgICAgfVxuICAgICAgbG9vcFJvdyA9IGN1cnJlbnRSb3c7XG4gICAgfVxuICAgIGNvbnN0IHJvd01hcCA9IGdyaWRNYXBbaV07XG4gICAgY29uc3QgY3VycmVudENlbGxIZWFkZXJTdGF0ZSA9IHJvd01hcFtpbnNlcnRBZnRlckNvbHVtbiA8IDAgPyAwIDogaW5zZXJ0QWZ0ZXJDb2x1bW5dLmNlbGwuX19oZWFkZXJTdGF0ZTtcbiAgICBjb25zdCBoZWFkZXJTdGF0ZSA9IGdldEhlYWRlclN0YXRlKGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUsIFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1cpO1xuICAgIGlmIChpbnNlcnRBZnRlckNvbHVtbiA8IDApIHtcbiAgICAgICRpbnNlcnRGaXJzdChsb29wUm93LCAkY3JlYXRlVGFibGVDZWxsTm9kZUZvckluc2VydFRhYmxlQ29sdW1uKGhlYWRlclN0YXRlKSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY2VsbDogY3VycmVudENlbGwsXG4gICAgICBzdGFydENvbHVtbjogY3VycmVudFN0YXJ0Q29sdW1uLFxuICAgICAgc3RhcnRSb3c6IGN1cnJlbnRTdGFydFJvd1xuICAgIH0gPSByb3dNYXBbaW5zZXJ0QWZ0ZXJDb2x1bW5dO1xuICAgIGlmIChjdXJyZW50U3RhcnRDb2x1bW4gKyBjdXJyZW50Q2VsbC5fX2NvbFNwYW4gLSAxIDw9IGluc2VydEFmdGVyQ29sdW1uKSB7XG4gICAgICBsZXQgaW5zZXJ0QWZ0ZXJDZWxsID0gY3VycmVudENlbGw7XG4gICAgICBsZXQgaW5zZXJ0QWZ0ZXJDZWxsUm93U3RhcnQgPSBjdXJyZW50U3RhcnRSb3c7XG4gICAgICBsZXQgcHJldkNlbGxJbmRleCA9IGluc2VydEFmdGVyQ29sdW1uO1xuICAgICAgd2hpbGUgKGluc2VydEFmdGVyQ2VsbFJvd1N0YXJ0ICE9PSBpICYmIGluc2VydEFmdGVyQ2VsbC5fX3Jvd1NwYW4gPiAxKSB7XG4gICAgICAgIHByZXZDZWxsSW5kZXggLT0gY3VycmVudENlbGwuX19jb2xTcGFuO1xuICAgICAgICBpZiAocHJldkNlbGxJbmRleCA+PSAwKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY2VsbDogY2VsbF8sXG4gICAgICAgICAgICBzdGFydFJvdzogc3RhcnRSb3dfXG4gICAgICAgICAgfSA9IHJvd01hcFtwcmV2Q2VsbEluZGV4XTtcbiAgICAgICAgICBpbnNlcnRBZnRlckNlbGwgPSBjZWxsXztcbiAgICAgICAgICBpbnNlcnRBZnRlckNlbGxSb3dTdGFydCA9IHN0YXJ0Um93XztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb29wUm93LmFwcGVuZCgkY3JlYXRlVGFibGVDZWxsTm9kZUZvckluc2VydFRhYmxlQ29sdW1uKGhlYWRlclN0YXRlKSk7XG4gICAgICAgICAgY29udGludWUgcm93TG9vcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW5zZXJ0QWZ0ZXJDZWxsLmluc2VydEFmdGVyKCRjcmVhdGVUYWJsZUNlbGxOb2RlRm9ySW5zZXJ0VGFibGVDb2x1bW4oaGVhZGVyU3RhdGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudENlbGwuc2V0Q29sU3BhbihjdXJyZW50Q2VsbC5fX2NvbFNwYW4gKyAxKTtcbiAgICB9XG4gIH1cbiAgaWYgKGZpcnN0SW5zZXJ0ZWRDZWxsICE9PSBudWxsICYmIHNob3VsZFNldFNlbGVjdGlvbikge1xuICAgICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGZpcnN0SW5zZXJ0ZWRDZWxsKTtcbiAgfVxuICBjb25zdCBjb2xXaWR0aHMgPSBncmlkLmdldENvbFdpZHRocygpO1xuICBpZiAoY29sV2lkdGhzKSB7XG4gICAgY29uc3QgbmV3Q29sV2lkdGhzID0gWy4uLmNvbFdpZHRoc107XG4gICAgY29uc3QgY29sdW1uSW5kZXggPSBpbnNlcnRBZnRlckNvbHVtbiA8IDAgPyAwIDogaW5zZXJ0QWZ0ZXJDb2x1bW47XG4gICAgY29uc3QgbmV3V2lkdGggPSBuZXdDb2xXaWR0aHNbY29sdW1uSW5kZXhdO1xuICAgIG5ld0NvbFdpZHRocy5zcGxpY2UoY29sdW1uSW5kZXgsIDAsIG5ld1dpZHRoKTtcbiAgICBncmlkLnNldENvbFdpZHRocyhuZXdDb2xXaWR0aHMpO1xuICB9XG4gIHJldHVybiBmaXJzdEluc2VydGVkQ2VsbDtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgbWVyZ2VkIGNlbGxzLiBVc2Uge0BsaW5rICRkZWxldGVUYWJsZUNvbHVtbkF0U2VsZWN0aW9ufSBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiAkZGVsZXRlVGFibGVDb2x1bW4odGFibGVOb2RlLCB0YXJnZXRJbmRleCkge1xuICBjb25zdCB0YWJsZVJvd3MgPSB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWJsZVJvd3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJyZW50VGFibGVSb3dOb2RlID0gdGFibGVSb3dzW2ldO1xuICAgIGlmICgkaXNUYWJsZVJvd05vZGUoY3VycmVudFRhYmxlUm93Tm9kZSkpIHtcbiAgICAgIGNvbnN0IHRhYmxlUm93Q2hpbGRyZW4gPSBjdXJyZW50VGFibGVSb3dOb2RlLmdldENoaWxkcmVuKCk7XG4gICAgICBpZiAodGFyZ2V0SW5kZXggPj0gdGFibGVSb3dDaGlsZHJlbi5sZW5ndGggfHwgdGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGFibGUgY29sdW1uIHRhcmdldCBpbmRleCBvdXQgb2YgcmFuZ2UnKTtcbiAgICAgIH1cbiAgICAgIHRhYmxlUm93Q2hpbGRyZW5bdGFyZ2V0SW5kZXhdLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuZnVuY3Rpb24gJGRlbGV0ZVRhYmxlUm93QXRTZWxlY3Rpb24oKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBUYWJsZVNlbGVjdGlvbmApO1xuICB9XG4gIGNvbnN0IFthbmNob3IsIGZvY3VzXSA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCkgPyBbc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKSwgc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCldIDogW3NlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpXTtcbiAgY29uc3QgW2FuY2hvckNlbGwsLCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChhbmNob3IpO1xuICBjb25zdCBbZm9jdXNDZWxsXSA9ICRnZXROb2RlVHJpcGxldChmb2N1cyk7XG4gIGNvbnN0IFtncmlkTWFwLCBhbmNob3JDZWxsTWFwLCBmb2N1c0NlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkLCBhbmNob3JDZWxsLCBmb2N1c0NlbGwpO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3c6IGFuY2hvclN0YXJ0Um93XG4gIH0gPSBhbmNob3JDZWxsTWFwO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3c6IGZvY3VzU3RhcnRSb3dcbiAgfSA9IGZvY3VzQ2VsbE1hcDtcbiAgY29uc3QgZm9jdXNFbmRSb3cgPSBmb2N1c1N0YXJ0Um93ICsgZm9jdXNDZWxsLl9fcm93U3BhbiAtIDE7XG4gIGlmIChncmlkTWFwLmxlbmd0aCA9PT0gZm9jdXNFbmRSb3cgLSBhbmNob3JTdGFydFJvdyArIDEpIHtcbiAgICAvLyBFbXB0eSBncmlkXG4gICAgZ3JpZC5yZW1vdmUoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29sdW1uQ291bnQgPSBncmlkTWFwWzBdLmxlbmd0aDtcbiAgY29uc3QgbmV4dFJvdyA9IGdyaWRNYXBbZm9jdXNFbmRSb3cgKyAxXTtcbiAgY29uc3QgbmV4dFJvd05vZGUgPSBncmlkLmdldENoaWxkQXRJbmRleChmb2N1c0VuZFJvdyArIDEpO1xuICBmb3IgKGxldCByb3cgPSBmb2N1c0VuZFJvdzsgcm93ID49IGFuY2hvclN0YXJ0Um93OyByb3ctLSkge1xuICAgIGZvciAobGV0IGNvbHVtbiA9IGNvbHVtbkNvdW50IC0gMTsgY29sdW1uID49IDA7IGNvbHVtbi0tKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Um93OiBjZWxsU3RhcnRSb3csXG4gICAgICAgIHN0YXJ0Q29sdW1uOiBjZWxsU3RhcnRDb2x1bW5cbiAgICAgIH0gPSBncmlkTWFwW3Jvd11bY29sdW1uXTtcbiAgICAgIGlmIChjZWxsU3RhcnRDb2x1bW4gIT09IGNvbHVtbikge1xuICAgICAgICAvLyBEb24ndCByZXBlYXQgd29yayBmb3IgdGhlIHNhbWUgQ2VsbFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFJvd3Mgb3ZlcmZsb3dpbmcgdG9wIG9yIGJvdHRvbSBoYXZlIHRvIGJlIHRyaW1tZWRcbiAgICAgIGlmIChjZWxsU3RhcnRSb3cgPCBhbmNob3JTdGFydFJvdyB8fCBjZWxsU3RhcnRSb3cgKyBjZWxsLl9fcm93U3BhbiAtIDEgPiBmb2N1c0VuZFJvdykge1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb25TdGFydCA9IE1hdGgubWF4KGNlbGxTdGFydFJvdywgYW5jaG9yU3RhcnRSb3cpO1xuICAgICAgICBjb25zdCBpbnRlcnNlY3Rpb25FbmQgPSBNYXRoLm1pbihjZWxsLl9fcm93U3BhbiArIGNlbGxTdGFydFJvdyAtIDEsIGZvY3VzRW5kUm93KTtcbiAgICAgICAgY29uc3Qgb3ZlcmZsb3dSb3dzQ291bnQgPSBpbnRlcnNlY3Rpb25TdGFydCA8PSBpbnRlcnNlY3Rpb25FbmQgPyBpbnRlcnNlY3Rpb25FbmQgLSBpbnRlcnNlY3Rpb25TdGFydCArIDEgOiAwO1xuICAgICAgICBjZWxsLnNldFJvd1NwYW4oY2VsbC5fX3Jvd1NwYW4gLSBvdmVyZmxvd1Jvd3NDb3VudCk7XG4gICAgICB9XG4gICAgICAvLyBSb3dzIG92ZXJmbG93aW5nIGJvdHRvbSBoYXZlIHRvIGJlIG1vdmVkIHRvIHRoZSBuZXh0IHJvd1xuICAgICAgaWYgKGNlbGxTdGFydFJvdyA+PSBhbmNob3JTdGFydFJvdyAmJiBjZWxsU3RhcnRSb3cgKyBjZWxsLl9fcm93U3BhbiAtIDEgPiBmb2N1c0VuZFJvdyAmJlxuICAgICAgLy8gSGFuZGxlIG92ZXJmbG93IG9ubHkgb25jZVxuICAgICAgcm93ID09PSBmb2N1c0VuZFJvdykge1xuICAgICAgICBpZiAoIShuZXh0Um93Tm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIG5leHRSb3dOb2RlIG5vdCB0byBiZSBudWxsYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluc2VydEFmdGVyQ2VsbCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGNvbHVtbkluZGV4ID0gMDsgY29sdW1uSW5kZXggPCBjb2x1bW47IGNvbHVtbkluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50Q2VsbE1hcCA9IG5leHRSb3dbY29sdW1uSW5kZXhdO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsID0gY3VycmVudENlbGxNYXAuY2VsbDtcbiAgICAgICAgICAvLyBDaGVja2luZyB0aGUgY2VsbCBoYXZpbmcgc3RhcnRSb3cgYXMgc2FtZSBhcyBuZXh0Um93XG4gICAgICAgICAgaWYgKGN1cnJlbnRDZWxsTWFwLnN0YXJ0Um93ID09PSByb3cgKyAxKSB7XG4gICAgICAgICAgICBpbnNlcnRBZnRlckNlbGwgPSBjdXJyZW50Q2VsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN1cnJlbnRDZWxsLl9fY29sU3BhbiA+IDEpIHtcbiAgICAgICAgICAgIGNvbHVtbkluZGV4ICs9IGN1cnJlbnRDZWxsLl9fY29sU3BhbiAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbnNlcnRBZnRlckNlbGwgPT09IG51bGwpIHtcbiAgICAgICAgICAkaW5zZXJ0Rmlyc3QobmV4dFJvd05vZGUsIGNlbGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc2VydEFmdGVyQ2VsbC5pbnNlcnRBZnRlcihjZWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByb3dOb2RlID0gZ3JpZC5nZXRDaGlsZEF0SW5kZXgocm93KTtcbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShyb3dOb2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZU5vZGUgY2hpbGRBdEluZGV4KCR7U3RyaW5nKHJvdyl9KSB0byBiZSBSb3dOb2RlYCk7XG4gICAgfVxuICAgIHJvd05vZGUucmVtb3ZlKCk7XG4gIH1cbiAgaWYgKG5leHRSb3cgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNlbGxcbiAgICB9ID0gbmV4dFJvd1swXTtcbiAgICAkbW92ZVNlbGVjdGlvblRvQ2VsbChjZWxsKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBwcmV2aW91c1JvdyA9IGdyaWRNYXBbYW5jaG9yU3RhcnRSb3cgLSAxXTtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IHByZXZpb3VzUm93WzBdO1xuICAgICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGNlbGwpO1xuICB9XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byB7QGxpbmsgJGRlbGV0ZVRhYmxlUm93QXRTZWxlY3Rpb259XG4gKi9cbmNvbnN0ICRkZWxldGVUYWJsZVJvd19fRVhQRVJJTUVOVEFMID0gJGRlbGV0ZVRhYmxlUm93QXRTZWxlY3Rpb247XG5mdW5jdGlvbiAkZGVsZXRlVGFibGVDb2x1bW5BdFNlbGVjdGlvbigpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIFRhYmxlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgW2FuY2hvckNlbGwsLCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChhbmNob3IpO1xuICBjb25zdCBbZm9jdXNDZWxsXSA9ICRnZXROb2RlVHJpcGxldChmb2N1cyk7XG4gIGNvbnN0IFtncmlkTWFwLCBhbmNob3JDZWxsTWFwLCBmb2N1c0NlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkLCBhbmNob3JDZWxsLCBmb2N1c0NlbGwpO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW46IGFuY2hvclN0YXJ0Q29sdW1uXG4gIH0gPSBhbmNob3JDZWxsTWFwO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3c6IGZvY3VzU3RhcnRSb3csXG4gICAgc3RhcnRDb2x1bW46IGZvY3VzU3RhcnRDb2x1bW5cbiAgfSA9IGZvY3VzQ2VsbE1hcDtcbiAgY29uc3Qgc3RhcnRDb2x1bW4gPSBNYXRoLm1pbihhbmNob3JTdGFydENvbHVtbiwgZm9jdXNTdGFydENvbHVtbik7XG4gIGNvbnN0IGVuZENvbHVtbiA9IE1hdGgubWF4KGFuY2hvclN0YXJ0Q29sdW1uICsgYW5jaG9yQ2VsbC5fX2NvbFNwYW4gLSAxLCBmb2N1c1N0YXJ0Q29sdW1uICsgZm9jdXNDZWxsLl9fY29sU3BhbiAtIDEpO1xuICBjb25zdCBzZWxlY3RlZENvbHVtbkNvdW50ID0gZW5kQ29sdW1uIC0gc3RhcnRDb2x1bW4gKyAxO1xuICBjb25zdCBjb2x1bW5Db3VudCA9IGdyaWRNYXBbMF0ubGVuZ3RoO1xuICBpZiAoY29sdW1uQ291bnQgPT09IGVuZENvbHVtbiAtIHN0YXJ0Q29sdW1uICsgMSkge1xuICAgIC8vIEVtcHR5IGdyaWRcbiAgICBncmlkLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgZ3JpZC5yZW1vdmUoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgcm93Q291bnQgPSBncmlkTWFwLmxlbmd0aDtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgcm93Q291bnQ7IHJvdysrKSB7XG4gICAgZm9yIChsZXQgY29sdW1uID0gc3RhcnRDb2x1bW47IGNvbHVtbiA8PSBlbmRDb2x1bW47IGNvbHVtbisrKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Q29sdW1uOiBjZWxsU3RhcnRDb2x1bW5cbiAgICAgIH0gPSBncmlkTWFwW3Jvd11bY29sdW1uXTtcbiAgICAgIGlmIChjZWxsU3RhcnRDb2x1bW4gPCBzdGFydENvbHVtbikge1xuICAgICAgICBpZiAoY29sdW1uID09PSBzdGFydENvbHVtbikge1xuICAgICAgICAgIGNvbnN0IG92ZXJmbG93TGVmdCA9IHN0YXJ0Q29sdW1uIC0gY2VsbFN0YXJ0Q29sdW1uO1xuICAgICAgICAgIC8vIE92ZXJmbG93aW5nIGxlZnRcbiAgICAgICAgICBjZWxsLnNldENvbFNwYW4oY2VsbC5fX2NvbFNwYW4gLVxuICAgICAgICAgIC8vIFBvc3NpYmxlIG92ZXJmbG93IHJpZ2h0IHRvb1xuICAgICAgICAgIE1hdGgubWluKHNlbGVjdGVkQ29sdW1uQ291bnQsIGNlbGwuX19jb2xTcGFuIC0gb3ZlcmZsb3dMZWZ0KSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2VsbFN0YXJ0Q29sdW1uICsgY2VsbC5fX2NvbFNwYW4gLSAxID4gZW5kQ29sdW1uKSB7XG4gICAgICAgIGlmIChjb2x1bW4gPT09IGVuZENvbHVtbikge1xuICAgICAgICAgIC8vIE92ZXJmbG93aW5nIHJpZ2h0XG4gICAgICAgICAgY29uc3QgaW5TZWxlY3RlZEFyZWEgPSBlbmRDb2x1bW4gLSBjZWxsU3RhcnRDb2x1bW4gKyAxO1xuICAgICAgICAgIGNlbGwuc2V0Q29sU3BhbihjZWxsLl9fY29sU3BhbiAtIGluU2VsZWN0ZWRBcmVhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2VsbC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgZm9jdXNSb3dNYXAgPSBncmlkTWFwW2ZvY3VzU3RhcnRSb3ddO1xuICBjb25zdCBuZXh0Q29sdW1uID0gYW5jaG9yU3RhcnRDb2x1bW4gPiBmb2N1c1N0YXJ0Q29sdW1uID8gZm9jdXNSb3dNYXBbYW5jaG9yU3RhcnRDb2x1bW4gKyBhbmNob3JDZWxsLl9fY29sU3Bhbl0gOiBmb2N1c1Jvd01hcFtmb2N1c1N0YXJ0Q29sdW1uICsgZm9jdXNDZWxsLl9fY29sU3Bhbl07XG4gIGlmIChuZXh0Q29sdW1uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IG5leHRDb2x1bW47XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoY2VsbCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJldmlvdXNSb3cgPSBmb2N1c1N0YXJ0Q29sdW1uIDwgYW5jaG9yU3RhcnRDb2x1bW4gPyBmb2N1c1Jvd01hcFtmb2N1c1N0YXJ0Q29sdW1uIC0gMV0gOiBmb2N1c1Jvd01hcFthbmNob3JTdGFydENvbHVtbiAtIDFdO1xuICAgIGNvbnN0IHtcbiAgICAgIGNlbGxcbiAgICB9ID0gcHJldmlvdXNSb3c7XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoY2VsbCk7XG4gIH1cbiAgY29uc3QgY29sV2lkdGhzID0gZ3JpZC5nZXRDb2xXaWR0aHMoKTtcbiAgaWYgKGNvbFdpZHRocykge1xuICAgIGNvbnN0IG5ld0NvbFdpZHRocyA9IFsuLi5jb2xXaWR0aHNdO1xuICAgIG5ld0NvbFdpZHRocy5zcGxpY2Uoc3RhcnRDb2x1bW4sIHNlbGVjdGVkQ29sdW1uQ291bnQpO1xuICAgIGdyaWQuc2V0Q29sV2lkdGhzKG5ld0NvbFdpZHRocyk7XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIHtAbGluayAkZGVsZXRlVGFibGVDb2x1bW5BdFNlbGVjdGlvbn1cbiAqL1xuY29uc3QgJGRlbGV0ZVRhYmxlQ29sdW1uX19FWFBFUklNRU5UQUwgPSAkZGVsZXRlVGFibGVDb2x1bW5BdFNlbGVjdGlvbjtcbmZ1bmN0aW9uICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGNlbGwpIHtcbiAgY29uc3QgZmlyc3REZXNjZW5kYW50ID0gY2VsbC5nZXRGaXJzdERlc2NlbmRhbnQoKTtcbiAgaWYgKGZpcnN0RGVzY2VuZGFudCA9PSBudWxsKSB7XG4gICAgY2VsbC5zZWxlY3RTdGFydCgpO1xuICB9IGVsc2Uge1xuICAgIGZpcnN0RGVzY2VuZGFudC5nZXRQYXJlbnRPclRocm93KCkuc2VsZWN0U3RhcnQoKTtcbiAgfVxufVxuZnVuY3Rpb24gJGluc2VydEZpcnN0KHBhcmVudCwgbm9kZSkge1xuICBjb25zdCBmaXJzdENoaWxkID0gcGFyZW50LmdldEZpcnN0Q2hpbGQoKTtcbiAgaWYgKGZpcnN0Q2hpbGQgIT09IG51bGwpIHtcbiAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZShub2RlKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJlbnQuYXBwZW5kKG5vZGUpO1xuICB9XG59XG5mdW5jdGlvbiAkbWVyZ2VDZWxscyhjZWxsTm9kZXMpIHtcbiAgaWYgKGNlbGxOb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHRhYmxlIG5vZGVcbiAgY29uc3QgdGFibGVOb2RlID0gJGdldFRhYmxlTm9kZUZyb21MZXhpY2FsTm9kZU9yVGhyb3coY2VsbE5vZGVzWzBdKTtcbiAgY29uc3QgW2dyaWRNYXBdID0gJGNvbXB1dGVUYWJsZU1hcFNraXBDZWxsQ2hlY2sodGFibGVOb2RlLCBudWxsLCBudWxsKTtcblxuICAvLyBGaW5kIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBzZWxlY3Rpb24gaW5jbHVkaW5nIG1lcmdlZCBjZWxsc1xuICBsZXQgbWluUm93ID0gSW5maW5pdHk7XG4gIGxldCBtYXhSb3cgPSAtSW5maW5pdHk7XG4gIGxldCBtaW5Db2wgPSBJbmZpbml0eTtcbiAgbGV0IG1heENvbCA9IC1JbmZpbml0eTtcblxuICAvLyBGaXJzdCBwYXNzOiBmaW5kIHRoZSBhY3R1YWwgYm91bmRhcmllcyBjb25zaWRlcmluZyBtZXJnZWQgY2VsbHNcbiAgY29uc3QgcHJvY2Vzc2VkQ2VsbHMgPSBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3Qgcm93IG9mIGdyaWRNYXApIHtcbiAgICBmb3IgKGNvbnN0IG1hcENlbGwgb2Ygcm93KSB7XG4gICAgICBpZiAoIW1hcENlbGwgfHwgIW1hcENlbGwuY2VsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNlbGxLZXkgPSBtYXBDZWxsLmNlbGwuZ2V0S2V5KCk7XG4gICAgICBpZiAocHJvY2Vzc2VkQ2VsbHMuaGFzKGNlbGxLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNlbGxOb2Rlcy5zb21lKGNlbGwgPT4gY2VsbC5pcyhtYXBDZWxsLmNlbGwpKSkge1xuICAgICAgICBwcm9jZXNzZWRDZWxscy5hZGQoY2VsbEtleSk7XG4gICAgICAgIC8vIEdldCB0aGUgYWN0dWFsIHBvc2l0aW9uIG9mIHRoaXMgY2VsbCBpbiB0aGUgZ3JpZFxuICAgICAgICBjb25zdCBjZWxsU3RhcnRSb3cgPSBtYXBDZWxsLnN0YXJ0Um93O1xuICAgICAgICBjb25zdCBjZWxsU3RhcnRDb2wgPSBtYXBDZWxsLnN0YXJ0Q29sdW1uO1xuICAgICAgICBjb25zdCBjZWxsUm93U3BhbiA9IG1hcENlbGwuY2VsbC5fX3Jvd1NwYW4gfHwgMTtcbiAgICAgICAgY29uc3QgY2VsbENvbFNwYW4gPSBtYXBDZWxsLmNlbGwuX19jb2xTcGFuIHx8IDE7XG5cbiAgICAgICAgLy8gVXBkYXRlIGJvdW5kYXJpZXMgY29uc2lkZXJpbmcgdGhlIGNlbGwncyBhY3R1YWwgcG9zaXRpb24gYW5kIHNwYW5cbiAgICAgICAgbWluUm93ID0gTWF0aC5taW4obWluUm93LCBjZWxsU3RhcnRSb3cpO1xuICAgICAgICBtYXhSb3cgPSBNYXRoLm1heChtYXhSb3csIGNlbGxTdGFydFJvdyArIGNlbGxSb3dTcGFuIC0gMSk7XG4gICAgICAgIG1pbkNvbCA9IE1hdGgubWluKG1pbkNvbCwgY2VsbFN0YXJ0Q29sKTtcbiAgICAgICAgbWF4Q29sID0gTWF0aC5tYXgobWF4Q29sLCBjZWxsU3RhcnRDb2wgKyBjZWxsQ29sU3BhbiAtIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGJvdW5kYXJpZXNcbiAgaWYgKG1pblJvdyA9PT0gSW5maW5pdHkgfHwgbWluQ29sID09PSBJbmZpbml0eSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gVGhlIHRvdGFsIHNwYW4gb2YgdGhlIG1lcmdlZCBjZWxsXG4gIGNvbnN0IHRvdGFsUm93U3BhbiA9IG1heFJvdyAtIG1pblJvdyArIDE7XG4gIGNvbnN0IHRvdGFsQ29sU3BhbiA9IG1heENvbCAtIG1pbkNvbCArIDE7XG5cbiAgLy8gVXNlIHRoZSB0b3AtbGVmdCBjZWxsIGFzIHRoZSB0YXJnZXQgY2VsbFxuICBjb25zdCB0YXJnZXRDZWxsTWFwID0gZ3JpZE1hcFttaW5Sb3ddW21pbkNvbF07XG4gIGlmICghdGFyZ2V0Q2VsbE1hcC5jZWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgdGFyZ2V0Q2VsbCA9IHRhcmdldENlbGxNYXAuY2VsbDtcblxuICAvLyBTZXQgdGhlIHNwYW5zIGZvciB0aGUgdGFyZ2V0IGNlbGxcbiAgdGFyZ2V0Q2VsbC5zZXRDb2xTcGFuKHRvdGFsQ29sU3Bhbik7XG4gIHRhcmdldENlbGwuc2V0Um93U3Bhbih0b3RhbFJvd1NwYW4pO1xuXG4gIC8vIE1vdmUgY29udGVudCBmcm9tIG90aGVyIGNlbGxzIHRvIHRoZSB0YXJnZXQgY2VsbFxuICBjb25zdCBzZWVuQ2VsbHMgPSBuZXcgU2V0KFt0YXJnZXRDZWxsLmdldEtleSgpXSk7XG5cbiAgLy8gU2Vjb25kIHBhc3M6IG1lcmdlIGNvbnRlbnQgYW5kIHJlbW92ZSBvdGhlciBjZWxsc1xuICBmb3IgKGxldCByb3cgPSBtaW5Sb3c7IHJvdyA8PSBtYXhSb3c7IHJvdysrKSB7XG4gICAgZm9yIChsZXQgY29sID0gbWluQ29sOyBjb2wgPD0gbWF4Q29sOyBjb2wrKykge1xuICAgICAgY29uc3QgbWFwQ2VsbCA9IGdyaWRNYXBbcm93XVtjb2xdO1xuICAgICAgaWYgKCFtYXBDZWxsLmNlbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IG1hcENlbGwuY2VsbDtcbiAgICAgIGNvbnN0IGtleSA9IGN1cnJlbnRDZWxsLmdldEtleSgpO1xuICAgICAgaWYgKCFzZWVuQ2VsbHMuaGFzKGtleSkpIHtcbiAgICAgICAgc2VlbkNlbGxzLmFkZChrZXkpO1xuICAgICAgICBjb25zdCBpc0VtcHR5ID0gJGNlbGxDb250YWluc0VtcHR5UGFyYWdyYXBoKGN1cnJlbnRDZWxsKTtcbiAgICAgICAgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgICAgdGFyZ2V0Q2VsbC5hcHBlbmQoLi4uY3VycmVudENlbGwuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudENlbGwucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRW5zdXJlIHRhcmdldCBjZWxsIGhhcyBjb250ZW50XG4gIGlmICh0YXJnZXRDZWxsLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgdGFyZ2V0Q2VsbC5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldENlbGw7XG59XG5mdW5jdGlvbiAkY2VsbENvbnRhaW5zRW1wdHlQYXJhZ3JhcGgoY2VsbCkge1xuICBpZiAoY2VsbC5nZXRDaGlsZHJlblNpemUoKSAhPT0gMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBmaXJzdENoaWxkID0gY2VsbC5nZXRGaXJzdENoaWxkT3JUaHJvdygpO1xuICBpZiAoISRpc1BhcmFncmFwaE5vZGUoZmlyc3RDaGlsZCkgfHwgIWZpcnN0Q2hpbGQuaXNFbXB0eSgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gJHVubWVyZ2VDZWxsKCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIGEgUmFuZ2VTZWxlY3Rpb24gb3IgVGFibGVTZWxlY3Rpb25gKTtcbiAgfVxuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgY29uc3QgY2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvciwgJGlzVGFibGVDZWxsTm9kZSk7XG4gIGlmICghJGlzVGFibGVDZWxsTm9kZShjZWxsTm9kZSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIHRvIGZpbmQgYSBwYXJlbnQgVGFibGVDZWxsTm9kZWApO1xuICB9XG4gIHJldHVybiAkdW5tZXJnZUNlbGxOb2RlKGNlbGxOb2RlKTtcbn1cbmZ1bmN0aW9uICR1bm1lcmdlQ2VsbE5vZGUoY2VsbE5vZGUpIHtcbiAgY29uc3QgW2NlbGwsIHJvdywgZ3JpZF0gPSAkZ2V0Tm9kZVRyaXBsZXQoY2VsbE5vZGUpO1xuICBjb25zdCBjb2xTcGFuID0gY2VsbC5fX2NvbFNwYW47XG4gIGNvbnN0IHJvd1NwYW4gPSBjZWxsLl9fcm93U3BhbjtcbiAgaWYgKGNvbFNwYW4gPT09IDEgJiYgcm93U3BhbiA9PT0gMSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBbbWFwLCBjZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgY2VsbCwgY2VsbCk7XG4gIGNvbnN0IHtcbiAgICBzdGFydENvbHVtbixcbiAgICBzdGFydFJvd1xuICB9ID0gY2VsbE1hcDtcbiAgLy8gQ3JlYXRlIGEgaGV1cmlzdGljIGZvciB3aGF0IHRoZSBzdHlsZSBvZiB0aGUgdW5tZXJnZWQgY2VsbHMgc2hvdWxkIGJlXG4gIC8vIGJhc2VkIG9uIHdoZXRoZXIgZXZlcnkgcm93IG9yIGNvbHVtbiBhbHJlYWR5IGhhZCB0aGF0IHN0YXRlIGJlZm9yZSB0aGVcbiAgLy8gdW5tZXJnZS5cbiAgY29uc3QgYmFzZUNvbFN0eWxlID0gY2VsbC5fX2hlYWRlclN0YXRlICYgVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTjtcbiAgY29uc3QgY29sU3R5bGVzID0gQXJyYXkuZnJvbSh7XG4gICAgbGVuZ3RoOiBjb2xTcGFuXG4gIH0sIChfdiwgaSkgPT4ge1xuICAgIGxldCBjb2xTdHlsZSA9IGJhc2VDb2xTdHlsZTtcbiAgICBmb3IgKGxldCByb3dJZHggPSAwOyBjb2xTdHlsZSAhPT0gMCAmJiByb3dJZHggPCBtYXAubGVuZ3RoOyByb3dJZHgrKykge1xuICAgICAgY29sU3R5bGUgJj0gbWFwW3Jvd0lkeF1baSArIHN0YXJ0Q29sdW1uXS5jZWxsLl9faGVhZGVyU3RhdGU7XG4gICAgfVxuICAgIHJldHVybiBjb2xTdHlsZTtcbiAgfSk7XG4gIGNvbnN0IGJhc2VSb3dTdHlsZSA9IGNlbGwuX19oZWFkZXJTdGF0ZSAmIFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1c7XG4gIGNvbnN0IHJvd1N0eWxlcyA9IEFycmF5LmZyb20oe1xuICAgIGxlbmd0aDogcm93U3BhblxuICB9LCAoX3YsIGkpID0+IHtcbiAgICBsZXQgcm93U3R5bGUgPSBiYXNlUm93U3R5bGU7XG4gICAgZm9yIChsZXQgY29sSWR4ID0gMDsgcm93U3R5bGUgIT09IDAgJiYgY29sSWR4IDwgbWFwWzBdLmxlbmd0aDsgY29sSWR4KyspIHtcbiAgICAgIHJvd1N0eWxlICY9IG1hcFtpICsgc3RhcnRSb3ddW2NvbElkeF0uY2VsbC5fX2hlYWRlclN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gcm93U3R5bGU7XG4gIH0pO1xuICBpZiAoY29sU3BhbiA+IDEpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGNvbFNwYW47IGkrKykge1xuICAgICAgY2VsbC5pbnNlcnRBZnRlcigkY3JlYXRlVGFibGVDZWxsTm9kZShjb2xTdHlsZXNbaV0gfCByb3dTdHlsZXNbMF0pLmFwcGVuZCgkY3JlYXRlUGFyYWdyYXBoTm9kZSgpKSk7XG4gICAgfVxuICAgIGNlbGwuc2V0Q29sU3BhbigxKTtcbiAgfVxuICBpZiAocm93U3BhbiA+IDEpIHtcbiAgICBsZXQgY3VycmVudFJvd05vZGU7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByb3dTcGFuOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1cnJlbnRSb3cgPSBzdGFydFJvdyArIGk7XG4gICAgICBjb25zdCBjdXJyZW50Um93TWFwID0gbWFwW2N1cnJlbnRSb3ddO1xuICAgICAgY3VycmVudFJvd05vZGUgPSAoY3VycmVudFJvd05vZGUgfHwgcm93KS5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoY3VycmVudFJvd05vZGUpKSB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgcm93IG5leHQgc2libGluZyB0byBiZSBhIHJvd2ApO1xuICAgICAgfVxuICAgICAgbGV0IGluc2VydEFmdGVyQ2VsbCA9IG51bGw7XG4gICAgICBmb3IgKGxldCBjb2x1bW4gPSAwOyBjb2x1bW4gPCBzdGFydENvbHVtbjsgY29sdW1uKyspIHtcbiAgICAgICAgY29uc3QgY3VycmVudENlbGxNYXAgPSBjdXJyZW50Um93TWFwW2NvbHVtbl07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsID0gY3VycmVudENlbGxNYXAuY2VsbDtcbiAgICAgICAgaWYgKGN1cnJlbnRDZWxsTWFwLnN0YXJ0Um93ID09PSBjdXJyZW50Um93KSB7XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsID0gY3VycmVudENlbGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRDZWxsLl9fY29sU3BhbiA+IDEpIHtcbiAgICAgICAgICBjb2x1bW4gKz0gY3VycmVudENlbGwuX19jb2xTcGFuIC0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGluc2VydEFmdGVyQ2VsbCA9PT0gbnVsbCkge1xuICAgICAgICBmb3IgKGxldCBqID0gY29sU3BhbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgJGluc2VydEZpcnN0KGN1cnJlbnRSb3dOb2RlLCAkY3JlYXRlVGFibGVDZWxsTm9kZShjb2xTdHlsZXNbal0gfCByb3dTdHlsZXNbaV0pLmFwcGVuZCgkY3JlYXRlUGFyYWdyYXBoTm9kZSgpKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGogPSBjb2xTcGFuIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICBpbnNlcnRBZnRlckNlbGwuaW5zZXJ0QWZ0ZXIoJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoY29sU3R5bGVzW2pdIHwgcm93U3R5bGVzW2ldKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNlbGwuc2V0Um93U3BhbigxKTtcbiAgfVxufVxuZnVuY3Rpb24gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGNlbGxBLCBjZWxsQikge1xuICBjb25zdCBbdGFibGVNYXAsIGNlbGxBVmFsdWUsIGNlbGxCVmFsdWVdID0gJGNvbXB1dGVUYWJsZU1hcFNraXBDZWxsQ2hlY2sodGFibGVOb2RlLCBjZWxsQSwgY2VsbEIpO1xuICBpZiAoIShjZWxsQVZhbHVlICE9PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgQW5jaG9yIG5vdCBmb3VuZCBpbiBUYWJsZWApO1xuICB9XG4gIGlmICghKGNlbGxCVmFsdWUgIT09IG51bGwpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBGb2N1cyBub3QgZm91bmQgaW4gVGFibGVgKTtcbiAgfVxuICByZXR1cm4gW3RhYmxlTWFwLCBjZWxsQVZhbHVlLCBjZWxsQlZhbHVlXTtcbn1cbmZ1bmN0aW9uICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrKHRhYmxlTm9kZSwgY2VsbEEsIGNlbGxCKSB7XG4gIGNvbnN0IHRhYmxlTWFwID0gW107XG4gIGxldCBjZWxsQVZhbHVlID0gbnVsbDtcbiAgbGV0IGNlbGxCVmFsdWUgPSBudWxsO1xuICBmdW5jdGlvbiBnZXRNYXBSb3coaSkge1xuICAgIGxldCByb3cgPSB0YWJsZU1hcFtpXTtcbiAgICBpZiAocm93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhYmxlTWFwW2ldID0gcm93ID0gW107XG4gICAgfVxuICAgIHJldHVybiByb3c7XG4gIH1cbiAgY29uc3QgZ3JpZENoaWxkcmVuID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IHJvd0lkeCA9IDA7IHJvd0lkeCA8IGdyaWRDaGlsZHJlbi5sZW5ndGg7IHJvd0lkeCsrKSB7XG4gICAgY29uc3Qgcm93ID0gZ3JpZENoaWxkcmVuW3Jvd0lkeF07XG4gICAgaWYgKCEkaXNUYWJsZVJvd05vZGUocm93KSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZU5vZGUgY2hpbGRyZW4gdG8gYmUgVGFibGVSb3dOb2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0TWFwUm93ID0gZ2V0TWFwUm93KHJvd0lkeCk7XG4gICAgZm9yIChsZXQgY2VsbCA9IHJvdy5nZXRGaXJzdENoaWxkKCksIGNvbElkeCA9IDA7IGNlbGwgIT0gbnVsbDsgY2VsbCA9IGNlbGwuZ2V0TmV4dFNpYmxpbmcoKSkge1xuICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGNlbGwpKSB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVSb3dOb2RlIGNoaWxkcmVuIHRvIGJlIFRhYmxlQ2VsbE5vZGVgKTtcbiAgICAgIH0gLy8gU2tpcCBwYXN0IGFueSBjb2x1bW5zIHRoYXQgd2VyZSBtZXJnZWQgZnJvbSBhIGhpZ2hlciByb3dcbiAgICAgIHdoaWxlIChzdGFydE1hcFJvd1tjb2xJZHhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29sSWR4Kys7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgc3RhcnRDb2x1bW46IGNvbElkeCxcbiAgICAgICAgc3RhcnRSb3c6IHJvd0lkeFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgX19yb3dTcGFuOiByb3dTcGFuLFxuICAgICAgICBfX2NvbFNwYW46IGNvbFNwYW5cbiAgICAgIH0gPSBjZWxsO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dTcGFuOyBqKyspIHtcbiAgICAgICAgaWYgKHJvd0lkeCArIGogPj0gZ3JpZENoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIC8vIFRoZSB0YWJsZSBpcyBub24tcmVjdGFuZ3VsYXIgd2l0aCBhIHJvd1NwYW5cbiAgICAgICAgICAvLyBiZWxvdyB0aGUgbGFzdCA8dHI+IGluIHRoZSB0YWJsZS5cbiAgICAgICAgICAvLyBXZSBzaG91bGQgcHJvYmFibHkgaGFuZGxlIHRoaXMgd2l0aCBhIG5vZGUgdHJhbnNmb3JtXG4gICAgICAgICAgLy8gdG8gZW5zdXJlIHRoYXQgdGFibGVzIGFyZSBhbHdheXMgcmVjdGFuZ3VsYXIgYnV0IHRoaXNcbiAgICAgICAgICAvLyB3aWxsIGF2b2lkIGNyYXNoZXMgc3VjaCBhcyAjNjU4NFxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGVyZSBhcmUgcHJvYmFibHkgc3RpbGwgbGF0ZW50IGJ1Z3NcbiAgICAgICAgICAvLyByZWdhcmRpbmcgY29sU3BhbiBvciBnZW5lcmFsIGNlbGwgY291bnQgbWlzbWF0Y2hlcy5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXBSb3cgPSBnZXRNYXBSb3cocm93SWR4ICsgaik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sU3BhbjsgaSsrKSB7XG4gICAgICAgICAgbWFwUm93W2NvbElkeCArIGldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjZWxsQSAhPT0gbnVsbCAmJiBjZWxsQVZhbHVlID09PSBudWxsICYmIGNlbGxBLmlzKGNlbGwpKSB7XG4gICAgICAgIGNlbGxBVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjZWxsQiAhPT0gbnVsbCAmJiBjZWxsQlZhbHVlID09PSBudWxsICYmIGNlbGxCLmlzKGNlbGwpKSB7XG4gICAgICAgIGNlbGxCVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFt0YWJsZU1hcCwgY2VsbEFWYWx1ZSwgY2VsbEJWYWx1ZV07XG59XG5mdW5jdGlvbiAkZ2V0Tm9kZVRyaXBsZXQoc291cmNlKSB7XG4gIGxldCBjZWxsO1xuICBpZiAoc291cmNlIGluc3RhbmNlb2YgVGFibGVDZWxsTm9kZSkge1xuICAgIGNlbGwgPSBzb3VyY2U7XG4gIH0gZWxzZSBpZiAoJ19fdHlwZScgaW4gc291cmNlKSB7XG4gICAgY29uc3QgY2VsbF8gPSAkZmluZE1hdGNoaW5nUGFyZW50KHNvdXJjZSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGNlbGxfKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0byBmaW5kIGEgcGFyZW50IFRhYmxlQ2VsbE5vZGVgKTtcbiAgICB9XG4gICAgY2VsbCA9IGNlbGxfO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNlbGxfID0gJGZpbmRNYXRjaGluZ1BhcmVudChzb3VyY2UuZ2V0Tm9kZSgpLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoY2VsbF8pKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIHRvIGZpbmQgYSBwYXJlbnQgVGFibGVDZWxsTm9kZWApO1xuICAgIH1cbiAgICBjZWxsID0gY2VsbF87XG4gIH1cbiAgY29uc3Qgcm93ID0gY2VsbC5nZXRQYXJlbnQoKTtcbiAgaWYgKCEkaXNUYWJsZVJvd05vZGUocm93KSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVDZWxsTm9kZSB0byBoYXZlIGEgcGFyZW50IFRhYmxlUm93Tm9kZWApO1xuICB9XG4gIGNvbnN0IGdyaWQgPSByb3cuZ2V0UGFyZW50KCk7XG4gIGlmICghJGlzVGFibGVOb2RlKGdyaWQpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZVJvd05vZGUgdG8gaGF2ZSBhIHBhcmVudCBUYWJsZU5vZGVgKTtcbiAgfVxuICByZXR1cm4gW2NlbGwsIHJvdywgZ3JpZF07XG59XG5mdW5jdGlvbiAkY29tcHV0ZVRhYmxlQ2VsbFJlY3RTcGFucyhtYXAsIGJvdW5kYXJ5KSB7XG4gIGNvbnN0IHtcbiAgICBtaW5Db2x1bW4sXG4gICAgbWF4Q29sdW1uLFxuICAgIG1pblJvdyxcbiAgICBtYXhSb3dcbiAgfSA9IGJvdW5kYXJ5O1xuICBsZXQgdG9wU3BhbiA9IDE7XG4gIGxldCBsZWZ0U3BhbiA9IDE7XG4gIGxldCByaWdodFNwYW4gPSAxO1xuICBsZXQgYm90dG9tU3BhbiA9IDE7XG4gIGNvbnN0IHRvcFJvdyA9IG1hcFttaW5Sb3ddO1xuICBjb25zdCBib3R0b21Sb3cgPSBtYXBbbWF4Um93XTtcbiAgZm9yIChsZXQgY29sID0gbWluQ29sdW1uOyBjb2wgPD0gbWF4Q29sdW1uOyBjb2wrKykge1xuICAgIHRvcFNwYW4gPSBNYXRoLm1heCh0b3BTcGFuLCB0b3BSb3dbY29sXS5jZWxsLl9fcm93U3Bhbik7XG4gICAgYm90dG9tU3BhbiA9IE1hdGgubWF4KGJvdHRvbVNwYW4sIGJvdHRvbVJvd1tjb2xdLmNlbGwuX19yb3dTcGFuKTtcbiAgfVxuICBmb3IgKGxldCByb3cgPSBtaW5Sb3c7IHJvdyA8PSBtYXhSb3c7IHJvdysrKSB7XG4gICAgbGVmdFNwYW4gPSBNYXRoLm1heChsZWZ0U3BhbiwgbWFwW3Jvd11bbWluQ29sdW1uXS5jZWxsLl9fY29sU3Bhbik7XG4gICAgcmlnaHRTcGFuID0gTWF0aC5tYXgocmlnaHRTcGFuLCBtYXBbcm93XVttYXhDb2x1bW5dLmNlbGwuX19jb2xTcGFuKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGJvdHRvbVNwYW4sXG4gICAgbGVmdFNwYW4sXG4gICAgcmlnaHRTcGFuLFxuICAgIHRvcFNwYW5cbiAgfTtcbn1cbmZ1bmN0aW9uICRjb21wdXRlVGFibGVDZWxsUmVjdEJvdW5kYXJ5KG1hcCwgY2VsbEFNYXAsIGNlbGxCTWFwKSB7XG4gIC8vIEluaXRpYWwgYm91bmRhcmllcyBiYXNlZCBvbiB0aGUgYW5jaG9yIGFuZCBmb2N1cyBjZWxsc1xuICBsZXQgbWluQ29sdW1uID0gTWF0aC5taW4oY2VsbEFNYXAuc3RhcnRDb2x1bW4sIGNlbGxCTWFwLnN0YXJ0Q29sdW1uKTtcbiAgbGV0IG1pblJvdyA9IE1hdGgubWluKGNlbGxBTWFwLnN0YXJ0Um93LCBjZWxsQk1hcC5zdGFydFJvdyk7XG4gIGxldCBtYXhDb2x1bW4gPSBNYXRoLm1heChjZWxsQU1hcC5zdGFydENvbHVtbiArIGNlbGxBTWFwLmNlbGwuX19jb2xTcGFuIC0gMSwgY2VsbEJNYXAuc3RhcnRDb2x1bW4gKyBjZWxsQk1hcC5jZWxsLl9fY29sU3BhbiAtIDEpO1xuICBsZXQgbWF4Um93ID0gTWF0aC5tYXgoY2VsbEFNYXAuc3RhcnRSb3cgKyBjZWxsQU1hcC5jZWxsLl9fcm93U3BhbiAtIDEsIGNlbGxCTWFwLnN0YXJ0Um93ICsgY2VsbEJNYXAuY2VsbC5fX3Jvd1NwYW4gLSAxKTtcblxuICAvLyBLZWVwIGV4cGFuZGluZyB1bnRpbCB3ZSBoYXZlIGEgY29tcGxldGUgcmVjdGFuZ2xlXG4gIGxldCBoYXNDaGFuZ2VzO1xuICBkbyB7XG4gICAgaGFzQ2hhbmdlcyA9IGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYWxsIGNlbGxzIGluIHRoZSB0YWJsZVxuICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IG1hcC5sZW5ndGg7IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBtYXBbMF0ubGVuZ3RoOyBjb2wrKykge1xuICAgICAgICBjb25zdCBjZWxsID0gbWFwW3Jvd11bY29sXTtcbiAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2VsbEVuZENvbCA9IGNlbGwuc3RhcnRDb2x1bW4gKyBjZWxsLmNlbGwuX19jb2xTcGFuIC0gMTtcbiAgICAgICAgY29uc3QgY2VsbEVuZFJvdyA9IGNlbGwuc3RhcnRSb3cgKyBjZWxsLmNlbGwuX19yb3dTcGFuIC0gMTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGNlbGwgaW50ZXJzZWN0cyB3aXRoIG91ciBjdXJyZW50IHNlbGVjdGlvbiByZWN0YW5nbGVcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0c0hvcml6b250YWxseSA9IGNlbGwuc3RhcnRDb2x1bW4gPD0gbWF4Q29sdW1uICYmIGNlbGxFbmRDb2wgPj0gbWluQ29sdW1uO1xuICAgICAgICBjb25zdCBpbnRlcnNlY3RzVmVydGljYWxseSA9IGNlbGwuc3RhcnRSb3cgPD0gbWF4Um93ICYmIGNlbGxFbmRSb3cgPj0gbWluUm93O1xuXG4gICAgICAgIC8vIElmIHRoZSBjZWxsIGludGVyc2VjdHMgZWl0aGVyIGhvcml6b250YWxseSBvciB2ZXJ0aWNhbGx5XG4gICAgICAgIGlmIChpbnRlcnNlY3RzSG9yaXpvbnRhbGx5ICYmIGludGVyc2VjdHNWZXJ0aWNhbGx5KSB7XG4gICAgICAgICAgLy8gRXhwYW5kIGJvdW5kYXJpZXMgdG8gaW5jbHVkZSB0aGlzIGNlbGwgY29tcGxldGVseVxuICAgICAgICAgIGNvbnN0IG5ld01pbkNvbHVtbiA9IE1hdGgubWluKG1pbkNvbHVtbiwgY2VsbC5zdGFydENvbHVtbik7XG4gICAgICAgICAgY29uc3QgbmV3TWF4Q29sdW1uID0gTWF0aC5tYXgobWF4Q29sdW1uLCBjZWxsRW5kQ29sKTtcbiAgICAgICAgICBjb25zdCBuZXdNaW5Sb3cgPSBNYXRoLm1pbihtaW5Sb3csIGNlbGwuc3RhcnRSb3cpO1xuICAgICAgICAgIGNvbnN0IG5ld01heFJvdyA9IE1hdGgubWF4KG1heFJvdywgY2VsbEVuZFJvdyk7XG5cbiAgICAgICAgICAvLyBDaGVjayBpZiBib3VuZGFyaWVzIGNoYW5nZWRcbiAgICAgICAgICBpZiAobmV3TWluQ29sdW1uICE9PSBtaW5Db2x1bW4gfHwgbmV3TWF4Q29sdW1uICE9PSBtYXhDb2x1bW4gfHwgbmV3TWluUm93ICE9PSBtaW5Sb3cgfHwgbmV3TWF4Um93ICE9PSBtYXhSb3cpIHtcbiAgICAgICAgICAgIG1pbkNvbHVtbiA9IG5ld01pbkNvbHVtbjtcbiAgICAgICAgICAgIG1heENvbHVtbiA9IG5ld01heENvbHVtbjtcbiAgICAgICAgICAgIG1pblJvdyA9IG5ld01pblJvdztcbiAgICAgICAgICAgIG1heFJvdyA9IG5ld01heFJvdztcbiAgICAgICAgICAgIGhhc0NoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSB3aGlsZSAoaGFzQ2hhbmdlcyk7XG4gIHJldHVybiB7XG4gICAgbWF4Q29sdW1uLFxuICAgIG1heFJvdyxcbiAgICBtaW5Db2x1bW4sXG4gICAgbWluUm93XG4gIH07XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVDZWxsTm9kZVJlY3QodGFibGVDZWxsTm9kZSkge1xuICBjb25zdCBbY2VsbE5vZGUsLCBncmlkTm9kZV0gPSAkZ2V0Tm9kZVRyaXBsZXQodGFibGVDZWxsTm9kZSk7XG4gIGNvbnN0IHJvd3MgPSBncmlkTm9kZS5nZXRDaGlsZHJlbigpO1xuICBjb25zdCByb3dDb3VudCA9IHJvd3MubGVuZ3RoO1xuICBjb25zdCBjb2x1bW5Db3VudCA9IHJvd3NbMF0uZ2V0Q2hpbGRyZW4oKS5sZW5ndGg7XG5cbiAgLy8gQ3JlYXRlIGEgbWF0cml4IG9mIHRoZSBzYW1lIHNpemUgYXMgdGhlIHRhYmxlIHRvIHRyYWNrIHRoZSBwb3NpdGlvbiBvZiBlYWNoIGNlbGxcbiAgY29uc3QgY2VsbE1hdHJpeCA9IG5ldyBBcnJheShyb3dDb3VudCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGNlbGxNYXRyaXhbaV0gPSBuZXcgQXJyYXkoY29sdW1uQ291bnQpO1xuICB9XG4gIGZvciAobGV0IHJvd0luZGV4ID0gMDsgcm93SW5kZXggPCByb3dDb3VudDsgcm93SW5kZXgrKykge1xuICAgIGNvbnN0IHJvdyA9IHJvd3Nbcm93SW5kZXhdO1xuICAgIGNvbnN0IGNlbGxzID0gcm93LmdldENoaWxkcmVuKCk7XG4gICAgbGV0IGNvbHVtbkluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBjZWxsSW5kZXggPSAwOyBjZWxsSW5kZXggPCBjZWxscy5sZW5ndGg7IGNlbGxJbmRleCsrKSB7XG4gICAgICAvLyBGaW5kIHRoZSBuZXh0IGF2YWlsYWJsZSBwb3NpdGlvbiBpbiB0aGUgbWF0cml4LCBza2lwIHRoZSBwb3NpdGlvbiBvZiBtZXJnZWQgY2VsbHNcbiAgICAgIHdoaWxlIChjZWxsTWF0cml4W3Jvd0luZGV4XVtjb2x1bW5JbmRleF0pIHtcbiAgICAgICAgY29sdW1uSW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNlbGwgPSBjZWxsc1tjZWxsSW5kZXhdO1xuICAgICAgY29uc3Qgcm93U3BhbiA9IGNlbGwuX19yb3dTcGFuIHx8IDE7XG4gICAgICBjb25zdCBjb2xTcGFuID0gY2VsbC5fX2NvbFNwYW4gfHwgMTtcblxuICAgICAgLy8gUHV0IHRoZSBjZWxsIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgcG9zaXRpb24gaW4gdGhlIG1hdHJpeFxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dTcGFuOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xTcGFuOyBqKyspIHtcbiAgICAgICAgICBjZWxsTWF0cml4W3Jvd0luZGV4ICsgaV1bY29sdW1uSW5kZXggKyBqXSA9IGNlbGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUmV0dXJuIHRvIHRoZSBvcmlnaW5hbCBpbmRleCwgcm93IHNwYW4gYW5kIGNvbHVtbiBzcGFuIG9mIHRoZSBjZWxsLlxuICAgICAgaWYgKGNlbGxOb2RlID09PSBjZWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29sU3BhbixcbiAgICAgICAgICBjb2x1bW5JbmRleCxcbiAgICAgICAgICByb3dJbmRleCxcbiAgICAgICAgICByb3dTcGFuXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb2x1bW5JbmRleCArPSBjb2xTcGFuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gJGdldENlbGxOb2Rlcyh0YWJsZVNlbGVjdGlvbikge1xuICBjb25zdCBbW2FuY2hvck5vZGUsIGFuY2hvckNlbGwsIGFuY2hvclJvdywgYW5jaG9yVGFibGVdLCBbZm9jdXNOb2RlLCBmb2N1c0NlbGwsIGZvY3VzUm93LCBmb2N1c1RhYmxlXV0gPSBbJ2FuY2hvcicsICdmb2N1cyddLm1hcChrID0+IHtcbiAgICBjb25zdCBub2RlID0gdGFibGVTZWxlY3Rpb25ba10uZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChub2RlLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoY2VsbE5vZGUpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIFRhYmxlU2VsZWN0aW9uICR7a30gdG8gYmUgKG9yIGEgY2hpbGQgb2YpIFRhYmxlQ2VsbE5vZGUsIGdvdCBrZXkgJHtub2RlLmdldEtleSgpfSBvZiB0eXBlICR7bm9kZS5nZXRUeXBlKCl9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJvd05vZGUgPSBjZWxsTm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShyb3dOb2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZVNlbGVjdGlvbiAke2t9IGNlbGwgcGFyZW50IHRvIGJlIGEgVGFibGVSb3dOb2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IHRhYmxlTm9kZSA9IHJvd05vZGUuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZVNlbGVjdGlvbiAke2t9IHJvdyBwYXJlbnQgdG8gYmUgYSBUYWJsZU5vZGVgKTtcbiAgICB9XG4gICAgcmV0dXJuIFtub2RlLCBjZWxsTm9kZSwgcm93Tm9kZSwgdGFibGVOb2RlXTtcbiAgfSk7XG4gIC8vIFRPRE86IG5lc3RlZCB0YWJsZXMgbWF5IHZpb2xhdGUgdGhpc1xuICBpZiAoIWFuY2hvclRhYmxlLmlzKGZvY3VzVGFibGUpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZVNlbGVjdGlvbiBhbmNob3IgYW5kIGZvY3VzIHRvIGJlIGluIHRoZSBzYW1lIHRhYmxlYCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhbmNob3JDZWxsLFxuICAgIGFuY2hvck5vZGUsXG4gICAgYW5jaG9yUm93LFxuICAgIGFuY2hvclRhYmxlLFxuICAgIGZvY3VzQ2VsbCxcbiAgICBmb2N1c05vZGUsXG4gICAgZm9jdXNSb3csXG4gICAgZm9jdXNUYWJsZVxuICB9O1xufVxuY2xhc3MgVGFibGVTZWxlY3Rpb24ge1xuICBjb25zdHJ1Y3Rvcih0YWJsZUtleSwgYW5jaG9yLCBmb2N1cykge1xuICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgIHRoaXMuZm9jdXMgPSBmb2N1cztcbiAgICBhbmNob3IuX3NlbGVjdGlvbiA9IHRoaXM7XG4gICAgZm9jdXMuX3NlbGVjdGlvbiA9IHRoaXM7XG4gICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBudWxsO1xuICAgIHRoaXMuZGlydHkgPSBmYWxzZTtcbiAgICB0aGlzLnRhYmxlS2V5ID0gdGFibGVLZXk7XG4gIH1cbiAgZ2V0U3RhcnRFbmRQb2ludHMoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmFuY2hvciwgdGhpcy5mb2N1c107XG4gIH1cblxuICAvKipcbiAgICoge0BsaW5rICRjcmVhdGVUYWJsZVNlbGVjdGlvbn0gdW5mb3J0dW5hdGVseSBtYWtlcyBpdCB2ZXJ5IGVhc3kgdG8gY3JlYXRlXG4gICAqIG5vbnNlbnNlIHNlbGVjdGlvbnMsIHNvIHdlIGhhdmUgYSBtZXRob2QgdG8gc2VlIGlmIHRoZSBzZWxlY3Rpb24gcHJvYmFibHlcbiAgICogbWFrZXMgc2Vuc2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRhYmxlU2VsZWN0aW9uIGlzIChwcm9iYWJseSkgdmFsaWRcbiAgICovXG4gIGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudGFibGVLZXkgIT09ICdyb290JyAmJiB0aGlzLmFuY2hvci5rZXkgIT09ICdyb290JyAmJiB0aGlzLmFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgdGhpcy5mb2N1cy5rZXkgIT09ICdyb290JyAmJiB0aGlzLmZvY3VzLnR5cGUgPT09ICdlbGVtZW50JztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIFNlbGVjdGlvbiBpcyBcImJhY2t3YXJkc1wiLCBtZWFuaW5nIHRoZSBmb2N1c1xuICAgKiBsb2dpY2FsbHkgcHJlY2VkZXMgdGhlIGFuY2hvciBpbiB0aGUgRWRpdG9yU3RhdGUuXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFNlbGVjdGlvbiBpcyBiYWNrd2FyZHMsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzQmFja3dhcmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXMuaXNCZWZvcmUodGhpcy5hbmNob3IpO1xuICB9XG4gIGdldENhY2hlZE5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWROb2RlcztcbiAgfVxuICBzZXRDYWNoZWROb2Rlcyhub2Rlcykge1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbm9kZXM7XG4gIH1cbiAgaXMoc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgdGhpcy50YWJsZUtleSA9PT0gc2VsZWN0aW9uLnRhYmxlS2V5ICYmIHRoaXMuYW5jaG9yLmlzKHNlbGVjdGlvbi5hbmNob3IpICYmIHRoaXMuZm9jdXMuaXMoc2VsZWN0aW9uLmZvY3VzKTtcbiAgfVxuICBzZXQodGFibGVLZXksIGFuY2hvckNlbGxLZXksIGZvY3VzQ2VsbEtleSkge1xuICAgIC8vIG5vdGU6IGNsb3N1cmUgY29tcGlsZXIncyBhY29ybiBkb2VzIG5vdCBzdXBwb3J0IHx8PVxuICAgIHRoaXMuZGlydHkgPSB0aGlzLmRpcnR5IHx8IHRhYmxlS2V5ICE9PSB0aGlzLnRhYmxlS2V5IHx8IGFuY2hvckNlbGxLZXkgIT09IHRoaXMuYW5jaG9yLmtleSB8fCBmb2N1c0NlbGxLZXkgIT09IHRoaXMuZm9jdXMua2V5O1xuICAgIHRoaXMudGFibGVLZXkgPSB0YWJsZUtleTtcbiAgICB0aGlzLmFuY2hvci5rZXkgPSBhbmNob3JDZWxsS2V5O1xuICAgIHRoaXMuZm9jdXMua2V5ID0gZm9jdXNDZWxsS2V5O1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IFRhYmxlU2VsZWN0aW9uKHRoaXMudGFibGVLZXksICRjcmVhdGVQb2ludCh0aGlzLmFuY2hvci5rZXksIHRoaXMuYW5jaG9yLm9mZnNldCwgdGhpcy5hbmNob3IudHlwZSksICRjcmVhdGVQb2ludCh0aGlzLmZvY3VzLmtleSwgdGhpcy5mb2N1cy5vZmZzZXQsIHRoaXMuZm9jdXMudHlwZSkpO1xuICB9XG4gIGlzQ29sbGFwc2VkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBleHRyYWN0KCkge1xuICAgIHJldHVybiB0aGlzLmdldE5vZGVzKCk7XG4gIH1cbiAgaW5zZXJ0UmF3VGV4dCh0ZXh0KSB7XG4gICAgLy8gRG8gbm90aGluZz9cbiAgfVxuICBpbnNlcnRUZXh0KCkge1xuICAgIC8vIERvIG5vdGhpbmc/XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBUZXh0Rm9ybWF0VHlwZSBpcyBwcmVzZW50IG9uIHRoZSBTZWxlY3Rpb24uXG4gICAqIFRoaXMgd2lsbCBiZSB0cnVlIGlmIGFueSBwYXJhZ3JhcGggaW4gdGFibGUgY2VsbHMgaGFzIHRoZSBzcGVjaWZpZWQgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZSB0aGUgVGV4dEZvcm1hdFR5cGUgdG8gY2hlY2sgZm9yLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBmb3JtYXQgaXMgY3VycmVudGx5IHRvZ2dsZWQgb24gb24gdGhlIFNlbGVjdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaGFzRm9ybWF0KHR5cGUpIHtcbiAgICBsZXQgZm9ybWF0ID0gMDtcbiAgICBjb25zdCBjZWxsTm9kZXMgPSB0aGlzLmdldE5vZGVzKCkuZmlsdGVyKCRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGNlbGxOb2Rlcy5mb3JFYWNoKGNlbGxOb2RlID0+IHtcbiAgICAgIGNvbnN0IHBhcmFncmFwaCA9IGNlbGxOb2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmICgkaXNQYXJhZ3JhcGhOb2RlKHBhcmFncmFwaCkpIHtcbiAgICAgICAgZm9ybWF0IHw9IHBhcmFncmFwaC5nZXRUZXh0Rm9ybWF0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZm9ybWF0RmxhZyA9IFRFWFRfVFlQRV9UT19GT1JNQVRbdHlwZV07XG4gICAgcmV0dXJuIChmb3JtYXQgJiBmb3JtYXRGbGFnKSAhPT0gMDtcbiAgfVxuICBpbnNlcnROb2Rlcyhub2Rlcykge1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHRoaXMuZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmICghJGlzRWxlbWVudE5vZGUoZm9jdXNOb2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZVNlbGVjdGlvbiBmb2N1cyB0byBiZSBhbiBFbGVtZW50Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkbm9ybWFsaXplU2VsZWN0aW9uX19FWFBFUklNRU5UQUwoZm9jdXNOb2RlLnNlbGVjdCgwLCBmb2N1c05vZGUuZ2V0Q2hpbGRyZW5TaXplKCkpKTtcbiAgICBzZWxlY3Rpb24uaW5zZXJ0Tm9kZXMobm9kZXMpO1xuICB9XG5cbiAgLy8gVE9ETyBEZXByZWNhdGUgdGhpcyBtZXRob2QuIEl0J3MgY29uZnVzaW5nIHdoZW4gdXNlZCB3aXRoIGNvbHNwYW58cm93c3BhblxuICBnZXRTaGFwZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JDZWxsLFxuICAgICAgZm9jdXNDZWxsXG4gICAgfSA9ICRnZXRDZWxsTm9kZXModGhpcyk7XG4gICAgY29uc3QgYW5jaG9yQ2VsbE5vZGVSZWN0ID0gJGdldFRhYmxlQ2VsbE5vZGVSZWN0KGFuY2hvckNlbGwpO1xuICAgIGlmICghKGFuY2hvckNlbGxOb2RlUmVjdCAhPT0gbnVsbCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgZ2V0Q2VsbFJlY3Q6IGV4cGVjdGVkIHRvIGZpbmQgQW5jaG9yTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBmb2N1c0NlbGxOb2RlUmVjdCA9ICRnZXRUYWJsZUNlbGxOb2RlUmVjdChmb2N1c0NlbGwpO1xuICAgIGlmICghKGZvY3VzQ2VsbE5vZGVSZWN0ICE9PSBudWxsKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBnZXRDZWxsUmVjdDogZXhwZWN0ZWQgdG8gZmluZCBmb2N1c0NlbGxOb2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0WCA9IE1hdGgubWluKGFuY2hvckNlbGxOb2RlUmVjdC5jb2x1bW5JbmRleCwgZm9jdXNDZWxsTm9kZVJlY3QuY29sdW1uSW5kZXgpO1xuICAgIGNvbnN0IHN0b3BYID0gTWF0aC5tYXgoYW5jaG9yQ2VsbE5vZGVSZWN0LmNvbHVtbkluZGV4ICsgYW5jaG9yQ2VsbE5vZGVSZWN0LmNvbFNwYW4gLSAxLCBmb2N1c0NlbGxOb2RlUmVjdC5jb2x1bW5JbmRleCArIGZvY3VzQ2VsbE5vZGVSZWN0LmNvbFNwYW4gLSAxKTtcbiAgICBjb25zdCBzdGFydFkgPSBNYXRoLm1pbihhbmNob3JDZWxsTm9kZVJlY3Qucm93SW5kZXgsIGZvY3VzQ2VsbE5vZGVSZWN0LnJvd0luZGV4KTtcbiAgICBjb25zdCBzdG9wWSA9IE1hdGgubWF4KGFuY2hvckNlbGxOb2RlUmVjdC5yb3dJbmRleCArIGFuY2hvckNlbGxOb2RlUmVjdC5yb3dTcGFuIC0gMSwgZm9jdXNDZWxsTm9kZVJlY3Qucm93SW5kZXggKyBmb2N1c0NlbGxOb2RlUmVjdC5yb3dTcGFuIC0gMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb21YOiBNYXRoLm1pbihzdGFydFgsIHN0b3BYKSxcbiAgICAgIGZyb21ZOiBNYXRoLm1pbihzdGFydFksIHN0b3BZKSxcbiAgICAgIHRvWDogTWF0aC5tYXgoc3RhcnRYLCBzdG9wWCksXG4gICAgICB0b1k6IE1hdGgubWF4KHN0YXJ0WSwgc3RvcFkpXG4gICAgfTtcbiAgfVxuICBnZXROb2RlcygpIHtcbiAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlZE5vZGVzID0gdGhpcy5fY2FjaGVkTm9kZXM7XG4gICAgaWYgKGNhY2hlZE5vZGVzICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY2FjaGVkTm9kZXM7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvclRhYmxlOiB0YWJsZU5vZGUsXG4gICAgICBhbmNob3JDZWxsLFxuICAgICAgZm9jdXNDZWxsXG4gICAgfSA9ICRnZXRDZWxsTm9kZXModGhpcyk7XG4gICAgY29uc3QgZm9jdXNDZWxsR3JpZCA9IGZvY3VzQ2VsbC5nZXRQYXJlbnRzKClbMV07XG4gICAgaWYgKGZvY3VzQ2VsbEdyaWQgIT09IHRhYmxlTm9kZSkge1xuICAgICAgaWYgKCF0YWJsZU5vZGUuaXNQYXJlbnRPZihmb2N1c0NlbGwpKSB7XG4gICAgICAgIC8vIGZvY3VzIGlzIG9uIGhpZ2hlciBHcmlkIGxldmVsIHRoYW4gYW5jaG9yXG4gICAgICAgIGNvbnN0IGdyaWRQYXJlbnQgPSB0YWJsZU5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmICghKGdyaWRQYXJlbnQgIT0gbnVsbCkpIHtcbiAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIGdyaWRQYXJlbnQgdG8gaGF2ZSBhIHBhcmVudGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0KHRoaXMudGFibGVLZXksIGdyaWRQYXJlbnQuZ2V0S2V5KCksIGZvY3VzQ2VsbC5nZXRLZXkoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBhbmNob3IgaXMgb24gaGlnaGVyIEdyaWQgbGV2ZWwgdGhhbiBmb2N1c1xuICAgICAgICBjb25zdCBmb2N1c0NlbGxQYXJlbnQgPSBmb2N1c0NlbGxHcmlkLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoIShmb2N1c0NlbGxQYXJlbnQgIT0gbnVsbCkpIHtcbiAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIGZvY3VzQ2VsbFBhcmVudCB0byBoYXZlIGEgcGFyZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXQodGhpcy50YWJsZUtleSwgZm9jdXNDZWxsLmdldEtleSgpLCBmb2N1c0NlbGxQYXJlbnQuZ2V0S2V5KCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0Tm9kZXMoKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIE1hcHBpbmcgdGhlIHdob2xlIEdyaWQgZXZlcnkgdGltZSBub3QgZWZmaWNpZW50LiBXZSBuZWVkIHRvIGNvbXB1dGUgdGhlIGVudGlyZSBzdGF0ZSBvbmx5XG4gICAgLy8gb25jZSAob24gbG9hZCkgYW5kIGl0ZXJhdGUgb24gaXQgYXMgdXBkYXRlcyBvY2N1ci4gSG93ZXZlciwgdG8gZG8gdGhpcyB3ZSBuZWVkIHRvIGhhdmUgdGhlXG4gICAgLy8gYWJpbGl0eSB0byBzdG9yZSBhIHN0YXRlLiBLaWxsaW5nIFRhYmxlU2VsZWN0aW9uIGFuZCBtb3ZpbmcgdGhlIGxvZ2ljIHRvIHRoZSBwbHVnaW4gd291bGQgbWFrZVxuICAgIC8vIHRoaXMgcG9zc2libGUuXG4gICAgY29uc3QgW21hcCwgY2VsbEFNYXAsIGNlbGxCTWFwXSA9ICRjb21wdXRlVGFibGVNYXAodGFibGVOb2RlLCBhbmNob3JDZWxsLCBmb2N1c0NlbGwpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1pbkNvbHVtbixcbiAgICAgIG1heENvbHVtbixcbiAgICAgIG1pblJvdyxcbiAgICAgIG1heFJvd1xuICAgIH0gPSAkY29tcHV0ZVRhYmxlQ2VsbFJlY3RCb3VuZGFyeShtYXAsIGNlbGxBTWFwLCBjZWxsQk1hcCk7XG5cbiAgICAvLyBXZSB1c2UgYSBNYXAgaGVyZSBiZWNhdXNlIG1lcmdlZCBjZWxscyBpbiB0aGUgZ3JpZCB3b3VsZCBvdGhlcndpc2VcbiAgICAvLyBzaG93IHVwIG11bHRpcGxlIHRpbWVzIGluIHRoZSBub2RlcyBhcnJheVxuICAgIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwKFtbdGFibGVOb2RlLmdldEtleSgpLCB0YWJsZU5vZGVdXSk7XG4gICAgbGV0IGxhc3RSb3cgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSBtaW5Sb3c7IGkgPD0gbWF4Um93OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBtaW5Db2x1bW47IGogPD0gbWF4Q29sdW1uOyBqKyspIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNlbGxcbiAgICAgICAgfSA9IG1hcFtpXVtqXTtcbiAgICAgICAgY29uc3QgY3VycmVudFJvdyA9IGNlbGwuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKGN1cnJlbnRSb3cpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZUNlbGxOb2RlIHBhcmVudCB0byBiZSBhIFRhYmxlUm93Tm9kZWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50Um93ICE9PSBsYXN0Um93KSB7XG4gICAgICAgICAgbm9kZU1hcC5zZXQoY3VycmVudFJvdy5nZXRLZXkoKSwgY3VycmVudFJvdyk7XG4gICAgICAgICAgbGFzdFJvdyA9IGN1cnJlbnRSb3c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub2RlTWFwLmhhcyhjZWxsLmdldEtleSgpKSkge1xuICAgICAgICAgICR2aXNpdFJlY3Vyc2l2ZWx5KGNlbGwsIGNoaWxkTm9kZSA9PiB7XG4gICAgICAgICAgICBub2RlTWFwLnNldChjaGlsZE5vZGUuZ2V0S2V5KCksIGNoaWxkTm9kZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9kZXMgPSBBcnJheS5mcm9tKG5vZGVNYXAudmFsdWVzKCkpO1xuICAgIGlmICghaXNDdXJyZW50bHlSZWFkT25seU1vZGUoKSkge1xuICAgICAgdGhpcy5fY2FjaGVkTm9kZXMgPSBub2RlcztcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG4gIGdldFRleHRDb250ZW50KCkge1xuICAgIGNvbnN0IG5vZGVzID0gdGhpcy5nZXROb2RlcygpLmZpbHRlcihub2RlID0+ICRpc1RhYmxlQ2VsbE5vZGUobm9kZSkpO1xuICAgIGxldCB0ZXh0Q29udGVudCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGNvbnN0IHJvdyA9IG5vZGUuX19wYXJlbnQ7XG4gICAgICBjb25zdCBuZXh0Um93ID0gKG5vZGVzW2kgKyAxXSB8fCB7fSkuX19wYXJlbnQ7XG4gICAgICB0ZXh0Q29udGVudCArPSBub2RlLmdldFRleHRDb250ZW50KCkgKyAobmV4dFJvdyAhPT0gcm93ID8gJ1xcbicgOiAnXFx0Jyk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0Q29udGVudDtcbiAgfVxufVxuZnVuY3Rpb24gJGlzVGFibGVTZWxlY3Rpb24oeCkge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIFRhYmxlU2VsZWN0aW9uO1xufVxuZnVuY3Rpb24gJGNyZWF0ZVRhYmxlU2VsZWN0aW9uKCkge1xuICAvLyBUT0RPIHRoaXMgaXMgYSBzdWJvcHRpbWFsIGRlc2lnbiwgaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIGhhdmVcbiAgLy8gYSB0YWJsZSBzZWxlY3Rpb24gdGhhdCBpc24ndCBhc3NvY2lhdGVkIHdpdGggYSB0YWJsZS4gVGhpc1xuICAvLyBjb25zdHJ1Y3RvciBzaG91bGQgaGF2ZSByZXF1aXJlZCBhcmd1bWVudHMgYW5kIGluIHRydWUgd2VcbiAgLy8gc2hvdWxkIGNoZWNrIHRoYXQgdGhleSBwb2ludCB0byBhIHRhYmxlIGFuZCBhcmUgZWxlbWVudCBwb2ludHMgdG9cbiAgLy8gY2VsbCBub2RlcyBvZiB0aGF0IHRhYmxlLlxuICBjb25zdCBhbmNob3IgPSAkY3JlYXRlUG9pbnQoJ3Jvb3QnLCAwLCAnZWxlbWVudCcpO1xuICBjb25zdCBmb2N1cyA9ICRjcmVhdGVQb2ludCgncm9vdCcsIDAsICdlbGVtZW50Jyk7XG4gIHJldHVybiBuZXcgVGFibGVTZWxlY3Rpb24oJ3Jvb3QnLCBhbmNob3IsIGZvY3VzKTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZVNlbGVjdGlvbkZyb20odGFibGVOb2RlLCBhbmNob3JDZWxsLCBmb2N1c0NlbGwpIHtcbiAgY29uc3QgdGFibGVOb2RlS2V5ID0gdGFibGVOb2RlLmdldEtleSgpO1xuICBjb25zdCBhbmNob3JDZWxsS2V5ID0gYW5jaG9yQ2VsbC5nZXRLZXkoKTtcbiAgY29uc3QgZm9jdXNDZWxsS2V5ID0gZm9jdXNDZWxsLmdldEtleSgpO1xuICB7XG4gICAgaWYgKCF0YWJsZU5vZGUuaXNBdHRhY2hlZCgpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRjcmVhdGVUYWJsZVNlbGVjdGlvbkZyb206IHRhYmxlTm9kZSAke3RhYmxlTm9kZUtleX0gaXMgbm90IGF0dGFjaGVkYCk7XG4gICAgfVxuICAgIGlmICghdGFibGVOb2RlLmlzKCRmaW5kVGFibGVOb2RlKGFuY2hvckNlbGwpKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkY3JlYXRlVGFibGVTZWxlY3Rpb25Gcm9tOiBhbmNob3JDZWxsICR7YW5jaG9yQ2VsbEtleX0gaXMgbm90IGluIHRhYmxlICR7dGFibGVOb2RlS2V5fWApO1xuICAgIH1cbiAgICBpZiAoIXRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShmb2N1c0NlbGwpKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkY3JlYXRlVGFibGVTZWxlY3Rpb25Gcm9tOiBmb2N1c0NlbGwgJHtmb2N1c0NlbGxLZXl9IGlzIG5vdCBpbiB0YWJsZSAke3RhYmxlTm9kZUtleX1gKTtcbiAgICB9IC8vIFRPRE86IENoZWNrIGZvciByZWN0YW5ndWxhciBncmlkXG4gIH1cbiAgY29uc3QgcHJldlNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgY29uc3QgbmV4dFNlbGVjdGlvbiA9ICRpc1RhYmxlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pID8gcHJldlNlbGVjdGlvbi5jbG9uZSgpIDogJGNyZWF0ZVRhYmxlU2VsZWN0aW9uKCk7XG4gIG5leHRTZWxlY3Rpb24uc2V0KHRhYmxlTm9kZS5nZXRLZXkoKSwgYW5jaG9yQ2VsbC5nZXRLZXkoKSwgZm9jdXNDZWxsLmdldEtleSgpKTtcbiAgcmV0dXJuIG5leHRTZWxlY3Rpb247XG59XG5cbi8qKlxuICogRGVwdGggZmlyc3QgdmlzaXRvclxuICogQHBhcmFtIG5vZGUgVGhlIHN0YXJ0aW5nIG5vZGVcbiAqIEBwYXJhbSAkdmlzaXQgVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggbm9kZS4gSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UsIHRoZW4gY2hpbGRyZW4gb2YgdGhpcyBub2RlIHdpbGwgbm90IGJlIGV4cGxvcmVkXG4gKi9cbmZ1bmN0aW9uICR2aXNpdFJlY3Vyc2l2ZWx5KG5vZGUsICR2aXNpdCkge1xuICBjb25zdCBzdGFjayA9IFtbbm9kZV1dO1xuICBmb3IgKGxldCBjdXJyZW50QXJyYXkgPSBzdGFjay5hdCgtMSk7IGN1cnJlbnRBcnJheSAhPT0gdW5kZWZpbmVkICYmIHN0YWNrLmxlbmd0aCA+IDA7IGN1cnJlbnRBcnJheSA9IHN0YWNrLmF0KC0xKSkge1xuICAgIGNvbnN0IGN1cnJlbnROb2RlID0gY3VycmVudEFycmF5LnBvcCgpO1xuICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdGFjay5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKCR2aXNpdChjdXJyZW50Tm9kZSkgIT09IGZhbHNlICYmICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgc3RhY2sucHVzaChjdXJyZW50Tm9kZS5nZXRDaGlsZHJlbigpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gJGdldFRhYmxlQW5kRWxlbWVudEJ5S2V5KHRhYmxlTm9kZUtleSwgZWRpdG9yID0gJGdldEVkaXRvcigpKSB7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXROb2RlQnlLZXkodGFibGVOb2RlS2V5KTtcbiAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgVGFibGVPYnNlcnZlcjogRXhwZWN0ZWQgdGFibGVOb2RlS2V5ICR7dGFibGVOb2RlS2V5fSB0byBiZSBhIFRhYmxlTm9kZWApO1xuICB9XG4gIGNvbnN0IHRhYmxlRWxlbWVudCA9IGdldFRhYmxlRWxlbWVudCh0YWJsZU5vZGUsIGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGFibGVOb2RlS2V5KSk7XG4gIGlmICghKHRhYmxlRWxlbWVudCAhPT0gbnVsbCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFRhYmxlT2JzZXJ2ZXI6IEV4cGVjdGVkIHRvIGZpbmQgVGFibGVFbGVtZW50IGluIERPTSBmb3Iga2V5ICR7dGFibGVOb2RlS2V5fWApO1xuICB9XG4gIHJldHVybiB7XG4gICAgdGFibGVFbGVtZW50LFxuICAgIHRhYmxlTm9kZVxuICB9O1xufVxuY2xhc3MgVGFibGVPYnNlcnZlciB7XG4gIGNvbnN0cnVjdG9yKGVkaXRvciwgdGFibGVOb2RlS2V5KSB7XG4gICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gZmFsc2U7XG4gICAgdGhpcy5hbmNob3JYID0gLTE7XG4gICAgdGhpcy5hbmNob3JZID0gLTE7XG4gICAgdGhpcy5mb2N1c1ggPSAtMTtcbiAgICB0aGlzLmZvY3VzWSA9IC0xO1xuICAgIHRoaXMubGlzdGVuZXJzVG9SZW1vdmUgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy50YWJsZU5vZGVLZXkgPSB0YWJsZU5vZGVLZXk7XG4gICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgdGhpcy50YWJsZSA9IHtcbiAgICAgIGNvbHVtbnM6IDAsXG4gICAgICBkb21Sb3dzOiBbXSxcbiAgICAgIHJvd3M6IDBcbiAgICB9O1xuICAgIHRoaXMudGFibGVTZWxlY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkgPSBudWxsO1xuICAgIHRoaXMuZm9jdXNDZWxsTm9kZUtleSA9IG51bGw7XG4gICAgdGhpcy5hbmNob3JDZWxsID0gbnVsbDtcbiAgICB0aGlzLmZvY3VzQ2VsbCA9IG51bGw7XG4gICAgdGhpcy5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyA9IGZhbHNlO1xuICAgIHRoaXMuaXNTZWxlY3RpbmcgPSBmYWxzZTtcbiAgICB0aGlzLnBvaW50ZXJUeXBlID0gbnVsbDtcbiAgICB0aGlzLnNob3VsZENoZWNrU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgdGhpcy5saXN0ZW5lck9wdGlvbnMgPSB7XG4gICAgICBzaWduYWw6IHRoaXMuYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgIH07XG4gICAgdGhpcy5uZXh0Rm9jdXMgPSBudWxsO1xuICAgIHRoaXMudHJhY2tUYWJsZSgpO1xuICB9XG4gIGdldFRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlO1xuICB9XG4gIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICB0aGlzLmFib3J0Q29udHJvbGxlci5hYm9ydCgncmVtb3ZlTGlzdGVuZXJzJyk7XG4gICAgQXJyYXkuZnJvbSh0aGlzLmxpc3RlbmVyc1RvUmVtb3ZlKS5mb3JFYWNoKHJlbW92ZUxpc3RlbmVyID0+IHJlbW92ZUxpc3RlbmVyKCkpO1xuICAgIHRoaXMubGlzdGVuZXJzVG9SZW1vdmUuY2xlYXIoKTtcbiAgfVxuICAkbG9va3VwKCkge1xuICAgIHJldHVybiAkZ2V0VGFibGVBbmRFbGVtZW50QnlLZXkodGhpcy50YWJsZU5vZGVLZXksIHRoaXMuZWRpdG9yKTtcbiAgfVxuICB0cmFja1RhYmxlKCkge1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIocmVjb3JkcyA9PiB7XG4gICAgICB0aGlzLmVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoKCkgPT4ge1xuICAgICAgICBsZXQgZ3JpZE5lZWRzUmVkcmF3ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHJlY29yZCA9IHJlY29yZHNbaV07XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICBjb25zdCBub2RlTmFtZSA9IHRhcmdldC5ub2RlTmFtZTtcbiAgICAgICAgICBpZiAobm9kZU5hbWUgPT09ICdUQUJMRScgfHwgbm9kZU5hbWUgPT09ICdUQk9EWScgfHwgbm9kZU5hbWUgPT09ICdUSEVBRCcgfHwgbm9kZU5hbWUgPT09ICdUUicpIHtcbiAgICAgICAgICAgIGdyaWROZWVkc1JlZHJhdyA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFncmlkTmVlZHNSZWRyYXcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHRhYmxlTm9kZSxcbiAgICAgICAgICB0YWJsZUVsZW1lbnRcbiAgICAgICAgfSA9IHRoaXMuJGxvb2t1cCgpO1xuICAgICAgICB0aGlzLnRhYmxlID0gZ2V0VGFibGUodGFibGVOb2RlLCB0YWJsZUVsZW1lbnQpO1xuICAgICAgfSwge1xuICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLmVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICB0YWJsZU5vZGUsXG4gICAgICAgIHRhYmxlRWxlbWVudFxuICAgICAgfSA9IHRoaXMuJGxvb2t1cCgpO1xuICAgICAgdGhpcy50YWJsZSA9IGdldFRhYmxlKHRhYmxlTm9kZSwgdGFibGVFbGVtZW50KTtcbiAgICAgIG9ic2VydmVyLm9ic2VydmUodGFibGVFbGVtZW50LCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSwge1xuICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvclxuICAgIH0pO1xuICB9XG4gICRjbGVhckhpZ2hsaWdodCgpIHtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICB0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgPSBmYWxzZTtcbiAgICB0aGlzLmFuY2hvclggPSAtMTtcbiAgICB0aGlzLmFuY2hvclkgPSAtMTtcbiAgICB0aGlzLmZvY3VzWCA9IC0xO1xuICAgIHRoaXMuZm9jdXNZID0gLTE7XG4gICAgdGhpcy50YWJsZVNlbGVjdGlvbiA9IG51bGw7XG4gICAgdGhpcy5hbmNob3JDZWxsTm9kZUtleSA9IG51bGw7XG4gICAgdGhpcy5mb2N1c0NlbGxOb2RlS2V5ID0gbnVsbDtcbiAgICB0aGlzLmFuY2hvckNlbGwgPSBudWxsO1xuICAgIHRoaXMuZm9jdXNDZWxsID0gbnVsbDtcbiAgICB0aGlzLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzID0gZmFsc2U7XG4gICAgdGhpcy4kZW5hYmxlSGlnaGxpZ2h0U3R5bGUoKTtcbiAgICBjb25zdCB7XG4gICAgICB0YWJsZU5vZGUsXG4gICAgICB0YWJsZUVsZW1lbnRcbiAgICB9ID0gdGhpcy4kbG9va3VwKCk7XG4gICAgY29uc3QgZ3JpZCA9IGdldFRhYmxlKHRhYmxlTm9kZSwgdGFibGVFbGVtZW50KTtcbiAgICAkdXBkYXRlRE9NRm9yU2VsZWN0aW9uKGVkaXRvciwgZ3JpZCwgbnVsbCk7XG4gICAgaWYgKCRnZXRTZWxlY3Rpb24oKSAhPT0gbnVsbCkge1xuICAgICAgJHNldFNlbGVjdGlvbihudWxsKTtcbiAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgIH1cbiAgfVxuICAkZW5hYmxlSGlnaGxpZ2h0U3R5bGUoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgY29uc3Qge1xuICAgICAgdGFibGVFbGVtZW50XG4gICAgfSA9IHRoaXMuJGxvb2t1cCgpO1xuICAgIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudCh0YWJsZUVsZW1lbnQsIGVkaXRvci5fY29uZmlnLnRoZW1lLnRhYmxlU2VsZWN0aW9uKTtcbiAgICB0YWJsZUVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnZGlzYWJsZS1zZWxlY3Rpb24nKTtcbiAgICB0aGlzLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzID0gZmFsc2U7XG4gIH1cbiAgJGRpc2FibGVIaWdobGlnaHRTdHlsZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YWJsZUVsZW1lbnRcbiAgICB9ID0gdGhpcy4kbG9va3VwKCk7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCh0YWJsZUVsZW1lbnQsIHRoaXMuZWRpdG9yLl9jb25maWcudGhlbWUudGFibGVTZWxlY3Rpb24pO1xuICAgIHRoaXMuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgPSB0cnVlO1xuICB9XG4gICR1cGRhdGVUYWJsZVRhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICAgIGlmIChzZWxlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgIGlmICghKHNlbGVjdGlvbi50YWJsZUtleSA9PT0gdGhpcy50YWJsZU5vZGVLZXkpKSB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgVGFibGVPYnNlcnZlci4kdXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbjogc2VsZWN0aW9uLnRhYmxlS2V5ICE9PSB0aGlzLnRhYmxlTm9kZUtleSAoJyR7c2VsZWN0aW9uLnRhYmxlS2V5fScgIT09ICcke3RoaXMudGFibGVOb2RlS2V5fScpYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmVkaXRvcjtcbiAgICAgIHRoaXMudGFibGVTZWxlY3Rpb24gPSBzZWxlY3Rpb247XG4gICAgICB0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgPSB0cnVlO1xuICAgICAgdGhpcy4kZGlzYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICAgICB0aGlzLnVwZGF0ZURPTVNlbGVjdGlvbigpO1xuICAgICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRoaXMudGFibGUsIHRoaXMudGFibGVTZWxlY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiRjbGVhckhpZ2hsaWdodCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogRmlyZWZveCBoYXMgYSBzdHJhbmdlIGJlaGF2aW9yIHdoZXJlIHByZXNzaW5nIHRoZSBkb3duIGFycm93IGtleSBmcm9tXG4gICAqIGFib3ZlIHRoZSB0YWJsZSB3aWxsIG1vdmUgdGhlIGNhcmV0IGFmdGVyIHRoZSB0YWJsZSBhbmQgdGhlbiBsZXhpY2FsXG4gICAqIHdpbGwgc2VsZWN0IHRoZSBsYXN0IGNlbGwgaW5zdGVhZCBvZiB0aGUgZmlyc3QuXG4gICAqIFdlIGRvIHN0aWxsIHdhbnQgdG8gbGV0IHRoZSBicm93c2VyIGhhbmRsZSBjYXJldCBtb3ZlbWVudCBidXQgd2Ugd2lsbFxuICAgKiB1c2UgdGhpcyBwcm9wZXJ0eSB0byBcInRhZ1wiIHRoZSB1cGRhdGUgc28gdGhhdCB3ZSBjYW4gcmVjaGVjayB0aGVcbiAgICogc2VsZWN0aW9uIGFmdGVyIHRoZSBldmVudCBpcyBwcm9jZXNzZWQuXG4gICAqL1xuICBzZXRTaG91bGRDaGVja1NlbGVjdGlvbigpIHtcbiAgICB0aGlzLnNob3VsZENoZWNrU2VsZWN0aW9uID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRBbmRDbGVhclNob3VsZENoZWNrU2VsZWN0aW9uKCkge1xuICAgIGlmICh0aGlzLnNob3VsZENoZWNrU2VsZWN0aW9uKSB7XG4gICAgICB0aGlzLnNob3VsZENoZWNrU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBXaGVuIGhhbmRsaW5nIG1vdXNlbW92ZSBldmVudHMgd2UgdHJhY2sgd2hhdCB0aGUgZm9jdXMgY2VsbCBzaG91bGQgYmUsIGJ1dFxuICAgKiB0aGUgRE9NIHNlbGVjdGlvbiBtYXkgZW5kIHVwIHNvbWV3aGVyZSBlbHNlIGVudGlyZWx5LiBXZSBkb24ndCBoYXZlIGFuIGVsZWdhbnRcbiAgICogd2F5IHRvIGhhbmRsZSB0aGlzIGFmdGVyIHRoZSBET00gc2VsZWN0aW9uIGhhcyBiZWVuIHJlc29sdmVkIGluIGFcbiAgICogU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5EIGNhbGxiYWNrLlxuICAgKi9cbiAgc2V0TmV4dEZvY3VzKG5leHRGb2N1cykge1xuICAgIHRoaXMubmV4dEZvY3VzID0gbmV4dEZvY3VzO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXRBbmRDbGVhck5leHRGb2N1cygpIHtcbiAgICBjb25zdCB7XG4gICAgICBuZXh0Rm9jdXNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAobmV4dEZvY3VzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm5leHRGb2N1cyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBuZXh0Rm9jdXM7XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZURPTVNlbGVjdGlvbigpIHtcbiAgICBpZiAodGhpcy5hbmNob3JDZWxsICE9PSBudWxsICYmIHRoaXMuZm9jdXNDZWxsICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBkb21TZWxlY3Rpb24gPSBnZXRET01TZWxlY3Rpb24odGhpcy5lZGl0b3IuX3dpbmRvdyk7XG4gICAgICAvLyBXZSBhcmUgbm90IHVzaW5nIGEgbmF0aXZlIHNlbGVjdGlvbiBmb3IgdGFibGVzLCBhbmQgaWYgd2VcbiAgICAgIC8vIHNldCBvbmUgdGhlbiB0aGUgcmVjb25jaWxlciB3aWxsIHVuZG8gaXQuXG4gICAgICAvLyBUT0RPIC0gaXQgd291bGQgbWFrZSBzZW5zZSB0byBoYXZlIG9uZSBzbyB0aGF0IG5hdGl2ZVxuICAgICAgLy8gICAgICAgIGNvcHkvcGFzdGUgd29ya2VkLiBSaWdodCBub3cgd2UgaGF2ZSB0byBlbXVsYXRlIHdpdGhcbiAgICAgIC8vICAgICAgICBrZXlib2FyZCBldmVudHMgYnV0IGl0IHdvbid0IGZpcmUgaWYgdHJpZ2dlcmVkIGZyb20gdGhlIG1lbnVcbiAgICAgIGlmIChkb21TZWxlY3Rpb24gJiYgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgJHNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihjZWxsLCBpZ25vcmVTdGFydCA9IGZhbHNlKSB7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgY29uc3Qge1xuICAgICAgdGFibGVOb2RlXG4gICAgfSA9IHRoaXMuJGxvb2t1cCgpO1xuICAgIGNvbnN0IGNlbGxYID0gY2VsbC54O1xuICAgIGNvbnN0IGNlbGxZID0gY2VsbC55O1xuICAgIHRoaXMuZm9jdXNDZWxsID0gY2VsbDtcbiAgICBpZiAoIXRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyAmJiAodGhpcy5hbmNob3JYICE9PSBjZWxsWCB8fCB0aGlzLmFuY2hvclkgIT09IGNlbGxZIHx8IGlnbm9yZVN0YXJ0KSkge1xuICAgICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGRpc2FibGVIaWdobGlnaHRTdHlsZSgpO1xuICAgIH0gZWxzZSBpZiAoY2VsbFggPT09IHRoaXMuZm9jdXNYICYmIGNlbGxZID09PSB0aGlzLmZvY3VzWSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmZvY3VzWCA9IGNlbGxYO1xuICAgIHRoaXMuZm9jdXNZID0gY2VsbFk7XG4gICAgaWYgKHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscykge1xuICAgICAgY29uc3QgZm9jdXNUYWJsZUNlbGxOb2RlID0gJGdldE5lYXJlc3RUYWJsZUNlbGxJblRhYmxlRnJvbURPTU5vZGUodGFibGVOb2RlLCBjZWxsLmVsZW0pO1xuICAgICAgaWYgKHRoaXMudGFibGVTZWxlY3Rpb24gIT0gbnVsbCAmJiB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ICE9IG51bGwgJiYgZm9jdXNUYWJsZUNlbGxOb2RlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZm9jdXNDZWxsTm9kZUtleSA9IGZvY3VzVGFibGVDZWxsTm9kZS5nZXRLZXkoKTtcbiAgICAgICAgdGhpcy50YWJsZVNlbGVjdGlvbiA9ICRjcmVhdGVUYWJsZVNlbGVjdGlvbkZyb20odGFibGVOb2RlLCB0aGlzLiRnZXRBbmNob3JUYWJsZUNlbGxPclRocm93KCksIGZvY3VzVGFibGVDZWxsTm9kZSk7XG4gICAgICAgICRzZXRTZWxlY3Rpb24odGhpcy50YWJsZVNlbGVjdGlvbik7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgICAkdXBkYXRlRE9NRm9yU2VsZWN0aW9uKGVkaXRvciwgdGhpcy50YWJsZSwgdGhpcy50YWJsZVNlbGVjdGlvbik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgJGdldEFuY2hvclRhYmxlQ2VsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5hbmNob3JDZWxsTm9kZUtleSA/ICRnZXROb2RlQnlLZXkodGhpcy5hbmNob3JDZWxsTm9kZUtleSkgOiBudWxsO1xuICB9XG4gICRnZXRBbmNob3JUYWJsZUNlbGxPclRocm93KCkge1xuICAgIGNvbnN0IGFuY2hvclRhYmxlQ2VsbCA9IHRoaXMuJGdldEFuY2hvclRhYmxlQ2VsbCgpO1xuICAgIGlmICghKGFuY2hvclRhYmxlQ2VsbCAhPT0gbnVsbCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgVGFibGVPYnNlcnZlciBhbmNob3JUYWJsZUNlbGwgaXMgbnVsbGApO1xuICAgIH1cbiAgICByZXR1cm4gYW5jaG9yVGFibGVDZWxsO1xuICB9XG4gICRnZXRGb2N1c1RhYmxlQ2VsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5mb2N1c0NlbGxOb2RlS2V5ID8gJGdldE5vZGVCeUtleSh0aGlzLmZvY3VzQ2VsbE5vZGVLZXkpIDogbnVsbDtcbiAgfVxuICAkZ2V0Rm9jdXNUYWJsZUNlbGxPclRocm93KCkge1xuICAgIGNvbnN0IGZvY3VzVGFibGVDZWxsID0gdGhpcy4kZ2V0Rm9jdXNUYWJsZUNlbGwoKTtcbiAgICBpZiAoIShmb2N1c1RhYmxlQ2VsbCAhPT0gbnVsbCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgVGFibGVPYnNlcnZlciBmb2N1c1RhYmxlQ2VsbCBpcyBudWxsYCk7XG4gICAgfVxuICAgIHJldHVybiBmb2N1c1RhYmxlQ2VsbDtcbiAgfVxuICAkc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbihjZWxsKSB7XG4gICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gZmFsc2U7XG4gICAgdGhpcy5hbmNob3JDZWxsID0gY2VsbDtcbiAgICB0aGlzLmFuY2hvclggPSBjZWxsLng7XG4gICAgdGhpcy5hbmNob3JZID0gY2VsbC55O1xuICAgIGNvbnN0IHtcbiAgICAgIHRhYmxlTm9kZVxuICAgIH0gPSB0aGlzLiRsb29rdXAoKTtcbiAgICBjb25zdCBhbmNob3JUYWJsZUNlbGxOb2RlID0gJGdldE5lYXJlc3RUYWJsZUNlbGxJblRhYmxlRnJvbURPTU5vZGUodGFibGVOb2RlLCBjZWxsLmVsZW0pO1xuICAgIGlmIChhbmNob3JUYWJsZUNlbGxOb2RlICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBhbmNob3JOb2RlS2V5ID0gYW5jaG9yVGFibGVDZWxsTm9kZS5nZXRLZXkoKTtcbiAgICAgIHRoaXMudGFibGVTZWxlY3Rpb24gPSB0aGlzLnRhYmxlU2VsZWN0aW9uICE9IG51bGwgPyB0aGlzLnRhYmxlU2VsZWN0aW9uLmNsb25lKCkgOiAkY3JlYXRlVGFibGVTZWxlY3Rpb24oKTtcbiAgICAgIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkgPSBhbmNob3JOb2RlS2V5O1xuICAgIH1cbiAgfVxuICAkZm9ybWF0Q2VsbHModHlwZSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGUgc2VsZWN0aW9uYCk7XG4gICAgfVxuICAgIGNvbnN0IGZvcm1hdFNlbGVjdGlvbiA9ICRjcmVhdGVSYW5nZVNlbGVjdGlvbigpO1xuICAgIGNvbnN0IGFuY2hvciA9IGZvcm1hdFNlbGVjdGlvbi5hbmNob3I7XG4gICAgY29uc3QgZm9jdXMgPSBmb3JtYXRTZWxlY3Rpb24uZm9jdXM7XG4gICAgY29uc3QgY2VsbE5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCkuZmlsdGVyKCRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGlmICghKGNlbGxOb2Rlcy5sZW5ndGggPiAwKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBObyB0YWJsZSBjZWxscyBwcmVzZW50YCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFncmFwaCA9IGNlbGxOb2Rlc1swXS5nZXRGaXJzdENoaWxkKCk7XG4gICAgY29uc3QgYWxpZ25Gb3JtYXRXaXRoID0gJGlzUGFyYWdyYXBoTm9kZShwYXJhZ3JhcGgpID8gcGFyYWdyYXBoLmdldEZvcm1hdEZsYWdzKHR5cGUsIG51bGwpIDogbnVsbDtcbiAgICBjZWxsTm9kZXMuZm9yRWFjaChjZWxsTm9kZSA9PiB7XG4gICAgICBhbmNob3Iuc2V0KGNlbGxOb2RlLmdldEtleSgpLCAwLCAnZWxlbWVudCcpO1xuICAgICAgZm9jdXMuc2V0KGNlbGxOb2RlLmdldEtleSgpLCBjZWxsTm9kZS5nZXRDaGlsZHJlblNpemUoKSwgJ2VsZW1lbnQnKTtcbiAgICAgIGZvcm1hdFNlbGVjdGlvbi5mb3JtYXRUZXh0KHR5cGUsIGFsaWduRm9ybWF0V2l0aCk7XG4gICAgfSk7XG4gICAgJHNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIHRoaXMuZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gIH1cbiAgJGNsZWFyVGV4dCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBlZGl0b3JcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB0YWJsZU5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHRoaXMudGFibGVOb2RlS2V5KTtcbiAgICBpZiAoISRpc1RhYmxlTm9kZSh0YWJsZU5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIFRhYmxlTm9kZS4nKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZVNlbGVjdGlvbmApO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCkuZmlsdGVyKCRpc1RhYmxlQ2VsbE5vZGUpO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGVudGlyZSB0YWJsZSBpcyBzZWxlY3RlZCBieSB2ZXJpZnlpbmcgZmlyc3QgYW5kIGxhc3QgY2VsbHNcbiAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlTm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgY29uc3QgbGFzdFJvdyA9IHRhYmxlTm9kZS5nZXRMYXN0Q2hpbGQoKTtcbiAgICBjb25zdCBpc0VudGlyZVRhYmxlU2VsZWN0ZWQgPSBzZWxlY3RlZE5vZGVzLmxlbmd0aCA+IDAgJiYgZmlyc3RSb3cgIT09IG51bGwgJiYgbGFzdFJvdyAhPT0gbnVsbCAmJiAkaXNUYWJsZVJvd05vZGUoZmlyc3RSb3cpICYmICRpc1RhYmxlUm93Tm9kZShsYXN0Um93KSAmJiBzZWxlY3RlZE5vZGVzWzBdID09PSBmaXJzdFJvdy5nZXRGaXJzdENoaWxkKCkgJiYgc2VsZWN0ZWROb2Rlc1tzZWxlY3RlZE5vZGVzLmxlbmd0aCAtIDFdID09PSBsYXN0Um93LmdldExhc3RDaGlsZCgpO1xuICAgIGlmIChpc0VudGlyZVRhYmxlU2VsZWN0ZWQpIHtcbiAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgY29uc3QgcGFyZW50ID0gdGFibGVOb2RlLmdldFBhcmVudCgpO1xuICAgICAgLy8gRGVsZXRlIGVudGlyZSB0YWJsZVxuICAgICAgdGFibGVOb2RlLnJlbW92ZSgpO1xuICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0YWJsZSB3YXMgdGhlIG9ubHkgbm9kZVxuICAgICAgaWYgKCRpc1Jvb3ROb2RlKHBhcmVudCkgJiYgcGFyZW50LmlzRW1wdHkoKSkge1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2VsZWN0ZWROb2Rlcy5mb3JFYWNoKGNlbGxOb2RlID0+IHtcbiAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjZWxsTm9kZSkpIHtcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKCk7XG4gICAgICAgIHBhcmFncmFwaE5vZGUuYXBwZW5kKHRleHROb2RlKTtcbiAgICAgICAgY2VsbE5vZGUuYXBwZW5kKHBhcmFncmFwaE5vZGUpO1xuICAgICAgICBjZWxsTm9kZS5nZXRDaGlsZHJlbigpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgIGlmIChjaGlsZCAhPT0gcGFyYWdyYXBoTm9kZSkge1xuICAgICAgICAgICAgY2hpbGQucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAkdXBkYXRlRE9NRm9yU2VsZWN0aW9uKGVkaXRvciwgdGhpcy50YWJsZSwgbnVsbCk7XG4gICAgJHNldFNlbGVjdGlvbihudWxsKTtcbiAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgfVxufVxuXG5jb25zdCBMRVhJQ0FMX0VMRU1FTlRfS0VZID0gJ19fbGV4aWNhbFRhYmxlU2VsZWN0aW9uJztcbmNvbnN0IGlzUG9pbnRlckRvd25PbkV2ZW50ID0gZXZlbnQgPT4ge1xuICByZXR1cm4gKGV2ZW50LmJ1dHRvbnMgJiAxKSA9PT0gMTtcbn07XG5mdW5jdGlvbiBpc0hUTUxUYWJsZUVsZW1lbnQoZWwpIHtcbiAgcmV0dXJuIGlzSFRNTEVsZW1lbnQoZWwpICYmIGVsLm5vZGVOYW1lID09PSAnVEFCTEUnO1xufVxuZnVuY3Rpb24gZ2V0VGFibGVFbGVtZW50KHRhYmxlTm9kZSwgZG9tKSB7XG4gIGlmICghZG9tKSB7XG4gICAgcmV0dXJuIGRvbTtcbiAgfVxuICBjb25zdCBlbGVtZW50ID0gaXNIVE1MVGFibGVFbGVtZW50KGRvbSkgPyBkb20gOiB0YWJsZU5vZGUuZ2V0RE9NU2xvdChkb20pLmVsZW1lbnQ7XG4gIGlmICghKGVsZW1lbnQubm9kZU5hbWUgPT09ICdUQUJMRScpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBnZXRUYWJsZUVsZW1lbnQ6IEV4cGVjdGluZyB0YWJsZSBpbiBhcyBET00gbm9kZSBmb3IgVGFibGVOb2RlLCBub3QgJHtkb20ubm9kZU5hbWV9YCk7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiBnZXRFZGl0b3JXaW5kb3coZWRpdG9yKSB7XG4gIHJldHVybiBlZGl0b3IuX3dpbmRvdztcbn1cbmZ1bmN0aW9uICRmaW5kUGFyZW50VGFibGVDZWxsTm9kZUluVGFibGUodGFibGVOb2RlLCBub2RlKSB7XG4gIGZvciAobGV0IGN1cnJlbnROb2RlID0gbm9kZSwgbGFzdFRhYmxlQ2VsbE5vZGUgPSBudWxsOyBjdXJyZW50Tm9kZSAhPT0gbnVsbDsgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnQoKSkge1xuICAgIGlmICh0YWJsZU5vZGUuaXMoY3VycmVudE5vZGUpKSB7XG4gICAgICByZXR1cm4gbGFzdFRhYmxlQ2VsbE5vZGU7XG4gICAgfSBlbHNlIGlmICgkaXNUYWJsZUNlbGxOb2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgbGFzdFRhYmxlQ2VsbE5vZGUgPSBjdXJyZW50Tm9kZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBBUlJPV19LRVlfQ09NTUFORFNfV0lUSF9ESVJFQ1RJT04gPSBbW0tFWV9BUlJPV19ET1dOX0NPTU1BTkQsICdkb3duJ10sIFtLRVlfQVJST1dfVVBfQ09NTUFORCwgJ3VwJ10sIFtLRVlfQVJST1dfTEVGVF9DT01NQU5ELCAnYmFja3dhcmQnXSwgW0tFWV9BUlJPV19SSUdIVF9DT01NQU5ELCAnZm9yd2FyZCddXTtcbmNvbnN0IERFTEVURV9URVhUX0NPTU1BTkRTID0gW0RFTEVURV9XT1JEX0NPTU1BTkQsIERFTEVURV9MSU5FX0NPTU1BTkQsIERFTEVURV9DSEFSQUNURVJfQ09NTUFORF07XG5jb25zdCBERUxFVEVfS0VZX0NPTU1BTkRTID0gW0tFWV9CQUNLU1BBQ0VfQ09NTUFORCwgS0VZX0RFTEVURV9DT01NQU5EXTtcbmZ1bmN0aW9uIGFwcGx5VGFibGVIYW5kbGVycyh0YWJsZU5vZGUsIGVsZW1lbnQsIGVkaXRvciwgaGFzVGFiSGFuZGxlcikge1xuICBjb25zdCByb290RWxlbWVudCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICBjb25zdCBlZGl0b3JXaW5kb3cgPSBnZXRFZGl0b3JXaW5kb3coZWRpdG9yKTtcbiAgaWYgKCEocm9vdEVsZW1lbnQgIT09IG51bGwgJiYgZWRpdG9yV2luZG93ICE9PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgYXBwbHlUYWJsZUhhbmRsZXJzOiBlZGl0b3IgaGFzIG5vIHJvb3QgZWxlbWVudCBzZXRgKTtcbiAgfVxuICBjb25zdCB0YWJsZU9ic2VydmVyID0gbmV3IFRhYmxlT2JzZXJ2ZXIoZWRpdG9yLCB0YWJsZU5vZGUuZ2V0S2V5KCkpO1xuICBjb25zdCB0YWJsZUVsZW1lbnQgPSBnZXRUYWJsZUVsZW1lbnQodGFibGVOb2RlLCBlbGVtZW50KTtcbiAgYXR0YWNoVGFibGVPYnNlcnZlclRvVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgdGFibGVPYnNlcnZlcik7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKCgpID0+IGRldGFjaFRhYmxlT2JzZXJ2ZXJGcm9tVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgdGFibGVPYnNlcnZlcikpO1xuICBjb25zdCBjcmVhdGVQb2ludGVySGFuZGxlcnMgPSAoKSA9PiB7XG4gICAgaWYgKHRhYmxlT2JzZXJ2ZXIuaXNTZWxlY3RpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb25Qb2ludGVyVXAgPSAoKSA9PiB7XG4gICAgICB0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nID0gZmFsc2U7XG4gICAgICBlZGl0b3JXaW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgb25Qb2ludGVyVXApO1xuICAgICAgZWRpdG9yV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgfTtcbiAgICBjb25zdCBvblBvaW50ZXJNb3ZlID0gbW92ZUV2ZW50ID0+IHtcbiAgICAgIGlmICghaXNQb2ludGVyRG93bk9uRXZlbnQobW92ZUV2ZW50KSAmJiB0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nKSB7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIuaXNTZWxlY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgZWRpdG9yV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIG9uUG9pbnRlclVwKTtcbiAgICAgICAgZWRpdG9yV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNET01Ob2RlKG1vdmVFdmVudC50YXJnZXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBmb2N1c0NlbGwgPSBudWxsO1xuICAgICAgLy8gSW4gZmlyZWZveCB0aGUgbW92ZUV2ZW50LnRhcmdldCBtYXkgYmUgY2FwdHVyZWQgc28gd2UgbXVzdCBhbHdheXNcbiAgICAgIC8vIGNvbnN1bHQgdGhlIGNvb3JkaW5hdGVzICM3MjQ1XG4gICAgICBjb25zdCBvdmVycmlkZSA9ICEoSVNfRklSRUZPWCB8fCB0YWJsZUVsZW1lbnQuY29udGFpbnMobW92ZUV2ZW50LnRhcmdldCkpO1xuICAgICAgaWYgKG92ZXJyaWRlKSB7XG4gICAgICAgIGZvY3VzQ2VsbCA9IGdldERPTUNlbGxJblRhYmxlRnJvbVRhcmdldCh0YWJsZUVsZW1lbnQsIG1vdmVFdmVudC50YXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBlbCBvZiBkb2N1bWVudC5lbGVtZW50c0Zyb21Qb2ludChtb3ZlRXZlbnQuY2xpZW50WCwgbW92ZUV2ZW50LmNsaWVudFkpKSB7XG4gICAgICAgICAgZm9jdXNDZWxsID0gZ2V0RE9NQ2VsbEluVGFibGVGcm9tVGFyZ2V0KHRhYmxlRWxlbWVudCwgZWwpO1xuICAgICAgICAgIGlmIChmb2N1c0NlbGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvY3VzQ2VsbCAmJiAodGFibGVPYnNlcnZlci5mb2N1c0NlbGwgPT09IG51bGwgfHwgZm9jdXNDZWxsLmVsZW0gIT09IHRhYmxlT2JzZXJ2ZXIuZm9jdXNDZWxsLmVsZW0pKSB7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIuc2V0TmV4dEZvY3VzKHtcbiAgICAgICAgICBmb2N1c0NlbGwsXG4gICAgICAgICAgb3ZlcnJpZGVcbiAgICAgICAgfSk7XG4gICAgICAgIGVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZyA9IHRydWU7XG4gICAgZWRpdG9yV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIG9uUG9pbnRlclVwLCB0YWJsZU9ic2VydmVyLmxpc3RlbmVyT3B0aW9ucyk7XG4gICAgZWRpdG9yV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSwgdGFibGVPYnNlcnZlci5saXN0ZW5lck9wdGlvbnMpO1xuICB9O1xuICBjb25zdCBvblBvaW50ZXJEb3duID0gZXZlbnQgPT4ge1xuICAgIHRhYmxlT2JzZXJ2ZXIucG9pbnRlclR5cGUgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8ICFpc0RPTU5vZGUoZXZlbnQudGFyZ2V0KSB8fCAhZWRpdG9yV2luZG93KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldENlbGwgPSBnZXRET01DZWxsRnJvbVRhcmdldChldmVudC50YXJnZXQpO1xuICAgIGlmICh0YXJnZXRDZWxsICE9PSBudWxsKSB7XG4gICAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgICAgY29uc3QgcHJldlNlbGVjdGlvbiA9ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICAgICAgICAvLyBXZSBjYW4ndCB0cnVzdCBGaXJlZm94IHRvIGRvIHRoZSByaWdodCB0aGluZyB3aXRoIHRoZSBzZWxlY3Rpb24gYW5kXG4gICAgICAgIC8vIHdlIGRvbid0IGhhdmUgYSBwcm9wZXIgc3RhdGUgbWFjaGluZSB0byBkbyB0aGlzIFwiY29ycmVjdGx5XCIgYnV0XG4gICAgICAgIC8vIGlmIHdlIGdvIGFoZWFkIGFuZCBtYWtlIHRoZSB0YWJsZSBzZWxlY3Rpb24gbm93IGl0IHdpbGwgd29ya1xuICAgICAgICBpZiAoSVNfRklSRUZPWCAmJiBldmVudC5zaGlmdEtleSAmJiAkaXNTZWxlY3Rpb25JblRhYmxlKHByZXZTZWxlY3Rpb24sIHRhYmxlTm9kZSkgJiYgKCRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pKSkge1xuICAgICAgICAgIGNvbnN0IHByZXZBbmNob3JOb2RlID0gcHJldlNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgICAgIGNvbnN0IHByZXZBbmNob3JDZWxsID0gJGZpbmRQYXJlbnRUYWJsZUNlbGxOb2RlSW5UYWJsZSh0YWJsZU5vZGUsIHByZXZTZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSk7XG4gICAgICAgICAgaWYgKHByZXZBbmNob3JDZWxsKSB7XG4gICAgICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKCRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIHByZXZBbmNob3JDZWxsKSk7XG4gICAgICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24odGFyZ2V0Q2VsbCk7XG4gICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSB0YWJsZU5vZGUuaXNCZWZvcmUocHJldkFuY2hvck5vZGUpID8gdGFibGVOb2RlLnNlbGVjdFN0YXJ0KCkgOiB0YWJsZU5vZGUuc2VsZWN0RW5kKCk7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb24uYW5jaG9yLnNldChwcmV2U2VsZWN0aW9uLmFuY2hvci5rZXksIHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldCwgcHJldlNlbGVjdGlvbi5hbmNob3IudHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE9ubHkgc2V0IGFuY2hvciBjZWxsIGZvciBzZWxlY3Rpb24gaWYgdGhpcyBpcyBub3QgYSBzaW1wbGUgdG91Y2ggdGFwXG4gICAgICAgICAgLy8gVG91Y2ggdGFwcyBzaG91bGQgbm90IGluaXRpYXRlIHRhYmxlIHNlbGVjdGlvbiBtb2RlXG4gICAgICAgICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKHRhcmdldENlbGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVBvaW50ZXJIYW5kbGVycygpO1xuICB9O1xuICB0YWJsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBvblBvaW50ZXJEb3duLCB0YWJsZU9ic2VydmVyLmxpc3RlbmVyT3B0aW9ucyk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKCgpID0+IHtcbiAgICB0YWJsZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBvblBvaW50ZXJEb3duKTtcbiAgfSk7XG4gIGNvbnN0IG9uVHJpcGxlQ2xpY2sgPSBldmVudCA9PiB7XG4gICAgaWYgKGV2ZW50LmRldGFpbCA+PSAzICYmIGlzRE9NTm9kZShldmVudC50YXJnZXQpKSB7XG4gICAgICBjb25zdCB0YXJnZXRDZWxsID0gZ2V0RE9NQ2VsbEZyb21UYXJnZXQoZXZlbnQudGFyZ2V0KTtcbiAgICAgIGlmICh0YXJnZXRDZWxsICE9PSBudWxsKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICB0YWJsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgb25UcmlwbGVDbGljaywgdGFibGVPYnNlcnZlci5saXN0ZW5lck9wdGlvbnMpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZCgoKSA9PiB7XG4gICAgdGFibGVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uVHJpcGxlQ2xpY2spO1xuICB9KTtcblxuICAvLyBDbGVhciBzZWxlY3Rpb24gd2hlbiBjbGlja2luZyBvdXRzaWRlIG9mIGRvbS5cbiAgY29uc3QgcG9pbnRlckRvd25DYWxsYmFjayA9IGV2ZW50ID0+IHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCAhaXNET01Ob2RlKHRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24udGFibGVLZXkgPT09IHRhYmxlT2JzZXJ2ZXIudGFibGVOb2RlS2V5ICYmIHJvb3RFbGVtZW50LmNvbnRhaW5zKHRhcmdldCkpIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci4kY2xlYXJIaWdobGlnaHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgZWRpdG9yV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgcG9pbnRlckRvd25DYWxsYmFjaywgdGFibGVPYnNlcnZlci5saXN0ZW5lck9wdGlvbnMpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZCgoKSA9PiB7XG4gICAgZWRpdG9yV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgcG9pbnRlckRvd25DYWxsYmFjayk7XG4gIH0pO1xuICBmb3IgKGNvbnN0IFtjb21tYW5kLCBkaXJlY3Rpb25dIG9mIEFSUk9XX0tFWV9DT01NQU5EU19XSVRIX0RJUkVDVElPTikge1xuICAgIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoY29tbWFuZCwgZXZlbnQgPT4gJGhhbmRsZUFycm93S2V5KGVkaXRvciwgZXZlbnQsIGRpcmVjdGlvbiwgdGFibGVOb2RlLCB0YWJsZU9ic2VydmVyKSwgQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIH1cbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfRVNDQVBFX0NPTU1BTkQsIGV2ZW50ID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSAkZmluZFBhcmVudFRhYmxlQ2VsbE5vZGVJblRhYmxlKHRhYmxlTm9kZSwgc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKSk7XG4gICAgICBpZiAoZm9jdXNDZWxsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBmb2N1c0NlbGxOb2RlLnNlbGVjdEVuZCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgY29uc3QgZGVsZXRlVGV4dEhhbmRsZXIgPSBjb21tYW5kID0+ICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgdGFibGVPYnNlcnZlci4kY2xlYXJUZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IHRhYmxlQ2VsbE5vZGUgPSAkZmluZFBhcmVudFRhYmxlQ2VsbE5vZGVJblRhYmxlKHRhYmxlTm9kZSwgc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgICBjb25zdCBpc0FuY2hvckluc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKGFuY2hvck5vZGUpO1xuICAgICAgY29uc3QgaXNGb2N1c0luc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKGZvY3VzTm9kZSk7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Db250YWluc1BhcnRpYWxUYWJsZSA9IGlzQW5jaG9ySW5zaWRlICYmICFpc0ZvY3VzSW5zaWRlIHx8IGlzRm9jdXNJbnNpZGUgJiYgIWlzQW5jaG9ySW5zaWRlO1xuICAgICAgaWYgKHNlbGVjdGlvbkNvbnRhaW5zUGFydGlhbFRhYmxlKSB7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIuJGNsZWFyVGV4dCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5lYXJlc3RFbGVtZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzRWxlbWVudE5vZGUobikpO1xuICAgICAgY29uc3QgdG9wTGV2ZWxDZWxsRWxlbWVudE5vZGUgPSBuZWFyZXN0RWxlbWVudE5vZGUgJiYgJGZpbmRNYXRjaGluZ1BhcmVudChuZWFyZXN0RWxlbWVudE5vZGUsIG4gPT4gJGlzRWxlbWVudE5vZGUobikgJiYgJGlzVGFibGVDZWxsTm9kZShuLmdldFBhcmVudCgpKSk7XG4gICAgICBpZiAoISRpc0VsZW1lbnROb2RlKHRvcExldmVsQ2VsbEVsZW1lbnROb2RlKSB8fCAhJGlzRWxlbWVudE5vZGUobmVhcmVzdEVsZW1lbnROb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoY29tbWFuZCA9PT0gREVMRVRFX0xJTkVfQ09NTUFORCAmJiB0b3BMZXZlbENlbGxFbGVtZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBGaXggRGVsZXRlIExpbmUgaW4gVGFibGUgQ2VsbHMuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGZvciAoY29uc3QgY29tbWFuZCBvZiBERUxFVEVfVEVYVF9DT01NQU5EUykge1xuICAgIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoY29tbWFuZCwgZGVsZXRlVGV4dEhhbmRsZXIoY29tbWFuZCksIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgfVxuICBjb25zdCAkZGVsZXRlQ2VsbEhhbmRsZXIgPSBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGlzIGluc2lkZSB0aGUgdGFibGUgYnV0IHNob3VsZCByZW1vdmUgdGhlIHdob2xlIHRhYmxlXG4gICAgLy8gd2UgZXhwYW5kIHRoZSBzZWxlY3Rpb24gc28gdGhhdCBib3RoIHRoZSBhbmNob3IgYW5kIGZvY3VzIGFyZSBvdXRzaWRlXG4gICAgLy8gdGhlIHRhYmxlIGFuZCB0aGUgZWRpdG9yJ3MgY29tbWFuZCBsaXN0ZW5lciB3aWxsIGhhbmRsZSB0aGUgZGVsZXRlXG4gICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSk7XG4gICAgY29uc3QgaXNGb2N1c0luc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCkpO1xuICAgIGlmIChpc0FuY2hvckluc2lkZSAhPT0gaXNGb2N1c0luc2lkZSkge1xuICAgICAgY29uc3QgdGFibGVQb2ludCA9IGlzQW5jaG9ySW5zaWRlID8gJ2FuY2hvcicgOiAnZm9jdXMnO1xuICAgICAgY29uc3Qgb3V0ZXJQb2ludCA9IGlzQW5jaG9ySW5zaWRlID8gJ2ZvY3VzJyA6ICdhbmNob3InO1xuICAgICAgLy8gUHJlc2VydmUgdGhlIG91dGVyIHBvaW50XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtleSxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICB0eXBlXG4gICAgICB9ID0gc2VsZWN0aW9uW291dGVyUG9pbnRdO1xuICAgICAgLy8gRXhwYW5kIHRoZSBzZWxlY3Rpb24gYXJvdW5kIHRoZSB0YWJsZVxuICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gdGFibGVOb2RlW3NlbGVjdGlvblt0YWJsZVBvaW50XS5pc0JlZm9yZShzZWxlY3Rpb25bb3V0ZXJQb2ludF0pID8gJ3NlbGVjdFByZXZpb3VzJyA6ICdzZWxlY3ROZXh0J10oKTtcbiAgICAgIC8vIFJlc3RvcmUgdGhlIG91dGVyIHBvaW50IG9mIHRoZSBzZWxlY3Rpb25cbiAgICAgIG5ld1NlbGVjdGlvbltvdXRlclBvaW50XS5zZXQoa2V5LCBvZmZzZXQsIHR5cGUpO1xuICAgICAgLy8gTGV0IHRoZSBiYXNlIGltcGxlbWVudGF0aW9uIGhhbmRsZSB0aGUgcmVzdFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgICB0YWJsZU9ic2VydmVyLiRjbGVhclRleHQoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG4gIGZvciAoY29uc3QgY29tbWFuZCBvZiBERUxFVEVfS0VZX0NPTU1BTkRTKSB7XG4gICAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChjb21tYW5kLCAkZGVsZXRlQ2VsbEhhbmRsZXIsIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgfVxuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENVVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgIGlmICghKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQ29weWluZyB0byB0aGUgY2xpcGJvYXJkIGlzIGFzeW5jIHNvIHdlIG11c3QgY2FwdHVyZSB0aGUgZGF0YVxuICAgICAgLy8gYmVmb3JlIHdlIGRlbGV0ZSBpdFxuICAgICAgdm9pZCBjb3B5VG9DbGlwYm9hcmQoZWRpdG9yLCBvYmplY3RLbGFzc0VxdWFscyhldmVudCwgQ2xpcGJvYXJkRXZlbnQpID8gZXZlbnQgOiBudWxsLCAkZ2V0Q2xpcGJvYXJkRGF0YUZyb21TZWxlY3Rpb24oc2VsZWN0aW9uKSk7XG4gICAgICBjb25zdCBpbnRlcmNlcHRlZCA9ICRkZWxldGVDZWxsSGFuZGxlcihldmVudCk7XG4gICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlVGV4dCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnRlcmNlcHRlZDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoRk9STUFUX1RFWFRfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHRhYmxlT2JzZXJ2ZXIuJGZvcm1hdENlbGxzKHBheWxvYWQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEZPUk1BVF9FTEVNRU5UX0NPTU1BTkQsIGZvcm1hdFR5cGUgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShhbmNob3JOb2RlKSB8fCAhJGlzVGFibGVDZWxsTm9kZShmb2N1c05vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gQWxpZ24gdGhlIHRhYmxlIGlmIHRoZSBlbnRpcmUgdGFibGUgaXMgc2VsZWN0ZWRcbiAgICBpZiAoJGlzRnVsbFRhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgdGFibGVOb2RlLnNldEZvcm1hdChmb3JtYXRUeXBlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBbdGFibGVNYXAsIGFuY2hvckNlbGwsIGZvY3VzQ2VsbF0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgYW5jaG9yTm9kZSwgZm9jdXNOb2RlKTtcbiAgICBjb25zdCBtYXhSb3cgPSBNYXRoLm1heChhbmNob3JDZWxsLnN0YXJ0Um93ICsgYW5jaG9yQ2VsbC5jZWxsLl9fcm93U3BhbiAtIDEsIGZvY3VzQ2VsbC5zdGFydFJvdyArIGZvY3VzQ2VsbC5jZWxsLl9fcm93U3BhbiAtIDEpO1xuICAgIGNvbnN0IG1heENvbHVtbiA9IE1hdGgubWF4KGFuY2hvckNlbGwuc3RhcnRDb2x1bW4gKyBhbmNob3JDZWxsLmNlbGwuX19jb2xTcGFuIC0gMSwgZm9jdXNDZWxsLnN0YXJ0Q29sdW1uICsgZm9jdXNDZWxsLmNlbGwuX19jb2xTcGFuIC0gMSk7XG4gICAgY29uc3QgbWluUm93ID0gTWF0aC5taW4oYW5jaG9yQ2VsbC5zdGFydFJvdywgZm9jdXNDZWxsLnN0YXJ0Um93KTtcbiAgICBjb25zdCBtaW5Db2x1bW4gPSBNYXRoLm1pbihhbmNob3JDZWxsLnN0YXJ0Q29sdW1uLCBmb2N1c0NlbGwuc3RhcnRDb2x1bW4pO1xuICAgIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IG1pblJvdzsgaSA8PSBtYXhSb3c7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IG1pbkNvbHVtbjsgaiA8PSBtYXhDb2x1bW47IGorKykge1xuICAgICAgICBjb25zdCBjZWxsID0gdGFibGVNYXBbaV1bal0uY2VsbDtcbiAgICAgICAgaWYgKHZpc2l0ZWQuaGFzKGNlbGwpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZC5hZGQoY2VsbCk7XG4gICAgICAgIGNlbGwuc2V0Rm9ybWF0KGZvcm1hdFR5cGUpO1xuICAgICAgICBjb25zdCBjZWxsQ2hpbGRyZW4gPSBjZWxsLmdldENoaWxkcmVuKCk7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgY2VsbENoaWxkcmVuLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBjZWxsQ2hpbGRyZW5ba107XG4gICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSAmJiAhY2hpbGQuaXNJbmxpbmUoKSkge1xuICAgICAgICAgICAgY2hpbGQuc2V0Rm9ybWF0KGZvcm1hdFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKENPTlRST0xMRURfVEVYVF9JTlNFUlRJT05fQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHRhYmxlT2JzZXJ2ZXIuJGNsZWFySGlnaGxpZ2h0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IGVkZ2VQb3NpdGlvbiA9ICRnZXRUYWJsZUVkZ2VDdXJzb3JQb3NpdGlvbihlZGl0b3IsIHNlbGVjdGlvbiwgdGFibGVOb2RlKTtcbiAgICAgICAgaWYgKGVkZ2VQb3NpdGlvbikge1xuICAgICAgICAgICRpbnNlcnRQYXJhZ3JhcGhBdFRhYmxlRWRnZShlZGdlUG9zaXRpb24sIHRhYmxlTm9kZSwgWyRjcmVhdGVUZXh0Tm9kZShwYXlsb2FkKV0pO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICBpZiAoaGFzVGFiSGFuZGxlcikge1xuICAgIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX1RBQl9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpIHx8ICEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGZpbmRDZWxsTm9kZShzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSk7XG4gICAgICBpZiAodGFibGVDZWxsTm9kZSA9PT0gbnVsbCB8fCAhdGFibGVOb2RlLmlzKCRmaW5kVGFibGVOb2RlKHRhYmxlQ2VsbE5vZGUpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgJHNlbGVjdEFkamFjZW50Q2VsbCh0YWJsZUNlbGxOb2RlLCBldmVudC5zaGlmdEtleSA/ICdwcmV2aW91cycgOiAnbmV4dCcpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB9XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoRk9DVVNfQ09NTUFORCwgcGF5bG9hZCA9PiB7XG4gICAgcmV0dXJuIHRhYmxlTm9kZS5pc1NlbGVjdGVkKCk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfSElHSCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFNFTEVDVElPTl9JTlNFUlRfQ0xJUEJPQVJEX05PREVTX0NPTU1BTkQsIChzZWxlY3Rpb25QYXlsb2FkLCBkaXNwYXRjaEVkaXRvcikgPT4ge1xuICAgIGlmIChlZGl0b3IgIT09IGRpc3BhdGNoRWRpdG9yKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIG5vZGVzLFxuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IHNlbGVjdGlvblBheWxvYWQ7XG4gICAgY29uc3QgYW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbmRQb2ludHMoKTtcbiAgICBjb25zdCBpc1RhYmxlU2VsZWN0aW9uID0gJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBjb25zdCBpc1JhbmdlU2VsZWN0aW9uID0gJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBjb25zdCBpc1NlbGVjdGlvbkluc2lkZU9mR3JpZCA9IGlzUmFuZ2VTZWxlY3Rpb24gJiYgJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKSAhPT0gbnVsbCAmJiAkZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSkgIT09IG51bGwgfHwgaXNUYWJsZVNlbGVjdGlvbjtcbiAgICBpZiAobm9kZXMubGVuZ3RoICE9PSAxIHx8ICEkaXNUYWJsZU5vZGUobm9kZXNbMF0pIHx8ICFpc1NlbGVjdGlvbkluc2lkZU9mR3JpZCB8fCBhbmNob3JBbmRGb2N1cyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBbYW5jaG9yLCBmb2N1c10gPSBhbmNob3JBbmRGb2N1cztcbiAgICBjb25zdCBbYW5jaG9yQ2VsbE5vZGUsIGFuY2hvclJvd05vZGUsIGdyaWROb2RlXSA9ICRnZXROb2RlVHJpcGxldChhbmNob3IpO1xuICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcbiAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoYW5jaG9yQ2VsbE5vZGUpIHx8ICEkaXNUYWJsZUNlbGxOb2RlKGZvY3VzQ2VsbE5vZGUpIHx8ICEkaXNUYWJsZVJvd05vZGUoYW5jaG9yUm93Tm9kZSkgfHwgISRpc1RhYmxlTm9kZShncmlkTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgdGVtcGxhdGVHcmlkID0gbm9kZXNbMF07XG4gICAgY29uc3QgW2luaXRpYWxHcmlkTWFwLCBhbmNob3JDZWxsTWFwLCBmb2N1c0NlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkTm9kZSwgYW5jaG9yQ2VsbE5vZGUsIGZvY3VzQ2VsbE5vZGUpO1xuICAgIGNvbnN0IFt0ZW1wbGF0ZUdyaWRNYXBdID0gJGNvbXB1dGVUYWJsZU1hcFNraXBDZWxsQ2hlY2sodGVtcGxhdGVHcmlkLCBudWxsLCBudWxsKTtcbiAgICBjb25zdCBpbml0aWFsUm93Q291bnQgPSBpbml0aWFsR3JpZE1hcC5sZW5ndGg7XG4gICAgY29uc3QgaW5pdGlhbENvbENvdW50ID0gaW5pdGlhbFJvd0NvdW50ID4gMCA/IGluaXRpYWxHcmlkTWFwWzBdLmxlbmd0aCA6IDA7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGEgcmFuZ2Ugc2VsZWN0aW9uLCB3ZSdsbCBmaXQgdGhlIHRlbXBsYXRlIGdyaWQgaW50byB0aGVcbiAgICAvLyB0YWJsZSwgZ3Jvd2luZyB0aGUgdGFibGUgaWYgbmVjZXNzYXJ5LlxuICAgIGxldCBzdGFydFJvdyA9IGFuY2hvckNlbGxNYXAuc3RhcnRSb3c7XG4gICAgbGV0IHN0YXJ0Q29sID0gYW5jaG9yQ2VsbE1hcC5zdGFydENvbHVtbjtcbiAgICBsZXQgYWZmZWN0ZWRSb3dDb3VudCA9IHRlbXBsYXRlR3JpZE1hcC5sZW5ndGg7XG4gICAgbGV0IGFmZmVjdGVkQ29sQ291bnQgPSBhZmZlY3RlZFJvd0NvdW50ID4gMCA/IHRlbXBsYXRlR3JpZE1hcFswXS5sZW5ndGggOiAwO1xuICAgIGlmIChpc1RhYmxlU2VsZWN0aW9uKSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgdGFibGUgc2VsZWN0aW9uLCB3ZSdsbCBvbmx5IG1vZGlmeSB0aGUgY2VsbHMgd2l0aGluXG4gICAgICAvLyB0aGUgc2VsZWN0aW9uIGJvdW5kYXJ5LlxuICAgICAgY29uc3Qgc2VsZWN0aW9uQm91bmRhcnkgPSAkY29tcHV0ZVRhYmxlQ2VsbFJlY3RCb3VuZGFyeShpbml0aWFsR3JpZE1hcCwgYW5jaG9yQ2VsbE1hcCwgZm9jdXNDZWxsTWFwKTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvblJvd0NvdW50ID0gc2VsZWN0aW9uQm91bmRhcnkubWF4Um93IC0gc2VsZWN0aW9uQm91bmRhcnkubWluUm93ICsgMTtcbiAgICAgIGNvbnN0IHNlbGVjdGlvbkNvbENvdW50ID0gc2VsZWN0aW9uQm91bmRhcnkubWF4Q29sdW1uIC0gc2VsZWN0aW9uQm91bmRhcnkubWluQ29sdW1uICsgMTtcbiAgICAgIHN0YXJ0Um93ID0gc2VsZWN0aW9uQm91bmRhcnkubWluUm93O1xuICAgICAgc3RhcnRDb2wgPSBzZWxlY3Rpb25Cb3VuZGFyeS5taW5Db2x1bW47XG4gICAgICBhZmZlY3RlZFJvd0NvdW50ID0gTWF0aC5taW4oYWZmZWN0ZWRSb3dDb3VudCwgc2VsZWN0aW9uUm93Q291bnQpO1xuICAgICAgYWZmZWN0ZWRDb2xDb3VudCA9IE1hdGgubWluKGFmZmVjdGVkQ29sQ291bnQsIHNlbGVjdGlvbkNvbENvdW50KTtcbiAgICB9XG5cbiAgICAvLyBTdGVwIDE6IFVubWVyZ2UgYWxsIG1lcmdlZCBjZWxscyB3aXRoaW4gdGhlIGFmZmVjdGVkIGFyZWFcbiAgICBsZXQgZGlkUGVyZm9ybU1lcmdlT3BlcmF0aW9ucyA9IGZhbHNlO1xuICAgIGNvbnN0IGxhc3RSb3dGb3JVbm1lcmdlID0gTWF0aC5taW4oaW5pdGlhbFJvd0NvdW50LCBzdGFydFJvdyArIGFmZmVjdGVkUm93Q291bnQpIC0gMTtcbiAgICBjb25zdCBsYXN0Q29sRm9yVW5tZXJnZSA9IE1hdGgubWluKGluaXRpYWxDb2xDb3VudCwgc3RhcnRDb2wgKyBhZmZlY3RlZENvbENvdW50KSAtIDE7XG4gICAgY29uc3QgdW5tZXJnZWRLZXlzID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IHJvdyA9IHN0YXJ0Um93OyByb3cgPD0gbGFzdFJvd0ZvclVubWVyZ2U7IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSBzdGFydENvbDsgY29sIDw9IGxhc3RDb2xGb3JVbm1lcmdlOyBjb2wrKykge1xuICAgICAgICBjb25zdCBjZWxsTWFwID0gaW5pdGlhbEdyaWRNYXBbcm93XVtjb2xdO1xuICAgICAgICBpZiAodW5tZXJnZWRLZXlzLmhhcyhjZWxsTWFwLmNlbGwuZ2V0S2V5KCkpKSB7XG4gICAgICAgICAgY29udGludWU7IC8vIGNlbGwgd2FzIGEgbWVyZ2VkIGNlbGwgdGhhdCB3YXMgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNlbGxNYXAuY2VsbC5fX3Jvd1NwYW4gPT09IDEgJiYgY2VsbE1hcC5jZWxsLl9fY29sU3BhbiA9PT0gMSkge1xuICAgICAgICAgIGNvbnRpbnVlOyAvLyBjZWxsIGlzIG5vdCBhIG1lcmdlZCBjZWxsXG4gICAgICAgIH1cbiAgICAgICAgJHVubWVyZ2VDZWxsTm9kZShjZWxsTWFwLmNlbGwpO1xuICAgICAgICB1bm1lcmdlZEtleXMuYWRkKGNlbGxNYXAuY2VsbC5nZXRLZXkoKSk7XG4gICAgICAgIGRpZFBlcmZvcm1NZXJnZU9wZXJhdGlvbnMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgW2ludGVyaW1HcmlkTWFwXSA9ICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrKGdyaWROb2RlLmdldFdyaXRhYmxlKCksIG51bGwsIG51bGwpO1xuXG4gICAgLy8gU3RlcCAyOiBFeHBhbmQgY3VycmVudCB0YWJsZSAoaWYgbmVlZGVkKVxuICAgIGNvbnN0IHJvd3NUb0luc2VydCA9IGFmZmVjdGVkUm93Q291bnQgLSBpbml0aWFsUm93Q291bnQgKyBzdGFydFJvdztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NUb0luc2VydDsgaSsrKSB7XG4gICAgICBjb25zdCBjZWxsTWFwID0gaW50ZXJpbUdyaWRNYXBbaW5pdGlhbFJvd0NvdW50IC0gMV1bMF07XG4gICAgICAkaW5zZXJ0VGFibGVSb3dBdE5vZGUoY2VsbE1hcC5jZWxsKTtcbiAgICB9XG4gICAgY29uc3QgY29sc1RvSW5zZXJ0ID0gYWZmZWN0ZWRDb2xDb3VudCAtIGluaXRpYWxDb2xDb3VudCArIHN0YXJ0Q29sO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sc1RvSW5zZXJ0OyBpKyspIHtcbiAgICAgIGNvbnN0IGNlbGxNYXAgPSBpbnRlcmltR3JpZE1hcFswXVtpbml0aWFsQ29sQ291bnQgLSAxXTtcbiAgICAgICRpbnNlcnRUYWJsZUNvbHVtbkF0Tm9kZShjZWxsTWFwLmNlbGwsIHRydWUsIGZhbHNlKTtcbiAgICB9XG4gICAgW2ludGVyaW1HcmlkTWFwXSA9ICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrKGdyaWROb2RlLmdldFdyaXRhYmxlKCksIG51bGwsIG51bGwpO1xuXG4gICAgLy8gU3RlcCAzOiBNZXJnZSBjZWxscyBhbmQgc2V0IGNlbGwgY29udGVudCwgdG8gbWF0Y2ggdGVtcGxhdGUgZ3JpZFxuICAgIGZvciAobGV0IHJvdyA9IHN0YXJ0Um93OyByb3cgPCBzdGFydFJvdyArIGFmZmVjdGVkUm93Q291bnQ7IHJvdysrKSB7XG4gICAgICBmb3IgKGxldCBjb2wgPSBzdGFydENvbDsgY29sIDwgc3RhcnRDb2wgKyBhZmZlY3RlZENvbENvdW50OyBjb2wrKykge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZVJvdyA9IHJvdyAtIHN0YXJ0Um93O1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZUNvbCA9IGNvbCAtIHN0YXJ0Q29sO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZUNlbGxNYXAgPSB0ZW1wbGF0ZUdyaWRNYXBbdGVtcGxhdGVSb3ddW3RlbXBsYXRlQ29sXTtcbiAgICAgICAgaWYgKHRlbXBsYXRlQ2VsbE1hcC5zdGFydFJvdyAhPT0gdGVtcGxhdGVSb3cgfHwgdGVtcGxhdGVDZWxsTWFwLnN0YXJ0Q29sdW1uICE9PSB0ZW1wbGF0ZUNvbCkge1xuICAgICAgICAgIGNvbnRpbnVlOyAvLyBjZWxsIGlzIGEgbWVyZ2VkIGNlbGwgdGhhdCB3YXMgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVtcGxhdGVDZWxsID0gdGVtcGxhdGVDZWxsTWFwLmNlbGw7XG4gICAgICAgIGlmICh0ZW1wbGF0ZUNlbGwuX19yb3dTcGFuICE9PSAxIHx8IHRlbXBsYXRlQ2VsbC5fX2NvbFNwYW4gIT09IDEpIHtcbiAgICAgICAgICBjb25zdCBjZWxsc1RvTWVyZ2UgPSBbXTtcbiAgICAgICAgICBjb25zdCBsYXN0Um93Rm9yTWVyZ2UgPSBNYXRoLm1pbihyb3cgKyB0ZW1wbGF0ZUNlbGwuX19yb3dTcGFuLCBzdGFydFJvdyArIGFmZmVjdGVkUm93Q291bnQpIC0gMTtcbiAgICAgICAgICBjb25zdCBsYXN0Q29sRm9yTWVyZ2UgPSBNYXRoLm1pbihjb2wgKyB0ZW1wbGF0ZUNlbGwuX19jb2xTcGFuLCBzdGFydENvbCArIGFmZmVjdGVkQ29sQ291bnQpIC0gMTtcbiAgICAgICAgICBmb3IgKGxldCByID0gcm93OyByIDw9IGxhc3RSb3dGb3JNZXJnZTsgcisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gY29sOyBjIDw9IGxhc3RDb2xGb3JNZXJnZTsgYysrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGNlbGxNYXAgPSBpbnRlcmltR3JpZE1hcFtyXVtjXTtcbiAgICAgICAgICAgICAgY2VsbHNUb01lcmdlLnB1c2goY2VsbE1hcC5jZWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgJG1lcmdlQ2VsbHMoY2VsbHNUb01lcmdlKTtcbiAgICAgICAgICBkaWRQZXJmb3JtTWVyZ2VPcGVyYXRpb25zID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgY2VsbFxuICAgICAgICB9ID0gaW50ZXJpbUdyaWRNYXBbcm93XVtjb2xdO1xuICAgICAgICBjb25zdCBvcmlnaW5hbENoaWxkcmVuID0gY2VsbC5nZXRDaGlsZHJlbigpO1xuICAgICAgICB0ZW1wbGF0ZUNlbGwuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhZ3JhcGhOb2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICAgICAgICAgIHBhcmFncmFwaE5vZGUuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICAgIGNlbGwuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2VsbC5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9yaWdpbmFsQ2hpbGRyZW4uZm9yRWFjaChuID0+IG4ucmVtb3ZlKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNUYWJsZVNlbGVjdGlvbiAmJiBkaWRQZXJmb3JtTWVyZ2VPcGVyYXRpb25zKSB7XG4gICAgICAvLyByZXNldCB0aGUgdGFibGUgc2VsZWN0aW9uIGluIGNhc2UgdGhlIGFuY2hvciBvciBmb2N1cyBjZWxsIHdhc1xuICAgICAgLy8gcmVtb3ZlZCB2aWEgbWVyZ2Ugb3BlcmF0aW9uc1xuICAgICAgY29uc3QgW2ZpbmFsR3JpZE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwU2tpcENlbGxDaGVjayhncmlkTm9kZS5nZXRXcml0YWJsZSgpLCBudWxsLCBudWxsKTtcbiAgICAgIGNvbnN0IG5ld0FuY2hvckNlbGxNYXAgPSBmaW5hbEdyaWRNYXBbYW5jaG9yQ2VsbE1hcC5zdGFydFJvd11bYW5jaG9yQ2VsbE1hcC5zdGFydENvbHVtbl07XG4gICAgICBuZXdBbmNob3JDZWxsTWFwLmNlbGwuc2VsZWN0RW5kKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBuZXh0Rm9jdXMgPSB0YWJsZU9ic2VydmVyLmdldEFuZENsZWFyTmV4dEZvY3VzKCk7XG4gICAgaWYgKG5leHRGb2N1cyAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmb2N1c0NlbGxcbiAgICAgIH0gPSBuZXh0Rm9jdXM7XG4gICAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24udGFibGVLZXkgPT09IHRhYmxlT2JzZXJ2ZXIudGFibGVOb2RlS2V5KSB7XG4gICAgICAgIGlmIChmb2N1c0NlbGwueCA9PT0gdGFibGVPYnNlcnZlci5mb2N1c1ggJiYgZm9jdXNDZWxsLnkgPT09IHRhYmxlT2JzZXJ2ZXIuZm9jdXNZKSB7XG4gICAgICAgICAgLy8gVGhlIHNlbGVjdGlvbiBpcyBhbHJlYWR5IHRoZSBjb3JyZWN0IHRhYmxlIHNlbGVjdGlvblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oZm9jdXNDZWxsKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmb2N1c0NlbGwgIT09IHRhYmxlT2JzZXJ2ZXIuYW5jaG9yQ2VsbCAmJiAkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgICAvLyBUaGUgc2VsZWN0aW9uIGhhcyBjcm9zc2VkIGNlbGxzXG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIuJHNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihmb2N1c0NlbGwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkQ2hlY2tTZWxlY3Rpb24gPSB0YWJsZU9ic2VydmVyLmdldEFuZENsZWFyU2hvdWxkQ2hlY2tTZWxlY3Rpb24oKTtcbiAgICAvLyBJZiB0aGV5IHByZXNzZWQgdGhlIGRvd24gYXJyb3cgd2l0aCB0aGUgc2VsZWN0aW9uIG91dHNpZGUgb2YgdGhlXG4gICAgLy8gdGFibGUsIGFuZCB0aGVuIHRoZSBzZWxlY3Rpb24gZW5kcyB1cCBpbiB0aGUgdGFibGUgYnV0IG5vdCBpbiB0aGVcbiAgICAvLyBmaXJzdCBjZWxsLCB0aGVuIG1vdmUgdGhlIHNlbGVjdGlvbiB0byB0aGUgZmlyc3QgY2VsbC5cbiAgICBpZiAoc2hvdWxkQ2hlY2tTZWxlY3Rpb24gJiYgJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBmaXJzdFJvdyA9IHRhYmxlTm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBjb25zdCBhbmNob3JDZWxsID0gJGZpbmRDZWxsTm9kZShhbmNob3IpO1xuICAgICAgaWYgKGFuY2hvckNlbGwgIT09IG51bGwgJiYgJGlzVGFibGVSb3dOb2RlKGZpcnN0Um93KSkge1xuICAgICAgICBjb25zdCBmaXJzdENlbGwgPSBmaXJzdFJvdy5nZXRGaXJzdENoaWxkKCk7XG4gICAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGZpcnN0Q2VsbCkgJiYgdGFibGVOb2RlLmlzKCRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yQ2VsbCwgbm9kZSA9PiBub2RlLmlzKHRhYmxlTm9kZSkgfHwgbm9kZS5pcyhmaXJzdENlbGwpKSkpIHtcbiAgICAgICAgICAvLyBUaGUgc2VsZWN0aW9uIG1vdmVkIHRvIHRoZSB0YWJsZSwgYnV0IG5vdCBpbiB0aGUgZmlyc3QgY2VsbFxuICAgICAgICAgIGZpcnN0Q2VsbC5zZWxlY3RTdGFydCgpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgZm9jdXNcbiAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IGZvY3VzLmdldE5vZGUoKTtcbiAgICAgIC8vIFVzaW5nIGV4cGxpY2l0IGNvbXBhcmlzb24gd2l0aCB0YWJsZSBub2RlIHRvIGVuc3VyZSBpdCdzIG5vdCBhIG5lc3RlZCB0YWJsZVxuICAgICAgLy8gYXMgaW4gdGhhdCBjYXNlIHdlJ2xsIGxlYXZlIHNlbGVjdGlvbiByZXNvbHZpbmcgdG8gdGhhdCB0YWJsZVxuICAgICAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSAkZmluZENlbGxOb2RlKGFuY2hvck5vZGUpO1xuICAgICAgY29uc3QgZm9jdXNDZWxsTm9kZSA9ICRmaW5kQ2VsbE5vZGUoZm9jdXNOb2RlKTtcbiAgICAgIGNvbnN0IGlzQW5jaG9ySW5zaWRlID0gISEoYW5jaG9yQ2VsbE5vZGUgJiYgdGFibGVOb2RlLmlzKCRmaW5kVGFibGVOb2RlKGFuY2hvckNlbGxOb2RlKSkpO1xuICAgICAgY29uc3QgaXNGb2N1c0luc2lkZSA9ICEhKGZvY3VzQ2VsbE5vZGUgJiYgdGFibGVOb2RlLmlzKCRmaW5kVGFibGVOb2RlKGZvY3VzQ2VsbE5vZGUpKSk7XG4gICAgICBjb25zdCBpc1BhcnRpYWxseVdpdGhpblRhYmxlID0gaXNBbmNob3JJbnNpZGUgIT09IGlzRm9jdXNJbnNpZGU7XG4gICAgICBjb25zdCBpc1dpdGhpblRhYmxlID0gaXNBbmNob3JJbnNpZGUgJiYgaXNGb2N1c0luc2lkZTtcbiAgICAgIGNvbnN0IGlzQmFja3dhcmQgPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpO1xuICAgICAgaWYgKGlzUGFydGlhbGx5V2l0aGluVGFibGUpIHtcbiAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gc2VsZWN0aW9uLmNsb25lKCk7XG4gICAgICAgIGlmIChpc0ZvY3VzSW5zaWRlKSB7XG4gICAgICAgICAgY29uc3QgW3RhYmxlTWFwXSA9ICRjb21wdXRlVGFibGVNYXAodGFibGVOb2RlLCBmb2N1c0NlbGxOb2RlLCBmb2N1c0NlbGxOb2RlKTtcbiAgICAgICAgICBjb25zdCBmaXJzdENlbGwgPSB0YWJsZU1hcFswXVswXS5jZWxsO1xuICAgICAgICAgIGNvbnN0IGxhc3RDZWxsID0gdGFibGVNYXBbdGFibGVNYXAubGVuZ3RoIC0gMV0uYXQoLTEpLmNlbGw7XG4gICAgICAgICAgbmV3U2VsZWN0aW9uLmZvY3VzLnNldChpc0JhY2t3YXJkID8gZmlyc3RDZWxsLmdldEtleSgpIDogbGFzdENlbGwuZ2V0S2V5KCksIGlzQmFja3dhcmQgPyBmaXJzdENlbGwuZ2V0Q2hpbGRyZW5TaXplKCkgOiBsYXN0Q2VsbC5nZXRDaGlsZHJlblNpemUoKSwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FuY2hvckluc2lkZSkge1xuICAgICAgICAgIGNvbnN0IFt0YWJsZU1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgYW5jaG9yQ2VsbE5vZGUsIGFuY2hvckNlbGxOb2RlKTtcbiAgICAgICAgICBjb25zdCBmaXJzdENlbGwgPSB0YWJsZU1hcFswXVswXS5jZWxsO1xuICAgICAgICAgIGNvbnN0IGxhc3RDZWxsID0gdGFibGVNYXBbdGFibGVNYXAubGVuZ3RoIC0gMV0uYXQoLTEpLmNlbGw7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogSWYgaXNCYWNrd2FyZCwgc2V0IHRoZSBhbmNob3IgdG8gYmUgYXQgdGhlIGVuZCBvZiB0aGUgdGFibGUgc28gdGhhdCB3aGVuIHRoZSBjdXJzb3IgbW92ZXMgb3V0c2lkZSBvZlxuICAgICAgICAgICAqIHRoZSB0YWJsZSBpbiB0aGUgYmFja3dhcmQgZGlyZWN0aW9uLCB0aGUgZW50aXJlIHRhYmxlIHdpbGwgYmUgc2VsZWN0ZWQgZnJvbSBpdHMgZW5kLlxuICAgICAgICAgICAqIE90aGVyd2lzZSwgaWYgZm9yd2FyZCwgc2V0IHRoZSBhbmNob3IgdG8gYmUgYXQgdGhlIHN0YXJ0IG9mIHRoZSB0YWJsZSBzbyB0aGF0IHdoZW4gdGhlIGZvY3VzIGlzIGRyYWdnZWRcbiAgICAgICAgICAgKiBvdXRzaWRlIHRoIGVuZCBvZiB0aGUgdGFibGUsIGl0IHdpbGwgc3RhcnQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSB0YWJsZS5cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBuZXdTZWxlY3Rpb24uYW5jaG9yLnNldChpc0JhY2t3YXJkID8gbGFzdENlbGwuZ2V0S2V5KCkgOiBmaXJzdENlbGwuZ2V0S2V5KCksIGlzQmFja3dhcmQgPyBsYXN0Q2VsbC5nZXRDaGlsZHJlblNpemUoKSA6IDAsICdlbGVtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgJHNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgICAgICAkYWRkSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVPYnNlcnZlcik7XG4gICAgICB9IGVsc2UgaWYgKGlzV2l0aGluVGFibGUpIHtcbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiBzZWxlY3Rpb24gc3BhbnMgYWNyb3NzIG11bHRpcGxlIGNlbGxzIGJ1dCBzdGlsbFxuICAgICAgICAvLyBoYXMgcmFuZ2Ugc2VsZWN0aW9uLCB0aGVuIHdlIGNvbnZlcnQgaXQgaW50byB0YWJsZSBzZWxlY3Rpb25cbiAgICAgICAgaWYgKCFhbmNob3JDZWxsTm9kZS5pcyhmb2N1c0NlbGxOb2RlKSkge1xuICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIuJHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oJGdldE9ic2VydmVyQ2VsbEZyb21DZWxsTm9kZU9yVGhyb3codGFibGVPYnNlcnZlciwgYW5jaG9yQ2VsbE5vZGUpKTtcbiAgICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oJGdldE9ic2VydmVyQ2VsbEZyb21DZWxsTm9kZU9yVGhyb3codGFibGVPYnNlcnZlciwgZm9jdXNDZWxsTm9kZSksIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFuZGxlIGNhc2Ugd2hlbiB0aGUgcG9pbnRlciB0eXBlIGlzIHRvdWNoIGFuZCB0aGUgY3VycmVudCBhbmRcbiAgICAgICAgLy8gcHJldmlvdXMgc2VsZWN0aW9uIGFyZSBjb2xsYXBzZWQsIGFuZCB0aGUgcHJldmlvdXMgYW5jaG9yIGFuZCBjdXJyZW50XG4gICAgICAgIC8vIGZvY3VzIGNlbGwgbm9kZXMgYXJlIGRpZmZlcmVudCwgdGhlbiB3ZSBjb252ZXJ0IGl0IGludG8gdGFibGUgc2VsZWN0aW9uXG4gICAgICAgIC8vIEhvd2V2ZXIsIG9ubHkgZG8gdGhpcyBpZiB0aGUgdGFibGUgb2JzZXJ2ZXIgaXMgYWN0aXZlbHkgc2VsZWN0aW5nICh1c2VyIGRyYWdnaW5nKVxuICAgICAgICAvLyB0byBwcmV2ZW50IHVud2FudGVkIHNlbGVjdGlvbnMgd2hlbiBzaW1wbHkgdGFwcGluZyBiZXR3ZWVuIGNlbGxzIG9uIG1vYmlsZVxuICAgICAgICBpZiAodGFibGVPYnNlcnZlci5wb2ludGVyVHlwZSA9PT0gJ3RvdWNoJyAmJiB0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmICRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmIHByZXZTZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICAgIGNvbnN0IHByZXZBbmNob3JDZWxsTm9kZSA9ICRmaW5kQ2VsbE5vZGUocHJldlNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpKTtcbiAgICAgICAgICBpZiAocHJldkFuY2hvckNlbGxOb2RlICYmICFwcmV2QW5jaG9yQ2VsbE5vZGUuaXMoZm9jdXNDZWxsTm9kZSkpIHtcbiAgICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIuJHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oJGdldE9ic2VydmVyQ2VsbEZyb21DZWxsTm9kZU9yVGhyb3codGFibGVPYnNlcnZlciwgcHJldkFuY2hvckNlbGxOb2RlKSk7XG4gICAgICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oJGdldE9ic2VydmVyQ2VsbEZyb21DZWxsTm9kZU9yVGhyb3codGFibGVPYnNlcnZlciwgZm9jdXNDZWxsTm9kZSksIHRydWUpO1xuICAgICAgICAgICAgdGFibGVPYnNlcnZlci5wb2ludGVyVHlwZSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzZWxlY3Rpb24gJiYgJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24uaXMocHJldlNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLnRhYmxlS2V5ID09PSB0YWJsZU5vZGUuZ2V0S2V5KCkpIHtcbiAgICAgIC8vIGlmIHNlbGVjdGlvbiBnb2VzIG91dHNpZGUgb2YgdGhlIHRhYmxlIHdlIG5lZWQgdG8gY2hhbmdlIGl0IHRvIFJhbmdlIHNlbGVjdGlvblxuICAgICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGVkaXRvcldpbmRvdyk7XG4gICAgICBpZiAoZG9tU2VsZWN0aW9uICYmIGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlICYmIGRvbVNlbGVjdGlvbi5mb2N1c05vZGUpIHtcbiAgICAgICAgY29uc3QgZm9jdXNOb2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZG9tU2VsZWN0aW9uLmZvY3VzTm9kZSk7XG4gICAgICAgIGNvbnN0IGlzRm9jdXNPdXRzaWRlID0gZm9jdXNOb2RlICYmICF0YWJsZU5vZGUuaXNQYXJlbnRPZihmb2N1c05vZGUpO1xuICAgICAgICBjb25zdCBhbmNob3JOb2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoZG9tU2VsZWN0aW9uLmFuY2hvck5vZGUpO1xuICAgICAgICBjb25zdCBpc0FuY2hvckluc2lkZSA9IGFuY2hvck5vZGUgJiYgdGFibGVOb2RlLmlzUGFyZW50T2YoYW5jaG9yTm9kZSk7XG4gICAgICAgIGlmIChpc0ZvY3VzT3V0c2lkZSAmJiBpc0FuY2hvckluc2lkZSAmJiBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgICAgICBjb25zdCBuZXdTZWxlY3Rpb24gPSAkY3JlYXRlUmFuZ2VTZWxlY3Rpb25Gcm9tRG9tKGRvbVNlbGVjdGlvbiwgZWRpdG9yKTtcbiAgICAgICAgICBpZiAobmV3U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb24uYW5jaG9yLnNldCh0YWJsZU5vZGUuZ2V0S2V5KCksIHNlbGVjdGlvbi5pc0JhY2t3YXJkKCkgPyB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW5TaXplKCkgOiAwLCAnZWxlbWVudCcpO1xuICAgICAgICAgICAgZG9tU2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgJHNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0aW9uICYmICFzZWxlY3Rpb24uaXMocHJldlNlbGVjdGlvbikgJiYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzVGFibGVTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikpICYmIHRhYmxlT2JzZXJ2ZXIudGFibGVTZWxlY3Rpb24gJiYgIXRhYmxlT2JzZXJ2ZXIudGFibGVTZWxlY3Rpb24uaXMocHJldlNlbGVjdGlvbikpIHtcbiAgICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi50YWJsZUtleSA9PT0gdGFibGVPYnNlcnZlci50YWJsZU5vZGVLZXkpIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci4kdXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgfSBlbHNlIGlmICghJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiAkaXNUYWJsZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBwcmV2U2VsZWN0aW9uLnRhYmxlS2V5ID09PSB0YWJsZU9ic2VydmVyLnRhYmxlTm9kZUtleSkge1xuICAgICAgICB0YWJsZU9ic2VydmVyLiR1cGRhdGVUYWJsZVRhYmxlU2VsZWN0aW9uKG51bGwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGFibGVPYnNlcnZlci5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyAmJiAhdGFibGVOb2RlLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgJHJlbW92ZUhpZ2hsaWdodFN0eWxlVG9UYWJsZShlZGl0b3IsIHRhYmxlT2JzZXJ2ZXIpO1xuICAgIH0gZWxzZSBpZiAoIXRhYmxlT2JzZXJ2ZXIuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgJiYgdGFibGVOb2RlLmlzU2VsZWN0ZWQoKSkge1xuICAgICAgJGFkZEhpZ2hsaWdodFN0eWxlVG9UYWJsZShlZGl0b3IsIHRhYmxlT2JzZXJ2ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsICgpID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCAhJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZWRnZVBvc2l0aW9uID0gJGdldFRhYmxlRWRnZUN1cnNvclBvc2l0aW9uKGVkaXRvciwgc2VsZWN0aW9uLCB0YWJsZU5vZGUpO1xuICAgIGlmIChlZGdlUG9zaXRpb24pIHtcbiAgICAgICRpbnNlcnRQYXJhZ3JhcGhBdFRhYmxlRWRnZShlZGdlUG9zaXRpb24sIHRhYmxlTm9kZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHJldHVybiB0YWJsZU9ic2VydmVyO1xufVxuZnVuY3Rpb24gZGV0YWNoVGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50LCB0YWJsZU9ic2VydmVyKSB7XG4gIGlmIChnZXRUYWJsZU9ic2VydmVyRnJvbVRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQpID09PSB0YWJsZU9ic2VydmVyKSB7XG4gICAgZGVsZXRlIHRhYmxlRWxlbWVudFtMRVhJQ0FMX0VMRU1FTlRfS0VZXTtcbiAgfVxufVxuZnVuY3Rpb24gYXR0YWNoVGFibGVPYnNlcnZlclRvVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgdGFibGVPYnNlcnZlcikge1xuICBpZiAoIShnZXRUYWJsZU9ic2VydmVyRnJvbVRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQpID09PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgdGFibGVFbGVtZW50IGFscmVhZHkgaGFzIGFuIGF0dGFjaGVkIFRhYmxlT2JzZXJ2ZXJgKTtcbiAgfVxuICB0YWJsZUVsZW1lbnRbTEVYSUNBTF9FTEVNRU5UX0tFWV0gPSB0YWJsZU9ic2VydmVyO1xufVxuZnVuY3Rpb24gZ2V0VGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50KSB7XG4gIHJldHVybiB0YWJsZUVsZW1lbnRbTEVYSUNBTF9FTEVNRU5UX0tFWV0gfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERPTUNlbGxGcm9tVGFyZ2V0KG5vZGUpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICBjb25zdCBub2RlTmFtZSA9IGN1cnJlbnROb2RlLm5vZGVOYW1lO1xuICAgIGlmIChub2RlTmFtZSA9PT0gJ1REJyB8fCBub2RlTmFtZSA9PT0gJ1RIJykge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGNvbnN0IGNlbGwgPSBjdXJyZW50Tm9kZS5fY2VsbDtcbiAgICAgIGlmIChjZWxsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2VsbDtcbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RE9NQ2VsbEluVGFibGVGcm9tVGFyZ2V0KHRhYmxlLCBub2RlKSB7XG4gIGlmICghdGFibGUuY29udGFpbnMobm9kZSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsZXQgY2VsbCA9IG51bGw7XG4gIGZvciAobGV0IGN1cnJlbnROb2RlID0gbm9kZTsgY3VycmVudE5vZGUgIT0gbnVsbDsgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlKSB7XG4gICAgaWYgKGN1cnJlbnROb2RlID09PSB0YWJsZSkge1xuICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVOYW1lID0gY3VycmVudE5vZGUubm9kZU5hbWU7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnVEQnIHx8IG5vZGVOYW1lID09PSAnVEgnKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgICAgY2VsbCA9IGN1cnJlbnROb2RlLl9jZWxsIHx8IG51bGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VGFibGUodGFibGVOb2RlLCBkb20pIHtcbiAgY29uc3QgdGFibGVFbGVtZW50ID0gZ2V0VGFibGVFbGVtZW50KHRhYmxlTm9kZSwgZG9tKTtcbiAgY29uc3QgZG9tUm93cyA9IFtdO1xuICBjb25zdCBncmlkID0ge1xuICAgIGNvbHVtbnM6IDAsXG4gICAgZG9tUm93cyxcbiAgICByb3dzOiAwXG4gIH07XG4gIGxldCBjdXJyZW50Tm9kZSA9IHRhYmxlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0cicpO1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgZG9tUm93cy5sZW5ndGggPSAwO1xuICB3aGlsZSAoY3VycmVudE5vZGUgIT0gbnVsbCkge1xuICAgIGNvbnN0IG5vZGVNYW1lID0gY3VycmVudE5vZGUubm9kZU5hbWU7XG4gICAgaWYgKG5vZGVNYW1lID09PSAnVEQnIHx8IG5vZGVNYW1lID09PSAnVEgnKSB7XG4gICAgICBjb25zdCBlbGVtID0gY3VycmVudE5vZGU7XG4gICAgICBjb25zdCBjZWxsID0ge1xuICAgICAgICBlbGVtLFxuICAgICAgICBoYXNCYWNrZ3JvdW5kQ29sb3I6IGVsZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yICE9PSAnJyxcbiAgICAgICAgaGlnaGxpZ2h0ZWQ6IGZhbHNlLFxuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9O1xuXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yOiBpbnRlcm5hbCBmaWVsZFxuICAgICAgY3VycmVudE5vZGUuX2NlbGwgPSBjZWxsO1xuICAgICAgbGV0IHJvdyA9IGRvbVJvd3NbeV07XG4gICAgICBpZiAocm93ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcm93ID0gZG9tUm93c1t5XSA9IFtdO1xuICAgICAgfVxuICAgICAgcm93W3hdID0gY2VsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2hpbGQgPSBjdXJyZW50Tm9kZS5maXJzdENoaWxkO1xuICAgICAgaWYgKGNoaWxkICE9IG51bGwpIHtcbiAgICAgICAgY3VycmVudE5vZGUgPSBjaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNpYmxpbmcgPSBjdXJyZW50Tm9kZS5uZXh0U2libGluZztcbiAgICBpZiAoc2libGluZyAhPSBudWxsKSB7XG4gICAgICB4Kys7XG4gICAgICBjdXJyZW50Tm9kZSA9IHNpYmxpbmc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50ID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHBhcmVudFNpYmxpbmcgPSBwYXJlbnQubmV4dFNpYmxpbmc7XG4gICAgICBpZiAocGFyZW50U2libGluZyA9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgeSsrO1xuICAgICAgeCA9IDA7XG4gICAgICBjdXJyZW50Tm9kZSA9IHBhcmVudFNpYmxpbmc7XG4gICAgfVxuICB9XG4gIGdyaWQuY29sdW1ucyA9IHggKyAxO1xuICBncmlkLnJvd3MgPSB5ICsgMTtcbiAgcmV0dXJuIGdyaWQ7XG59XG5mdW5jdGlvbiAkdXBkYXRlRE9NRm9yU2VsZWN0aW9uKGVkaXRvciwgdGFibGUsIHNlbGVjdGlvbikge1xuICBjb25zdCBzZWxlY3RlZENlbGxOb2RlcyA9IG5ldyBTZXQoc2VsZWN0aW9uID8gc2VsZWN0aW9uLmdldE5vZGVzKCkgOiBbXSk7XG4gICRmb3JFYWNoVGFibGVDZWxsKHRhYmxlLCAoY2VsbCwgbGV4aWNhbE5vZGUpID0+IHtcbiAgICBjb25zdCBlbGVtID0gY2VsbC5lbGVtO1xuICAgIGlmIChzZWxlY3RlZENlbGxOb2Rlcy5oYXMobGV4aWNhbE5vZGUpKSB7XG4gICAgICBjZWxsLmhpZ2hsaWdodGVkID0gdHJ1ZTtcbiAgICAgICRhZGRIaWdobGlnaHRUb0RPTShlZGl0b3IsIGNlbGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxsLmhpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgICAkcmVtb3ZlSGlnaGxpZ2h0RnJvbURPTShlZGl0b3IsIGNlbGwpO1xuICAgICAgaWYgKCFlbGVtLmdldEF0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gJGZvckVhY2hUYWJsZUNlbGwoZ3JpZCwgY2IpIHtcbiAgY29uc3Qge1xuICAgIGRvbVJvd3NcbiAgfSA9IGdyaWQ7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgZG9tUm93cy5sZW5ndGg7IHkrKykge1xuICAgIGNvbnN0IHJvdyA9IGRvbVJvd3NbeV07XG4gICAgaWYgKCFyb3cpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHJvdy5sZW5ndGg7IHgrKykge1xuICAgICAgY29uc3QgY2VsbCA9IHJvd1t4XTtcbiAgICAgIGlmICghY2VsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxleGljYWxOb2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoY2VsbC5lbGVtKTtcbiAgICAgIGlmIChsZXhpY2FsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICBjYihjZWxsLCBsZXhpY2FsTm9kZSwge1xuICAgICAgICAgIHgsXG4gICAgICAgICAgeVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRhZGRIaWdobGlnaHRTdHlsZVRvVGFibGUoZWRpdG9yLCB0YWJsZVNlbGVjdGlvbikge1xuICB0YWJsZVNlbGVjdGlvbi4kZGlzYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICRmb3JFYWNoVGFibGVDZWxsKHRhYmxlU2VsZWN0aW9uLnRhYmxlLCBjZWxsID0+IHtcbiAgICBjZWxsLmhpZ2hsaWdodGVkID0gdHJ1ZTtcbiAgICAkYWRkSGlnaGxpZ2h0VG9ET00oZWRpdG9yLCBjZWxsKTtcbiAgfSk7XG59XG5mdW5jdGlvbiAkcmVtb3ZlSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVPYnNlcnZlcikge1xuICB0YWJsZU9ic2VydmVyLiRlbmFibGVIaWdobGlnaHRTdHlsZSgpO1xuICAkZm9yRWFjaFRhYmxlQ2VsbCh0YWJsZU9ic2VydmVyLnRhYmxlLCBjZWxsID0+IHtcbiAgICBjb25zdCBlbGVtID0gY2VsbC5lbGVtO1xuICAgIGNlbGwuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcbiAgICAkcmVtb3ZlSGlnaGxpZ2h0RnJvbURPTShlZGl0b3IsIGNlbGwpO1xuICAgIGlmICghZWxlbS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgIGVsZW0ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiAkc2VsZWN0QWRqYWNlbnRDZWxsKHRhYmxlQ2VsbE5vZGUsIGRpcmVjdGlvbikge1xuICBjb25zdCBzaWJsaW5nTWV0aG9kID0gZGlyZWN0aW9uID09PSAnbmV4dCcgPyAnZ2V0TmV4dFNpYmxpbmcnIDogJ2dldFByZXZpb3VzU2libGluZyc7XG4gIGNvbnN0IGNoaWxkTWV0aG9kID0gZGlyZWN0aW9uID09PSAnbmV4dCcgPyAnZ2V0Rmlyc3RDaGlsZCcgOiAnZ2V0TGFzdENoaWxkJztcbiAgY29uc3Qgc2libGluZyA9IHRhYmxlQ2VsbE5vZGVbc2libGluZ01ldGhvZF0oKTtcbiAgaWYgKCRpc0VsZW1lbnROb2RlKHNpYmxpbmcpKSB7XG4gICAgcmV0dXJuIHNpYmxpbmcuc2VsZWN0RW5kKCk7XG4gIH1cbiAgY29uc3QgcGFyZW50Um93ID0gJGZpbmRNYXRjaGluZ1BhcmVudCh0YWJsZUNlbGxOb2RlLCAkaXNUYWJsZVJvd05vZGUpO1xuICBpZiAoIShwYXJlbnRSb3cgIT09IG51bGwpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBzZWxlY3RBZGphY2VudENlbGw6IENlbGwgbm90IGluIHRhYmxlIHJvd2ApO1xuICB9XG4gIGZvciAobGV0IG5leHRSb3cgPSBwYXJlbnRSb3dbc2libGluZ01ldGhvZF0oKTsgJGlzVGFibGVSb3dOb2RlKG5leHRSb3cpOyBuZXh0Um93ID0gbmV4dFJvd1tzaWJsaW5nTWV0aG9kXSgpKSB7XG4gICAgY29uc3QgY2hpbGQgPSBuZXh0Um93W2NoaWxkTWV0aG9kXSgpO1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkpIHtcbiAgICAgIHJldHVybiBjaGlsZC5zZWxlY3RFbmQoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgcGFyZW50VGFibGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHBhcmVudFJvdywgJGlzVGFibGVOb2RlKTtcbiAgaWYgKCEocGFyZW50VGFibGUgIT09IG51bGwpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBzZWxlY3RBZGphY2VudENlbGw6IFJvdyBub3QgaW4gdGFibGVgKTtcbiAgfVxuICByZXR1cm4gZGlyZWN0aW9uID09PSAnbmV4dCcgPyBwYXJlbnRUYWJsZS5zZWxlY3ROZXh0KCkgOiBwYXJlbnRUYWJsZS5zZWxlY3RQcmV2aW91cygpO1xufVxuY29uc3Qgc2VsZWN0VGFibGVOb2RlSW5EaXJlY3Rpb24gPSAodGFibGVPYnNlcnZlciwgdGFibGVOb2RlLCB4LCB5LCBkaXJlY3Rpb24pID0+IHtcbiAgY29uc3QgaXNGb3J3YXJkID0gZGlyZWN0aW9uID09PSAnZm9yd2FyZCc7XG4gIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgY2FzZSAnYmFja3dhcmQnOlxuICAgIGNhc2UgJ2ZvcndhcmQnOlxuICAgICAgaWYgKHggIT09IChpc0ZvcndhcmQgPyB0YWJsZU9ic2VydmVyLnRhYmxlLmNvbHVtbnMgLSAxIDogMCkpIHtcbiAgICAgICAgc2VsZWN0VGFibGVDZWxsTm9kZSh0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHNPclRocm93KHggKyAoaXNGb3J3YXJkID8gMSA6IC0xKSwgeSwgdGFibGVPYnNlcnZlci50YWJsZSksIGlzRm9yd2FyZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoeSAhPT0gKGlzRm9yd2FyZCA/IHRhYmxlT2JzZXJ2ZXIudGFibGUucm93cyAtIDEgOiAwKSkge1xuICAgICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyhpc0ZvcndhcmQgPyAwIDogdGFibGVPYnNlcnZlci50YWJsZS5jb2x1bW5zIC0gMSwgeSArIChpc0ZvcndhcmQgPyAxIDogLTEpLCB0YWJsZU9ic2VydmVyLnRhYmxlKSwgaXNGb3J3YXJkKTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNGb3J3YXJkKSB7XG4gICAgICAgICAgdGFibGVOb2RlLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFibGVOb2RlLnNlbGVjdE5leHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAndXAnOlxuICAgICAgaWYgKHkgIT09IDApIHtcbiAgICAgICAgc2VsZWN0VGFibGVDZWxsTm9kZSh0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHNPclRocm93KHgsIHkgLSAxLCB0YWJsZU9ic2VydmVyLnRhYmxlKSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFibGVOb2RlLnNlbGVjdFByZXZpb3VzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdkb3duJzpcbiAgICAgIGlmICh5ICE9PSB0YWJsZU9ic2VydmVyLnRhYmxlLnJvd3MgLSAxKSB7XG4gICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4LCB5ICsgMSwgdGFibGVPYnNlcnZlci50YWJsZSksIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFibGVOb2RlLnNlbGVjdE5leHQoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRDb3JuZXIocmVjdCwgY2VsbFZhbHVlKSB7XG4gIGxldCBjb2xOYW1lO1xuICBsZXQgcm93TmFtZTtcbiAgaWYgKGNlbGxWYWx1ZS5zdGFydENvbHVtbiA9PT0gcmVjdC5taW5Db2x1bW4pIHtcbiAgICBjb2xOYW1lID0gJ21pbkNvbHVtbic7XG4gIH0gZWxzZSBpZiAoY2VsbFZhbHVlLnN0YXJ0Q29sdW1uICsgY2VsbFZhbHVlLmNlbGwuX19jb2xTcGFuIC0gMSA9PT0gcmVjdC5tYXhDb2x1bW4pIHtcbiAgICBjb2xOYW1lID0gJ21heENvbHVtbic7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNlbGxWYWx1ZS5zdGFydFJvdyA9PT0gcmVjdC5taW5Sb3cpIHtcbiAgICByb3dOYW1lID0gJ21pblJvdyc7XG4gIH0gZWxzZSBpZiAoY2VsbFZhbHVlLnN0YXJ0Um93ICsgY2VsbFZhbHVlLmNlbGwuX19yb3dTcGFuIC0gMSA9PT0gcmVjdC5tYXhSb3cpIHtcbiAgICByb3dOYW1lID0gJ21heFJvdyc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIFtjb2xOYW1lLCByb3dOYW1lXTtcbn1cbmZ1bmN0aW9uIGdldENvcm5lck9yVGhyb3cocmVjdCwgY2VsbFZhbHVlKSB7XG4gIGNvbnN0IGNvcm5lciA9IGdldENvcm5lcihyZWN0LCBjZWxsVmFsdWUpO1xuICBpZiAoIShjb3JuZXIgIT09IG51bGwpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBnZXRDb3JuZXJPclRocm93OiBjZWxsICR7Y2VsbFZhbHVlLmNlbGwuZ2V0S2V5KCl9IGlzIG5vdCBhdCBhIGNvcm5lciBvZiByZWN0YCk7XG4gIH1cbiAgcmV0dXJuIGNvcm5lcjtcbn1cbmZ1bmN0aW9uIG9wcG9zaXRlQ29ybmVyKFtjb2xOYW1lLCByb3dOYW1lXSkge1xuICByZXR1cm4gW2NvbE5hbWUgPT09ICdtaW5Db2x1bW4nID8gJ21heENvbHVtbicgOiAnbWluQ29sdW1uJywgcm93TmFtZSA9PT0gJ21pblJvdycgPyAnbWF4Um93JyA6ICdtaW5Sb3cnXTtcbn1cbmZ1bmN0aW9uIGNlbGxBdENvcm5lck9yVGhyb3codGFibGVNYXAsIHJlY3QsIFtjb2xOYW1lLCByb3dOYW1lXSkge1xuICBjb25zdCByb3dOdW0gPSByZWN0W3Jvd05hbWVdO1xuICBjb25zdCByb3dNYXAgPSB0YWJsZU1hcFtyb3dOdW1dO1xuICBpZiAoIShyb3dNYXAgIT09IHVuZGVmaW5lZCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGNlbGxBdENvcm5lck9yVGhyb3c6ICR7cm93TmFtZX0gPSAke1N0cmluZyhyb3dOdW0pfSBtaXNzaW5nIGluIHRhYmxlTWFwYCk7XG4gIH1cbiAgY29uc3QgY29sTnVtID0gcmVjdFtjb2xOYW1lXTtcbiAgY29uc3QgY2VsbCA9IHJvd01hcFtjb2xOdW1dO1xuICBpZiAoIShjZWxsICE9PSB1bmRlZmluZWQpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBjZWxsQXRDb3JuZXJPclRocm93OiAke2NvbE5hbWV9ID0gJHtTdHJpbmcoY29sTnVtKX0gbWlzc2luZyBpbiB0YWJsZU1hcGApO1xuICB9XG4gIHJldHVybiBjZWxsO1xufVxuZnVuY3Rpb24gJGV4dHJhY3RSZWN0Q29ybmVycyh0YWJsZU1hcCwgYW5jaG9yQ2VsbFZhbHVlLCBuZXdGb2N1c0NlbGxWYWx1ZSkge1xuICAvLyBXZSBhcmUgc3VyZSB0aGF0IHRoZSBmb2N1cyBub3cgZWl0aGVyIGNvbnRyYWN0cyBvciBleHBhbmRzIHRoZSByZWN0XG4gIC8vIGJ1dCBib3RoIHRoZSBhbmNob3IgYW5kIGZvY3VzIG1pZ2h0IGJlIG1vdmVkIHRvIGVuc3VyZSBhIHJlY3RhbmdsZVxuICAvLyBnaXZlbiBhIHBvdGVudGlhbGx5IHJhZ2dlZCBtZXJnZSBzaGFwZVxuICBjb25zdCByZWN0ID0gJGNvbXB1dGVUYWJsZUNlbGxSZWN0Qm91bmRhcnkodGFibGVNYXAsIGFuY2hvckNlbGxWYWx1ZSwgbmV3Rm9jdXNDZWxsVmFsdWUpO1xuICBjb25zdCBhbmNob3JDb3JuZXIgPSBnZXRDb3JuZXIocmVjdCwgYW5jaG9yQ2VsbFZhbHVlKTtcbiAgaWYgKGFuY2hvckNvcm5lcikge1xuICAgIHJldHVybiBbY2VsbEF0Q29ybmVyT3JUaHJvdyh0YWJsZU1hcCwgcmVjdCwgYW5jaG9yQ29ybmVyKSwgY2VsbEF0Q29ybmVyT3JUaHJvdyh0YWJsZU1hcCwgcmVjdCwgb3Bwb3NpdGVDb3JuZXIoYW5jaG9yQ29ybmVyKSldO1xuICB9XG4gIGNvbnN0IG5ld0ZvY3VzQ29ybmVyID0gZ2V0Q29ybmVyKHJlY3QsIG5ld0ZvY3VzQ2VsbFZhbHVlKTtcbiAgaWYgKG5ld0ZvY3VzQ29ybmVyKSB7XG4gICAgcmV0dXJuIFtjZWxsQXRDb3JuZXJPclRocm93KHRhYmxlTWFwLCByZWN0LCBvcHBvc2l0ZUNvcm5lcihuZXdGb2N1c0Nvcm5lcikpLCBjZWxsQXRDb3JuZXJPclRocm93KHRhYmxlTWFwLCByZWN0LCBuZXdGb2N1c0Nvcm5lcildO1xuICB9XG4gIC8vIFRPRE8gdGhpcyBkb2Vzbid0IGhhdmUgdG8gYmUgYXJiaXRyYXJ5LCB1c2UgdGhlIGNsb3Nlc3QgY29ybmVyIGluc3RlYWRcbiAgY29uc3QgbmV3QW5jaG9yQ29ybmVyID0gWydtaW5Db2x1bW4nLCAnbWluUm93J107XG4gIHJldHVybiBbY2VsbEF0Q29ybmVyT3JUaHJvdyh0YWJsZU1hcCwgcmVjdCwgbmV3QW5jaG9yQ29ybmVyKSwgY2VsbEF0Q29ybmVyT3JUaHJvdyh0YWJsZU1hcCwgcmVjdCwgb3Bwb3NpdGVDb3JuZXIobmV3QW5jaG9yQ29ybmVyKSldO1xufVxuZnVuY3Rpb24gJGFkanVzdEZvY3VzSW5EaXJlY3Rpb24odGFibGVPYnNlcnZlciwgdGFibGVNYXAsIGFuY2hvckNlbGxWYWx1ZSwgZm9jdXNDZWxsVmFsdWUsIGRpcmVjdGlvbikge1xuICBjb25zdCByZWN0ID0gJGNvbXB1dGVUYWJsZUNlbGxSZWN0Qm91bmRhcnkodGFibGVNYXAsIGFuY2hvckNlbGxWYWx1ZSwgZm9jdXNDZWxsVmFsdWUpO1xuICBjb25zdCBzcGFucyA9ICRjb21wdXRlVGFibGVDZWxsUmVjdFNwYW5zKHRhYmxlTWFwLCByZWN0KTtcbiAgY29uc3Qge1xuICAgIHRvcFNwYW4sXG4gICAgbGVmdFNwYW4sXG4gICAgYm90dG9tU3BhbixcbiAgICByaWdodFNwYW5cbiAgfSA9IHNwYW5zO1xuICBjb25zdCBhbmNob3JDb3JuZXIgPSBnZXRDb3JuZXJPclRocm93KHJlY3QsIGFuY2hvckNlbGxWYWx1ZSk7XG4gIGNvbnN0IFtmb2N1c0NvbHVtbiwgZm9jdXNSb3ddID0gb3Bwb3NpdGVDb3JuZXIoYW5jaG9yQ29ybmVyKTtcbiAgbGV0IGZDb2wgPSByZWN0W2ZvY3VzQ29sdW1uXTtcbiAgbGV0IGZSb3cgPSByZWN0W2ZvY3VzUm93XTtcbiAgaWYgKGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgZkNvbCArPSBmb2N1c0NvbHVtbiA9PT0gJ21heENvbHVtbicgPyAxIDogbGVmdFNwYW47XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnYmFja3dhcmQnKSB7XG4gICAgZkNvbCAtPSBmb2N1c0NvbHVtbiA9PT0gJ21pbkNvbHVtbicgPyAxIDogcmlnaHRTcGFuO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2Rvd24nKSB7XG4gICAgZlJvdyArPSBmb2N1c1JvdyA9PT0gJ21heFJvdycgPyAxIDogdG9wU3BhbjtcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICd1cCcpIHtcbiAgICBmUm93IC09IGZvY3VzUm93ID09PSAnbWluUm93JyA/IDEgOiBib3R0b21TcGFuO1xuICB9XG4gIGNvbnN0IHRhcmdldFJvd01hcCA9IHRhYmxlTWFwW2ZSb3ddO1xuICBpZiAodGFyZ2V0Um93TWFwID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgbmV3Rm9jdXNDZWxsVmFsdWUgPSB0YXJnZXRSb3dNYXBbZkNvbF07XG4gIGlmIChuZXdGb2N1c0NlbGxWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFdlIGNhbiBiZSBjZXJ0YWluIHRoYXQgYW5jaG9yQ2VsbFZhbHVlIGFuZCBuZXdGb2N1c0NlbGxWYWx1ZSBhcmVcbiAgLy8gY29udGFpbmVkIHdpdGhpbiB0aGUgZGVzaXJlZCBzZWxlY3Rpb24sIGJ1dCB3ZSBhcmUgbm90IGNlcnRhaW4gaWZcbiAgLy8gdGhleSBuZWVkIHRvIGJlIGV4cGFuZGVkIG9yIG5vdCB0byBtYWludGFpbiBhIHJlY3Rhbmd1bGFyIHNoYXBlXG4gIGNvbnN0IFtmaW5hbEFuY2hvckNlbGwsIGZpbmFsRm9jdXNDZWxsXSA9ICRleHRyYWN0UmVjdENvcm5lcnModGFibGVNYXAsIGFuY2hvckNlbGxWYWx1ZSwgbmV3Rm9jdXNDZWxsVmFsdWUpO1xuICBjb25zdCBhbmNob3JET00gPSAkZ2V0T2JzZXJ2ZXJDZWxsRnJvbUNlbGxOb2RlT3JUaHJvdyh0YWJsZU9ic2VydmVyLCBmaW5hbEFuY2hvckNlbGwuY2VsbCk7XG4gIGNvbnN0IGZvY3VzRE9NID0gJGdldE9ic2VydmVyQ2VsbEZyb21DZWxsTm9kZU9yVGhyb3codGFibGVPYnNlcnZlciwgZmluYWxGb2N1c0NlbGwuY2VsbCk7XG4gIHRhYmxlT2JzZXJ2ZXIuJHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oYW5jaG9yRE9NKTtcbiAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGZvY3VzRE9NLCB0cnVlKTtcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiAkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSB7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAvLyBUT0RPIHRoaXMgc2hvdWxkIHByb2JhYmx5IHJldHVybiBmYWxzZSBpZiB0aGVyZSdzIGFuIHVucmVsYXRlZFxuICAgIC8vICAgICAgc2hhZG93IHJvb3QgYmV0d2VlbiB0aGUgbm9kZSBhbmQgdGhlIHRhYmxlIChlLmcuIGFub3RoZXIgdGFibGUsXG4gICAgLy8gICAgICBjb2xsYXBzaWJsZSwgZXRjLilcbiAgICBjb25zdCBpc0FuY2hvckluc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpKTtcbiAgICBjb25zdCBpc0ZvY3VzSW5zaWRlID0gdGFibGVOb2RlLmlzUGFyZW50T2Yoc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKSk7XG4gICAgcmV0dXJuIGlzQW5jaG9ySW5zaWRlICYmIGlzRm9jdXNJbnNpZGU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gJGlzRnVsbFRhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbiwgdGFibGVOb2RlKSB7XG4gIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgaWYgKHRhYmxlTm9kZSAmJiBhbmNob3JOb2RlICYmIGZvY3VzTm9kZSkge1xuICAgICAgY29uc3QgW21hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgYW5jaG9yTm9kZSwgZm9jdXNOb2RlKTtcbiAgICAgIHJldHVybiBhbmNob3JOb2RlLmdldEtleSgpID09PSBtYXBbMF1bMF0uY2VsbC5nZXRLZXkoKSAmJiBmb2N1c05vZGUuZ2V0S2V5KCkgPT09IG1hcFttYXAubGVuZ3RoIC0gMV0uYXQoLTEpLmNlbGwuZ2V0S2V5KCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVDZWxsLCBmcm9tU3RhcnQpIHtcbiAgaWYgKGZyb21TdGFydCkge1xuICAgIHRhYmxlQ2VsbC5zZWxlY3RTdGFydCgpO1xuICB9IGVsc2Uge1xuICAgIHRhYmxlQ2VsbC5zZWxlY3RFbmQoKTtcbiAgfVxufVxuZnVuY3Rpb24gJGFkZEhpZ2hsaWdodFRvRE9NKGVkaXRvciwgY2VsbCkge1xuICBjb25zdCBlbGVtZW50ID0gY2VsbC5lbGVtO1xuICBjb25zdCBlZGl0b3JUaGVtZUNsYXNzZXMgPSBlZGl0b3IuX2NvbmZpZy50aGVtZTtcbiAgY29uc3Qgbm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGVsZW1lbnQpO1xuICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUobm9kZSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIHRvIGZpbmQgTGV4aWNhbE5vZGUgZnJvbSBUYWJsZSBDZWxsIERPTU5vZGVgKTtcbiAgfVxuICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGVkaXRvclRoZW1lQ2xhc3Nlcy50YWJsZUNlbGxTZWxlY3RlZCk7XG59XG5mdW5jdGlvbiAkcmVtb3ZlSGlnaGxpZ2h0RnJvbURPTShlZGl0b3IsIGNlbGwpIHtcbiAgY29uc3QgZWxlbWVudCA9IGNlbGwuZWxlbTtcbiAgY29uc3Qgbm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGVsZW1lbnQpO1xuICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUobm9kZSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIHRvIGZpbmQgTGV4aWNhbE5vZGUgZnJvbSBUYWJsZSBDZWxsIERPTU5vZGVgKTtcbiAgfVxuICBjb25zdCBlZGl0b3JUaGVtZUNsYXNzZXMgPSBlZGl0b3IuX2NvbmZpZy50aGVtZTtcbiAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGVsZW1lbnQsIGVkaXRvclRoZW1lQ2xhc3Nlcy50YWJsZUNlbGxTZWxlY3RlZCk7XG59XG5mdW5jdGlvbiAkZmluZENlbGxOb2RlKG5vZGUpIHtcbiAgY29uc3QgY2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KG5vZGUsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICByZXR1cm4gJGlzVGFibGVDZWxsTm9kZShjZWxsTm9kZSkgPyBjZWxsTm9kZSA6IG51bGw7XG59XG5mdW5jdGlvbiAkZmluZFRhYmxlTm9kZShub2RlKSB7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgJGlzVGFibGVOb2RlKTtcbiAgcmV0dXJuICRpc1RhYmxlTm9kZSh0YWJsZU5vZGUpID8gdGFibGVOb2RlIDogbnVsbDtcbn1cbmZ1bmN0aW9uICRnZXRCbG9ja1BhcmVudElmRmlyc3ROb2RlKG5vZGUpIHtcbiAgZm9yIChsZXQgcHJldk5vZGUgPSBub2RlLCBjdXJyZW50Tm9kZSA9IG5vZGU7IGN1cnJlbnROb2RlICE9PSBudWxsOyBwcmV2Tm9kZSA9IGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmdldFBhcmVudCgpKSB7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgaWYgKGN1cnJlbnROb2RlICE9PSBwcmV2Tm9kZSAmJiBjdXJyZW50Tm9kZS5nZXRGaXJzdENoaWxkKCkgIT09IHByZXZOb2RlKSB7XG4gICAgICAgIC8vIE5vdCB0aGUgZmlyc3QgY2hpbGQgb3IgdGhlIGluaXRpYWwgbm9kZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIWN1cnJlbnROb2RlLmlzSW5saW5lKCkpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRoYW5kbGVIb3Jpem9udGFsQXJyb3dLZXlSYW5nZVNlbGVjdGlvbihlZGl0b3IsIGV2ZW50LCBzZWxlY3Rpb24sIGFsdGVyLCBpc0JhY2t3YXJkLCB0YWJsZU5vZGUsIHRhYmxlT2JzZXJ2ZXIpIHtcbiAgY29uc3QgaW5pdGlhbEZvY3VzID0gJGNhcmV0RnJvbVBvaW50KHNlbGVjdGlvbi5mb2N1cywgaXNCYWNrd2FyZCA/ICdwcmV2aW91cycgOiAnbmV4dCcpO1xuICBpZiAoJGlzRXh0ZW5kYWJsZVRleHRQb2ludENhcmV0KGluaXRpYWxGb2N1cykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGxhc3RDYXJldCA9IGluaXRpYWxGb2N1cztcbiAgLy8gVGFibGVDZWxsTm9kZSBpcyB0aGUgb25seSBzaGFkb3cgcm9vdCB3ZSBhcmUgaW50ZXJlc3RlZCBpbiBwaWVyY2luZyBzb1xuICAvLyB3ZSBmaW5kIHRoZSBsYXN0IGludGVybmFsIGNhcmV0IGFuZCB0aGVuIGNoZWNrIGl0cyBwYXJlbnRcbiAgZm9yIChjb25zdCBuZXh0Q2FyZXQgb2YgJGV4dGVuZENhcmV0VG9SYW5nZShpbml0aWFsRm9jdXMpLml0ZXJOb2RlQ2FyZXRzKCdzaGFkb3dSb290JykpIHtcbiAgICBpZiAoISgkaXNTaWJsaW5nQ2FyZXQobmV4dENhcmV0KSAmJiAkaXNFbGVtZW50Tm9kZShuZXh0Q2FyZXQub3JpZ2luKSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGFzdENhcmV0ID0gbmV4dENhcmV0O1xuICB9XG4gIGNvbnN0IGxhc3RDYXJldFBhcmVudCA9IGxhc3RDYXJldC5nZXRQYXJlbnRBdENhcmV0KCk7XG4gIGlmICghJGlzVGFibGVDZWxsTm9kZShsYXN0Q2FyZXRQYXJlbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFuY2hvckNlbGwgPSBsYXN0Q2FyZXRQYXJlbnQ7XG4gIGNvbnN0IGZvY3VzQ2FyZXQgPSAkZmluZE5leHRUYWJsZUNlbGwoJGdldFNpYmxpbmdDYXJldChhbmNob3JDZWxsLCBsYXN0Q2FyZXQuZGlyZWN0aW9uKSk7XG4gIGNvbnN0IGFuY2hvckNlbGxUYWJsZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yQ2VsbCwgJGlzVGFibGVOb2RlKTtcbiAgaWYgKCEoYW5jaG9yQ2VsbFRhYmxlICYmIGFuY2hvckNlbGxUYWJsZS5pcyh0YWJsZU5vZGUpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhbmNob3JDZWxsRE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3JDZWxsLmdldEtleSgpKTtcbiAgY29uc3QgYW5jaG9yRE9NQ2VsbCA9IGdldERPTUNlbGxGcm9tVGFyZ2V0KGFuY2hvckNlbGxET00pO1xuICBpZiAoIWFuY2hvckNlbGxET00gfHwgIWFuY2hvckRPTUNlbGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYW5jaG9yQ2VsbFRhYmxlRWxlbWVudCA9ICRnZXRFbGVtZW50Rm9yVGFibGVOb2RlKGVkaXRvciwgYW5jaG9yQ2VsbFRhYmxlKTtcbiAgdGFibGVPYnNlcnZlci50YWJsZSA9IGFuY2hvckNlbGxUYWJsZUVsZW1lbnQ7XG4gIGlmICghZm9jdXNDYXJldCkge1xuICAgIGlmIChhbHRlciA9PT0gJ2V4dGVuZCcpIHtcbiAgICAgIC8vIGV4dGVuZCB0aGUgc2VsZWN0aW9uIGZyb20gYSByYW5nZSBpbnNpZGUgdGhlIGNlbGwgdG8gYSB0YWJsZSBzZWxlY3Rpb24gb2YgdGhlIGNlbGxcbiAgICAgIHRhYmxlT2JzZXJ2ZXIuJHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oYW5jaG9yRE9NQ2VsbCk7XG4gICAgICB0YWJsZU9ic2VydmVyLiRzZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oYW5jaG9yRE9NQ2VsbCwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXQgdGhlIHRhYmxlXG4gICAgICBjb25zdCBvdXRlckZvY3VzQ2FyZXQgPSAkZ2V0VGFibGVFeGl0Q2FyZXQoJGdldFNpYmxpbmdDYXJldChhbmNob3JDZWxsVGFibGUsIGluaXRpYWxGb2N1cy5kaXJlY3Rpb24pKTtcbiAgICAgICRzZXRQb2ludEZyb21DYXJldChzZWxlY3Rpb24uYW5jaG9yLCBvdXRlckZvY3VzQ2FyZXQpO1xuICAgICAgJHNldFBvaW50RnJvbUNhcmV0KHNlbGVjdGlvbi5mb2N1cywgb3V0ZXJGb2N1c0NhcmV0KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYWx0ZXIgPT09ICdleHRlbmQnKSB7XG4gICAgY29uc3QgZm9jdXNET01DZWxsID0gZ2V0RE9NQ2VsbEZyb21UYXJnZXQoZWRpdG9yLmdldEVsZW1lbnRCeUtleShmb2N1c0NhcmV0Lm9yaWdpbi5nZXRLZXkoKSkpO1xuICAgIGlmICghZm9jdXNET01DZWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRhYmxlT2JzZXJ2ZXIuJHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oYW5jaG9yRE9NQ2VsbCk7XG4gICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGZvY3VzRE9NQ2VsbCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYWx0ZXIgPT09ICdtb3ZlJ1xuICAgIGNvbnN0IGlubmVyRm9jdXNDYXJldCA9ICRub3JtYWxpemVDYXJldChmb2N1c0NhcmV0KTtcbiAgICAkc2V0UG9pbnRGcm9tQ2FyZXQoc2VsZWN0aW9uLmFuY2hvciwgaW5uZXJGb2N1c0NhcmV0KTtcbiAgICAkc2V0UG9pbnRGcm9tQ2FyZXQoc2VsZWN0aW9uLmZvY3VzLCBpbm5lckZvY3VzQ2FyZXQpO1xuICB9XG4gIHN0b3BFdmVudChldmVudCk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlRXhpdENhcmV0KGluaXRpYWxDYXJldCkge1xuICBjb25zdCBhZGphY2VudCA9ICRnZXRBZGphY2VudENoaWxkQ2FyZXQoaW5pdGlhbENhcmV0KTtcbiAgcmV0dXJuICRpc0NoaWxkQ2FyZXQoYWRqYWNlbnQpID8gJG5vcm1hbGl6ZUNhcmV0KGFkamFjZW50KSA6IGluaXRpYWxDYXJldDtcbn1cbmZ1bmN0aW9uICRmaW5kTmV4dFRhYmxlQ2VsbChpbml0aWFsQ2FyZXQpIHtcbiAgZm9yIChjb25zdCBuZXh0Q2FyZXQgb2YgJGV4dGVuZENhcmV0VG9SYW5nZShpbml0aWFsQ2FyZXQpLml0ZXJOb2RlQ2FyZXRzKCdyb290JykpIHtcbiAgICBjb25zdCB7XG4gICAgICBvcmlnaW5cbiAgICB9ID0gbmV4dENhcmV0O1xuICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKG9yaWdpbikpIHtcbiAgICAgIC8vIG5vdCBzdXJlIHdoeSB0cyBpc24ndCBuYXJyb3dpbmcgaGVyZSAoZXZlbiBpZiB0aGUgZ3VhcmQgaXMgb24gbmV4dENhcmV0Lm9yaWdpbilcbiAgICAgIC8vIGJ1dCByZXR1cm5pbmcgYSBuZXcgY2FyZXQgaXMgZmluZVxuICAgICAgaWYgKCRpc0NoaWxkQ2FyZXQobmV4dENhcmV0KSkge1xuICAgICAgICByZXR1cm4gJGdldENoaWxkQ2FyZXQob3JpZ2luLCBpbml0aWFsQ2FyZXQuZGlyZWN0aW9uKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEkaXNUYWJsZVJvd05vZGUob3JpZ2luKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gJGhhbmRsZUFycm93S2V5KGVkaXRvciwgZXZlbnQsIGRpcmVjdGlvbiwgdGFibGVOb2RlLCB0YWJsZU9ic2VydmVyKSB7XG4gIGlmICgoZGlyZWN0aW9uID09PSAndXAnIHx8IGRpcmVjdGlvbiA9PT0gJ2Rvd24nKSAmJiBpc1R5cGVhaGVhZE1lbnVJblZpZXcoZWRpdG9yKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJykge1xuICAgICAgICBpZiAoc2VsZWN0aW9uLmZvY3VzLm9mZnNldCA+IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9ICRnZXRCbG9ja1BhcmVudElmRmlyc3ROb2RlKHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCkpO1xuICAgICAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2libGluZ05vZGUgPSBwYXJlbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgICBpZiAoISRpc1RhYmxlTm9kZShzaWJsaW5nTm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgc2VsZWN0aW9uLmZvY3VzLnNldChzaWJsaW5nTm9kZS5nZXRQYXJlbnRPclRocm93KCkuZ2V0S2V5KCksIHNpYmxpbmdOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCksICdlbGVtZW50Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2libGluZ05vZGUuc2VsZWN0RW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50LnNoaWZ0S2V5ICYmIChkaXJlY3Rpb24gPT09ICd1cCcgfHwgZGlyZWN0aW9uID09PSAnZG93bicpKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgICAgIGNvbnN0IGlzVGFibGVVbnNlbGVjdCA9ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiAoZGlyZWN0aW9uID09PSAndXAnICYmICFzZWxlY3Rpb24uaXNCYWNrd2FyZCgpIHx8IGRpcmVjdGlvbiA9PT0gJ2Rvd24nICYmIHNlbGVjdGlvbi5pc0JhY2t3YXJkKCkpO1xuICAgICAgICBpZiAoaXNUYWJsZVVuc2VsZWN0KSB7XG4gICAgICAgICAgbGV0IGZvY3VzUGFyZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXNOb2RlLCBuID0+ICRpc1RhYmxlTm9kZShuKSk7XG4gICAgICAgICAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUoZm9jdXNQYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgZm9jdXNQYXJlbnROb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1c1BhcmVudE5vZGUsICRpc1RhYmxlTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb2N1c1BhcmVudE5vZGUgIT09IHRhYmxlTm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWZvY3VzUGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gZGlyZWN0aW9uID09PSAnZG93bicgPyBmb2N1c1BhcmVudE5vZGUuZ2V0TmV4dFNpYmxpbmcoKSA6IGZvY3VzUGFyZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgICAgICBpZiAoIXNpYmxpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IG5ld09mZnNldCA9IDA7XG4gICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ3VwJykge1xuICAgICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICAgIG5ld09mZnNldCA9IHNpYmxpbmcuZ2V0Q2hpbGRyZW5TaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBuZXdGb2N1c05vZGUgPSBzaWJsaW5nO1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd1cCcpIHtcbiAgICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShzaWJsaW5nKSkge1xuICAgICAgICAgICAgICBjb25zdCBsYXN0Q2VsbCA9IHNpYmxpbmcuZ2V0TGFzdENoaWxkKCk7XG4gICAgICAgICAgICAgIG5ld0ZvY3VzTm9kZSA9IGxhc3RDZWxsID8gbGFzdENlbGwgOiBzaWJsaW5nO1xuICAgICAgICAgICAgICBuZXdPZmZzZXQgPSAkaXNUZXh0Tm9kZShuZXdGb2N1c05vZGUpID8gbmV3Rm9jdXNOb2RlLmdldFRleHRDb250ZW50U2l6ZSgpIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gc2VsZWN0aW9uLmNsb25lKCk7XG4gICAgICAgICAgbmV3U2VsZWN0aW9uLmZvY3VzLnNldChuZXdGb2N1c05vZGUuZ2V0S2V5KCksIG5ld09mZnNldCwgJGlzVGV4dE5vZGUobmV3Rm9jdXNOb2RlKSA/ICd0ZXh0JyA6ICdlbGVtZW50Jyk7XG4gICAgICAgICAgJHNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChmb2N1c05vZGUpKSB7XG4gICAgICAgICAgY29uc3Qgc2VsZWN0ZWROb2RlID0gZGlyZWN0aW9uID09PSAndXAnID8gc2VsZWN0aW9uLmdldE5vZGVzKClbc2VsZWN0aW9uLmdldE5vZGVzKCkubGVuZ3RoIC0gMV0gOiBzZWxlY3Rpb24uZ2V0Tm9kZXMoKVswXTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGZpbmRQYXJlbnRUYWJsZUNlbGxOb2RlSW5UYWJsZSh0YWJsZU5vZGUsIHNlbGVjdGVkTm9kZSk7XG4gICAgICAgICAgICBpZiAodGFibGVDZWxsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCBmaXJzdERlc2NlbmRhbnQgPSB0YWJsZU5vZGUuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3REZXNjZW5kYW50ID0gdGFibGVOb2RlLmdldExhc3REZXNjZW5kYW50KCk7XG4gICAgICAgICAgICAgIGlmICghZmlyc3REZXNjZW5kYW50IHx8ICFsYXN0RGVzY2VuZGFudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBbZmlyc3RDZWxsTm9kZV0gPSAkZ2V0Tm9kZVRyaXBsZXQoZmlyc3REZXNjZW5kYW50KTtcbiAgICAgICAgICAgICAgY29uc3QgW2xhc3RDZWxsTm9kZV0gPSAkZ2V0Tm9kZVRyaXBsZXQobGFzdERlc2NlbmRhbnQpO1xuICAgICAgICAgICAgICBjb25zdCBmaXJzdENlbGxDb29yZHMgPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUoZmlyc3RDZWxsTm9kZSwgdGFibGVPYnNlcnZlci50YWJsZSk7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RDZWxsQ29vcmRzID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKGxhc3RDZWxsTm9kZSwgdGFibGVPYnNlcnZlci50YWJsZSk7XG4gICAgICAgICAgICAgIGNvbnN0IGZpcnN0Q2VsbERPTSA9IHRhYmxlTm9kZS5nZXRET01DZWxsRnJvbUNvcmRzT3JUaHJvdyhmaXJzdENlbGxDb29yZHMueCwgZmlyc3RDZWxsQ29vcmRzLnksIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICAgICAgICBjb25zdCBsYXN0Q2VsbERPTSA9IHRhYmxlTm9kZS5nZXRET01DZWxsRnJvbUNvcmRzT3JUaHJvdyhsYXN0Q2VsbENvb3Jkcy54LCBsYXN0Q2VsbENvb3Jkcy55LCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbihmaXJzdENlbGxET00pO1xuICAgICAgICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24obGFzdENlbGxET00sIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBmb2N1c1BhcmVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzTm9kZSwgbiA9PiAkaXNFbGVtZW50Tm9kZShuKSAmJiAhbi5pc0lubGluZSgpKTtcbiAgICAgICAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShmb2N1c1BhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBmb2N1c1BhcmVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzUGFyZW50Tm9kZSwgJGlzVGFibGVOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb2N1c1BhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IGRpcmVjdGlvbiA9PT0gJ2Rvd24nID8gZm9jdXNQYXJlbnROb2RlLmdldE5leHRTaWJsaW5nKCkgOiBmb2N1c1BhcmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgICAgaWYgKCRpc1RhYmxlTm9kZShzaWJsaW5nKSAmJiB0YWJsZU9ic2VydmVyLnRhYmxlTm9kZUtleSA9PT0gc2libGluZy5nZXRLZXkoKSkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3REZXNjZW5kYW50ID0gc2libGluZy5nZXRGaXJzdERlc2NlbmRhbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3REZXNjZW5kYW50ID0gc2libGluZy5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgICAgICAgICAgaWYgKCFmaXJzdERlc2NlbmRhbnQgfHwgIWxhc3REZXNjZW5kYW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtmaXJzdENlbGxOb2RlXSA9ICRnZXROb2RlVHJpcGxldChmaXJzdERlc2NlbmRhbnQpO1xuICAgICAgICAgICAgY29uc3QgW2xhc3RDZWxsTm9kZV0gPSAkZ2V0Tm9kZVRyaXBsZXQobGFzdERlc2NlbmRhbnQpO1xuICAgICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gc2VsZWN0aW9uLmNsb25lKCk7XG4gICAgICAgICAgICBuZXdTZWxlY3Rpb24uZm9jdXMuc2V0KChkaXJlY3Rpb24gPT09ICd1cCcgPyBmaXJzdENlbGxOb2RlIDogbGFzdENlbGxOb2RlKS5nZXRLZXkoKSwgZGlyZWN0aW9uID09PSAndXAnID8gMCA6IGxhc3RDZWxsTm9kZS5nZXRDaGlsZHJlblNpemUoKSwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgICAgICAkc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2Rvd24nICYmICRpc1Njcm9sbGFibGVUYWJsZXNBY3RpdmUoZWRpdG9yKSkge1xuICAgICAgLy8gRW5hYmxlIEZpcmVmb3ggd29ya2Fyb3VuZFxuICAgICAgdGFibGVPYnNlcnZlci5zZXRTaG91bGRDaGVja1NlbGVjdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBpZiAoZGlyZWN0aW9uID09PSAnYmFja3dhcmQnIHx8IGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICBjb25zdCBhbHRlciA9IGV2ZW50LnNoaWZ0S2V5ID8gJ2V4dGVuZCcgOiAnbW92ZSc7XG4gICAgICByZXR1cm4gJGhhbmRsZUhvcml6b250YWxBcnJvd0tleVJhbmdlU2VsZWN0aW9uKGVkaXRvciwgZXZlbnQsIHNlbGVjdGlvbiwgYWx0ZXIsIGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJywgdGFibGVOb2RlLCB0YWJsZU9ic2VydmVyKTtcbiAgICB9XG4gICAgaWYgKHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFuY2hvcixcbiAgICAgICAgZm9jdXNcbiAgICAgIH0gPSBzZWxlY3Rpb247XG4gICAgICBjb25zdCBhbmNob3JDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1cy5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlKSB8fCAhYW5jaG9yQ2VsbE5vZGUuaXMoZm9jdXNDZWxsTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgYW5jaG9yQ2VsbFRhYmxlID0gJGZpbmRUYWJsZU5vZGUoYW5jaG9yQ2VsbE5vZGUpO1xuICAgICAgaWYgKGFuY2hvckNlbGxUYWJsZSAhPT0gdGFibGVOb2RlICYmIGFuY2hvckNlbGxUYWJsZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvckNlbGxUYWJsZUVsZW1lbnQgPSBnZXRUYWJsZUVsZW1lbnQoYW5jaG9yQ2VsbFRhYmxlLCBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGFuY2hvckNlbGxUYWJsZS5nZXRLZXkoKSkpO1xuICAgICAgICBpZiAoYW5jaG9yQ2VsbFRhYmxlRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgdGFibGVPYnNlcnZlci50YWJsZSA9IGdldFRhYmxlKGFuY2hvckNlbGxUYWJsZSwgYW5jaG9yQ2VsbFRhYmxlRWxlbWVudCk7XG4gICAgICAgICAgcmV0dXJuICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCBkaXJlY3Rpb24sIGFuY2hvckNlbGxUYWJsZSwgdGFibGVPYnNlcnZlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGFuY2hvckNlbGxEb20gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGFuY2hvckNlbGxOb2RlLl9fa2V5KTtcbiAgICAgIGNvbnN0IGFuY2hvckRPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yLmtleSk7XG4gICAgICBpZiAoYW5jaG9yRE9NID09IG51bGwgfHwgYW5jaG9yQ2VsbERvbSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGxldCBlZGdlU2VsZWN0aW9uUmVjdDtcbiAgICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnKSB7XG4gICAgICAgIGVkZ2VTZWxlY3Rpb25SZWN0ID0gYW5jaG9yRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGdldEVkaXRvcldpbmRvdyhlZGl0b3IpKTtcbiAgICAgICAgaWYgKGRvbVNlbGVjdGlvbiA9PT0gbnVsbCB8fCBkb21TZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYW5nZSA9IGRvbVNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgICBlZGdlU2VsZWN0aW9uUmVjdCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRnZUNoaWxkID0gZGlyZWN0aW9uID09PSAndXAnID8gYW5jaG9yQ2VsbE5vZGUuZ2V0Rmlyc3RDaGlsZCgpIDogYW5jaG9yQ2VsbE5vZGUuZ2V0TGFzdENoaWxkKCk7XG4gICAgICBpZiAoZWRnZUNoaWxkID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRnZUNoaWxkRE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShlZGdlQ2hpbGQuX19rZXkpO1xuICAgICAgaWYgKGVkZ2VDaGlsZERPTSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkZ2VSZWN0ID0gZWRnZUNoaWxkRE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgY29uc3QgaXNFeGl0aW5nID0gZGlyZWN0aW9uID09PSAndXAnID8gZWRnZVJlY3QudG9wID4gZWRnZVNlbGVjdGlvblJlY3QudG9wIC0gZWRnZVNlbGVjdGlvblJlY3QuaGVpZ2h0IDogZWRnZVNlbGVjdGlvblJlY3QuYm90dG9tICsgZWRnZVNlbGVjdGlvblJlY3QuaGVpZ2h0ID4gZWRnZVJlY3QuYm90dG9tO1xuICAgICAgaWYgKGlzRXhpdGluZykge1xuICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICBjb25zdCBjb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZShhbmNob3JDZWxsTm9kZSwgdGFibGVPYnNlcnZlci50YWJsZSk7XG4gICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgIGNvbnN0IGNlbGwgPSB0YWJsZU5vZGUuZ2V0RE9NQ2VsbEZyb21Db3Jkc09yVGhyb3coY29yZHMueCwgY29yZHMueSwgdGFibGVPYnNlcnZlci50YWJsZSk7XG4gICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbihjZWxsKTtcbiAgICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oY2VsbCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGVjdFRhYmxlTm9kZUluRGlyZWN0aW9uKHRhYmxlT2JzZXJ2ZXIsIHRhYmxlTm9kZSwgY29yZHMueCwgY29yZHMueSwgZGlyZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCBhbmNob3JDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgY29uc3QgZm9jdXNDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXMuZ2V0Tm9kZSgpLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICBjb25zdCBbdGFibGVOb2RlRnJvbVNlbGVjdGlvbl0gPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgICBpZiAoISRpc1RhYmxlTm9kZSh0YWJsZU5vZGVGcm9tU2VsZWN0aW9uKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkaGFuZGxlQXJyb3dLZXk6IFRhYmxlU2VsZWN0aW9uLmdldE5vZGVzKClbMF0gZXhwZWN0ZWQgdG8gYmUgVGFibGVOb2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGdldFRhYmxlRWxlbWVudCh0YWJsZU5vZGVGcm9tU2VsZWN0aW9uLCBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRhYmxlTm9kZUZyb21TZWxlY3Rpb24uZ2V0S2V5KCkpKTtcbiAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoYW5jaG9yQ2VsbE5vZGUpIHx8ICEkaXNUYWJsZUNlbGxOb2RlKGZvY3VzQ2VsbE5vZGUpIHx8ICEkaXNUYWJsZU5vZGUodGFibGVOb2RlRnJvbVNlbGVjdGlvbikgfHwgdGFibGVFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGFibGVPYnNlcnZlci4kdXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGNvbnN0IGdyaWQgPSBnZXRUYWJsZSh0YWJsZU5vZGVGcm9tU2VsZWN0aW9uLCB0YWJsZUVsZW1lbnQpO1xuICAgIGNvbnN0IGNvcmRzQW5jaG9yID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlLCBncmlkKTtcbiAgICBjb25zdCBhbmNob3JDZWxsID0gdGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KGNvcmRzQW5jaG9yLngsIGNvcmRzQW5jaG9yLnksIGdyaWQpO1xuICAgIHRhYmxlT2JzZXJ2ZXIuJHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oYW5jaG9yQ2VsbCk7XG4gICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgIGNvbnN0IFt0YWJsZU1hcCwgYW5jaG9yVmFsdWUsIGZvY3VzVmFsdWVdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvckNlbGxOb2RlLCBmb2N1c0NlbGxOb2RlKTtcbiAgICAgIHJldHVybiAkYWRqdXN0Rm9jdXNJbkRpcmVjdGlvbih0YWJsZU9ic2VydmVyLCB0YWJsZU1hcCwgYW5jaG9yVmFsdWUsIGZvY3VzVmFsdWUsIGRpcmVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvY3VzQ2VsbE5vZGUuc2VsZWN0RW5kKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN0b3BFdmVudChldmVudCkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG59XG5mdW5jdGlvbiBpc1R5cGVhaGVhZE1lbnVJblZpZXcoZWRpdG9yKSB7XG4gIC8vIFRoZXJlIGlzIG5vIGluYnVpbHQgd2F5IHRvIGNoZWNrIGlmIHRoZSBjb21wb25lbnQgcGlja2VyIGlzIGluIHZpZXdcbiAgLy8gYnV0IHdlIGNhbiBjaGVjayBpZiB0aGUgcm9vdCBET00gZWxlbWVudCBoYXMgdGhlIGFyaWEtY29udHJvbHMgYXR0cmlidXRlIFwidHlwZWFoZWFkLW1lbnVcIi5cbiAgY29uc3Qgcm9vdCA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICBpZiAoIXJvb3QpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHJvb3QuaGFzQXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJykgJiYgcm9vdC5nZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnKSA9PT0gJ3R5cGVhaGVhZC1tZW51Jztcbn1cbmZ1bmN0aW9uICRpbnNlcnRQYXJhZ3JhcGhBdFRhYmxlRWRnZShlZGdlUG9zaXRpb24sIHRhYmxlTm9kZSwgY2hpbGRyZW4pIHtcbiAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gIGlmIChlZGdlUG9zaXRpb24gPT09ICdmaXJzdCcpIHtcbiAgICB0YWJsZU5vZGUuaW5zZXJ0QmVmb3JlKHBhcmFncmFwaE5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHRhYmxlTm9kZS5pbnNlcnRBZnRlcihwYXJhZ3JhcGhOb2RlKTtcbiAgfVxuICBwYXJhZ3JhcGhOb2RlLmFwcGVuZCguLi4oY2hpbGRyZW4gfHwgW10pKTtcbiAgcGFyYWdyYXBoTm9kZS5zZWxlY3RFbmQoKTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZUVkZ2VDdXJzb3JQb3NpdGlvbihlZGl0b3IsIHNlbGVjdGlvbiwgdGFibGVOb2RlKSB7XG4gIGNvbnN0IHRhYmxlTm9kZVBhcmVudCA9IHRhYmxlTm9kZS5nZXRQYXJlbnQoKTtcbiAgaWYgKCF0YWJsZU5vZGVQYXJlbnQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gVE9ETzogQWRkIHN1cHBvcnQgZm9yIG5lc3RlZCB0YWJsZXNcbiAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKGdldEVkaXRvcldpbmRvdyhlZGl0b3IpKTtcbiAgaWYgKCFkb21TZWxlY3Rpb24pIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IGRvbUFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgY29uc3QgdGFibGVOb2RlUGFyZW50RE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0YWJsZU5vZGVQYXJlbnQuZ2V0S2V5KCkpO1xuICBjb25zdCB0YWJsZUVsZW1lbnQgPSBnZXRUYWJsZUVsZW1lbnQodGFibGVOb2RlLCBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRhYmxlTm9kZS5nZXRLZXkoKSkpO1xuICAvLyBXZSBhcmUgb25seSBpbnRlcmVzdGVkIGluIHRoZSBzY2VuYXJpbyB3aGVyZSB0aGVcbiAgLy8gbmF0aXZlIHNlbGVjdGlvbiBhbmNob3IgaXM6XG4gIC8vIC0gYXQgb3IgaW5zaWRlIHRoZSB0YWJsZSdzIHBhcmVudCBET01cbiAgLy8gLSBhbmQgTk9UIGF0IG9yIGluc2lkZSB0aGUgdGFibGUgRE9NXG4gIC8vIEl0IG1heSBiZSBhZGphY2VudCB0byB0aGUgdGFibGUgRE9NIChlLmcuIGluIGEgd3JhcHBlcilcbiAgaWYgKCFkb21BbmNob3JOb2RlIHx8ICF0YWJsZU5vZGVQYXJlbnRET00gfHwgIXRhYmxlRWxlbWVudCB8fCAhdGFibGVOb2RlUGFyZW50RE9NLmNvbnRhaW5zKGRvbUFuY2hvck5vZGUpIHx8IHRhYmxlRWxlbWVudC5jb250YWlucyhkb21BbmNob3JOb2RlKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpO1xuICBpZiAoIWFuY2hvckNlbGxOb2RlKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBwYXJlbnRUYWJsZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yQ2VsbE5vZGUsIG4gPT4gJGlzVGFibGVOb2RlKG4pKTtcbiAgaWYgKCEkaXNUYWJsZU5vZGUocGFyZW50VGFibGUpIHx8ICFwYXJlbnRUYWJsZS5pcyh0YWJsZU5vZGUpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBbdGFibGVNYXAsIGNlbGxWYWx1ZV0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgYW5jaG9yQ2VsbE5vZGUsIGFuY2hvckNlbGxOb2RlKTtcbiAgY29uc3QgZmlyc3RDZWxsID0gdGFibGVNYXBbMF1bMF07XG4gIGNvbnN0IGxhc3RDZWxsID0gdGFibGVNYXBbdGFibGVNYXAubGVuZ3RoIC0gMV1bdGFibGVNYXBbMF0ubGVuZ3RoIC0gMV07XG4gIGNvbnN0IHtcbiAgICBzdGFydFJvdyxcbiAgICBzdGFydENvbHVtblxuICB9ID0gY2VsbFZhbHVlO1xuICBjb25zdCBpc0F0Rmlyc3RDZWxsID0gc3RhcnRSb3cgPT09IGZpcnN0Q2VsbC5zdGFydFJvdyAmJiBzdGFydENvbHVtbiA9PT0gZmlyc3RDZWxsLnN0YXJ0Q29sdW1uO1xuICBjb25zdCBpc0F0TGFzdENlbGwgPSBzdGFydFJvdyA9PT0gbGFzdENlbGwuc3RhcnRSb3cgJiYgc3RhcnRDb2x1bW4gPT09IGxhc3RDZWxsLnN0YXJ0Q29sdW1uO1xuICBpZiAoaXNBdEZpcnN0Q2VsbCkge1xuICAgIHJldHVybiAnZmlyc3QnO1xuICB9IGVsc2UgaWYgKGlzQXRMYXN0Q2VsbCkge1xuICAgIHJldHVybiAnbGFzdCc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuZnVuY3Rpb24gJGdldE9ic2VydmVyQ2VsbEZyb21DZWxsTm9kZU9yVGhyb3codGFibGVPYnNlcnZlciwgdGFibGVDZWxsTm9kZSkge1xuICBjb25zdCB7XG4gICAgdGFibGVOb2RlXG4gIH0gPSB0YWJsZU9ic2VydmVyLiRsb29rdXAoKTtcbiAgY29uc3QgY3VycmVudENvcmRzID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICByZXR1cm4gdGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KGN1cnJlbnRDb3Jkcy54LCBjdXJyZW50Q29yZHMueSwgdGFibGVPYnNlcnZlci50YWJsZSk7XG59XG5mdW5jdGlvbiAkZ2V0TmVhcmVzdFRhYmxlQ2VsbEluVGFibGVGcm9tRE9NTm9kZSh0YWJsZU5vZGUsIHN0YXJ0aW5nRE9NLCBlZGl0b3JTdGF0ZSkge1xuICByZXR1cm4gJGZpbmRQYXJlbnRUYWJsZUNlbGxOb2RlSW5UYWJsZSh0YWJsZU5vZGUsICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKHN0YXJ0aW5nRE9NLCBlZGl0b3JTdGF0ZSkpO1xufVxuXG5mdW5jdGlvbiBpc0hUTUxEaXZFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGlzSFRNTEVsZW1lbnQkMShlbGVtZW50KSAmJiBlbGVtZW50Lm5vZGVOYW1lID09PSAnRElWJztcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbGdyb3VwKGRvbSwgY29uZmlnLCBjb2xDb3VudCwgY29sV2lkdGhzKSB7XG4gIGNvbnN0IGNvbEdyb3VwID0gZG9tLnF1ZXJ5U2VsZWN0b3IoJ2NvbGdyb3VwJyk7XG4gIGlmICghY29sR3JvdXApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY29scyA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbENvdW50OyBpKyspIHtcbiAgICBjb25zdCBjb2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2wnKTtcbiAgICBjb25zdCB3aWR0aCA9IGNvbFdpZHRocyAmJiBjb2xXaWR0aHNbaV07XG4gICAgaWYgKHdpZHRoKSB7XG4gICAgICBjb2wuc3R5bGUud2lkdGggPSBgJHt3aWR0aH1weGA7XG4gICAgfVxuICAgIGNvbHMucHVzaChjb2wpO1xuICB9XG4gIGNvbEdyb3VwLnJlcGxhY2VDaGlsZHJlbiguLi5jb2xzKTtcbn1cbmZ1bmN0aW9uIHNldFJvd1N0cmlwaW5nKGRvbSwgY29uZmlnLCByb3dTdHJpcGluZykge1xuICBpZiAocm93U3RyaXBpbmcpIHtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGRvbSwgY29uZmlnLnRoZW1lLnRhYmxlUm93U3RyaXBpbmcpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1yb3ctc3RyaXBpbmcnLCAndHJ1ZScpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChkb20sIGNvbmZpZy50aGVtZS50YWJsZVJvd1N0cmlwaW5nKTtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWxleGljYWwtcm93LXN0cmlwaW5nJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEZyb3plbkNvbHVtbnMoZG9tLCB0YWJsZUVsZW1lbnQsIGNvbmZpZywgZnJvemVuQ29sdW1uQ291bnQpIHtcbiAgaWYgKGZyb3plbkNvbHVtbkNvdW50ID4gMCkge1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCBjb25maWcudGhlbWUudGFibGVGcm96ZW5Db2x1bW4pO1xuICAgIHRhYmxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1mcm96ZW4tY29sdW1uJywgJ3RydWUnKTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCBjb25maWcudGhlbWUudGFibGVGcm96ZW5Db2x1bW4pO1xuICAgIHRhYmxlRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1mcm96ZW4tY29sdW1uJyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEZyb3plblJvd3MoZG9tLCB0YWJsZUVsZW1lbnQsIGNvbmZpZywgZnJvemVuUm93Q291bnQpIHtcbiAgaWYgKGZyb3plblJvd0NvdW50ID4gMCkge1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCBjb25maWcudGhlbWUudGFibGVGcm96ZW5Sb3cpO1xuICAgIHRhYmxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1mcm96ZW4tcm93JywgJ3RydWUnKTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCBjb25maWcudGhlbWUudGFibGVGcm96ZW5Sb3cpO1xuICAgIHRhYmxlRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtbGV4aWNhbC1mcm96ZW4tcm93Jyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFsaWduVGFibGVFbGVtZW50KGRvbSwgY29uZmlnLCBmb3JtYXRUeXBlKSB7XG4gIGlmICghY29uZmlnLnRoZW1lLnRhYmxlQWxpZ25tZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlbW92ZUNsYXNzZXMgPSBbXTtcbiAgY29uc3QgYWRkQ2xhc3NlcyA9IFtdO1xuICBmb3IgKGNvbnN0IGZvcm1hdCBvZiBbJ2NlbnRlcicsICdyaWdodCddKSB7XG4gICAgY29uc3QgY2xhc3NlcyA9IGNvbmZpZy50aGVtZS50YWJsZUFsaWdubWVudFtmb3JtYXRdO1xuICAgIGlmICghY2xhc3Nlcykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIChmb3JtYXQgPT09IGZvcm1hdFR5cGUgPyBhZGRDbGFzc2VzIDogcmVtb3ZlQ2xhc3NlcykucHVzaChjbGFzc2VzKTtcbiAgfVxuICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCAuLi5yZW1vdmVDbGFzc2VzKTtcbiAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChkb20sIC4uLmFkZENsYXNzZXMpO1xufVxuY29uc3Qgc2Nyb2xsYWJsZUVkaXRvcnMgPSBuZXcgV2Vha1NldCgpO1xuZnVuY3Rpb24gJGlzU2Nyb2xsYWJsZVRhYmxlc0FjdGl2ZShlZGl0b3IgPSAkZ2V0RWRpdG9yKCkpIHtcbiAgcmV0dXJuIHNjcm9sbGFibGVFZGl0b3JzLmhhcyhlZGl0b3IpO1xufVxuZnVuY3Rpb24gc2V0U2Nyb2xsYWJsZVRhYmxlc0FjdGl2ZShlZGl0b3IsIGFjdGl2ZSkge1xuICBpZiAoYWN0aXZlKSB7XG4gICAgaWYgKCFlZGl0b3IuX2NvbmZpZy50aGVtZS50YWJsZVNjcm9sbGFibGVXcmFwcGVyKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1RhYmxlTm9kZTogaGFzSG9yaXpvbnRhbFNjcm9sbCBpcyBhY3RpdmUgYnV0IHRoZW1lLnRhYmxlU2Nyb2xsYWJsZVdyYXBwZXIgaXMgbm90IGRlZmluZWQuJyk7XG4gICAgfVxuICAgIHNjcm9sbGFibGVFZGl0b3JzLmFkZChlZGl0b3IpO1xuICB9IGVsc2Uge1xuICAgIHNjcm9sbGFibGVFZGl0b3JzLmRlbGV0ZShlZGl0b3IpO1xuICB9XG59XG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBUYWJsZU5vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3RhYmxlJztcbiAgfVxuICBnZXRDb2xXaWR0aHMoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgcmV0dXJuIHNlbGYuX19jb2xXaWR0aHM7XG4gIH1cbiAgc2V0Q29sV2lkdGhzKGNvbFdpZHRocykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgLy8gTk9URTogTm9kZSBwcm9wZXJ0aWVzIHNob3VsZCBiZSBpbW11dGFibGUuIEZyZWV6ZSB0byBwcmV2ZW50IGFjY2lkZW50YWwgbXV0YXRpb24uXG4gICAgc2VsZi5fX2NvbFdpZHRocyA9IGNvbFdpZHRocyAhPT0gdW5kZWZpbmVkICYmIHRydWUgPyBPYmplY3QuZnJlZXplKGNvbFdpZHRocykgOiBjb2xXaWR0aHM7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFRhYmxlTm9kZShub2RlLl9fa2V5KTtcbiAgfVxuICBhZnRlckNsb25lRnJvbShwcmV2Tm9kZSkge1xuICAgIHN1cGVyLmFmdGVyQ2xvbmVGcm9tKHByZXZOb2RlKTtcbiAgICB0aGlzLl9fY29sV2lkdGhzID0gcHJldk5vZGUuX19jb2xXaWR0aHM7XG4gICAgdGhpcy5fX3Jvd1N0cmlwaW5nID0gcHJldk5vZGUuX19yb3dTdHJpcGluZztcbiAgICB0aGlzLl9fZnJvemVuQ29sdW1uQ291bnQgPSBwcmV2Tm9kZS5fX2Zyb3plbkNvbHVtbkNvdW50O1xuICAgIHRoaXMuX19mcm96ZW5Sb3dDb3VudCA9IHByZXZOb2RlLl9fZnJvemVuUm93Q291bnQ7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFibGU6IF9ub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGFibGVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVUYWJsZU5vZGUoKS51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSk7XG4gIH1cbiAgdXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpLnNldFJvd1N0cmlwaW5nKHNlcmlhbGl6ZWROb2RlLnJvd1N0cmlwaW5nIHx8IGZhbHNlKS5zZXRGcm96ZW5Db2x1bW5zKHNlcmlhbGl6ZWROb2RlLmZyb3plbkNvbHVtbkNvdW50IHx8IDApLnNldEZyb3plblJvd3Moc2VyaWFsaXplZE5vZGUuZnJvemVuUm93Q291bnQgfHwgMCkuc2V0Q29sV2lkdGhzKHNlcmlhbGl6ZWROb2RlLmNvbFdpZHRocyk7XG4gIH1cbiAgY29uc3RydWN0b3Ioa2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9fcm93U3RyaXBpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9fZnJvemVuQ29sdW1uQ291bnQgPSAwO1xuICAgIHRoaXMuX19mcm96ZW5Sb3dDb3VudCA9IDA7XG4gIH1cbiAgZXhwb3J0SlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgY29sV2lkdGhzOiB0aGlzLmdldENvbFdpZHRocygpLFxuICAgICAgZnJvemVuQ29sdW1uQ291bnQ6IHRoaXMuX19mcm96ZW5Db2x1bW5Db3VudCA/IHRoaXMuX19mcm96ZW5Db2x1bW5Db3VudCA6IHVuZGVmaW5lZCxcbiAgICAgIGZyb3plblJvd0NvdW50OiB0aGlzLl9fZnJvemVuUm93Q291bnQgPyB0aGlzLl9fZnJvemVuUm93Q291bnQgOiB1bmRlZmluZWQsXG4gICAgICByb3dTdHJpcGluZzogdGhpcy5fX3Jvd1N0cmlwaW5nID8gdGhpcy5fX3Jvd1N0cmlwaW5nIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkLCBzZWxlY3Rpb24sIGRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uID09PSAnaHRtbCc7XG4gIH1cbiAgZ2V0RE9NU2xvdChlbGVtZW50KSB7XG4gICAgY29uc3QgdGFibGVFbGVtZW50ID0gIWlzSFRNTFRhYmxlRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQucXVlcnlTZWxlY3RvcigndGFibGUnKSA6IGVsZW1lbnQ7XG4gICAgaWYgKCFpc0hUTUxUYWJsZUVsZW1lbnQodGFibGVFbGVtZW50KSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBUYWJsZU5vZGUuZ2V0RE9NU2xvdDogY3JlYXRlRE9NKCkgZGlkIG5vdCByZXR1cm4gYSB0YWJsZWApO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZ2V0RE9NU2xvdChlbGVtZW50KS53aXRoRWxlbWVudCh0YWJsZUVsZW1lbnQpLndpdGhBZnRlcih0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvcignY29sZ3JvdXAnKSk7XG4gIH1cbiAgY3JlYXRlRE9NKGNvbmZpZywgZWRpdG9yKSB7XG4gICAgY29uc3QgdGFibGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcbiAgICBpZiAodGhpcy5fX3N0eWxlKSB7XG4gICAgICB0YWJsZUVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHRoaXMuX19zdHlsZTtcbiAgICB9XG4gICAgY29uc3QgY29sR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjb2xncm91cCcpO1xuICAgIHRhYmxlRWxlbWVudC5hcHBlbmRDaGlsZChjb2xHcm91cCk7XG4gICAgc2V0RE9NVW5tYW5hZ2VkKGNvbEdyb3VwKTtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KHRhYmxlRWxlbWVudCwgY29uZmlnLnRoZW1lLnRhYmxlKTtcbiAgICB0aGlzLnVwZGF0ZVRhYmxlRWxlbWVudChudWxsLCB0YWJsZUVsZW1lbnQsIGNvbmZpZyk7XG4gICAgaWYgKCRpc1Njcm9sbGFibGVUYWJsZXNBY3RpdmUoZWRpdG9yKSkge1xuICAgICAgY29uc3Qgd3JhcHBlckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbnN0IGNsYXNzZXMgPSBjb25maWcudGhlbWUudGFibGVTY3JvbGxhYmxlV3JhcHBlcjtcbiAgICAgIGlmIChjbGFzc2VzKSB7XG4gICAgICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQod3JhcHBlckVsZW1lbnQsIGNsYXNzZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd3JhcHBlckVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9ICdvdmVyZmxvdy14OiBhdXRvOyc7XG4gICAgICB9XG4gICAgICB3cmFwcGVyRWxlbWVudC5hcHBlbmRDaGlsZCh0YWJsZUVsZW1lbnQpO1xuICAgICAgdGhpcy51cGRhdGVUYWJsZVdyYXBwZXIobnVsbCwgd3JhcHBlckVsZW1lbnQsIHRhYmxlRWxlbWVudCwgY29uZmlnKTtcbiAgICAgIHJldHVybiB3cmFwcGVyRWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRhYmxlRWxlbWVudDtcbiAgfVxuICB1cGRhdGVUYWJsZVdyYXBwZXIocHJldk5vZGUsIHRhYmxlV3JhcHBlciwgdGFibGVFbGVtZW50LCBjb25maWcpIHtcbiAgICBpZiAodGhpcy5fX2Zyb3plbkNvbHVtbkNvdW50ICE9PSAocHJldk5vZGUgPyBwcmV2Tm9kZS5fX2Zyb3plbkNvbHVtbkNvdW50IDogMCkpIHtcbiAgICAgIHNldEZyb3plbkNvbHVtbnModGFibGVXcmFwcGVyLCB0YWJsZUVsZW1lbnQsIGNvbmZpZywgdGhpcy5fX2Zyb3plbkNvbHVtbkNvdW50KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX19mcm96ZW5Sb3dDb3VudCAhPT0gKHByZXZOb2RlID8gcHJldk5vZGUuX19mcm96ZW5Sb3dDb3VudCA6IDApKSB7XG4gICAgICBzZXRGcm96ZW5Sb3dzKHRhYmxlV3JhcHBlciwgdGFibGVFbGVtZW50LCBjb25maWcsIHRoaXMuX19mcm96ZW5Sb3dDb3VudCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRhYmxlRWxlbWVudChwcmV2Tm9kZSwgdGFibGVFbGVtZW50LCBjb25maWcpIHtcbiAgICBpZiAodGhpcy5fX3N0eWxlICE9PSAocHJldk5vZGUgPyBwcmV2Tm9kZS5fX3N0eWxlIDogJycpKSB7XG4gICAgICB0YWJsZUVsZW1lbnQuc3R5bGUuY3NzVGV4dCA9IHRoaXMuX19zdHlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX19yb3dTdHJpcGluZyAhPT0gKHByZXZOb2RlID8gcHJldk5vZGUuX19yb3dTdHJpcGluZyA6IGZhbHNlKSkge1xuICAgICAgc2V0Um93U3RyaXBpbmcodGFibGVFbGVtZW50LCBjb25maWcsIHRoaXMuX19yb3dTdHJpcGluZyk7XG4gICAgfVxuICAgIHVwZGF0ZUNvbGdyb3VwKHRhYmxlRWxlbWVudCwgY29uZmlnLCB0aGlzLmdldENvbHVtbkNvdW50KCksIHRoaXMuZ2V0Q29sV2lkdGhzKCkpO1xuICAgIGFsaWduVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgY29uZmlnLCB0aGlzLmdldEZvcm1hdFR5cGUoKSk7XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZykge1xuICAgIGNvbnN0IHNsb3QgPSB0aGlzLmdldERPTVNsb3QoZG9tKTtcbiAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBzbG90LmVsZW1lbnQ7XG4gICAgaWYgKGRvbSA9PT0gdGFibGVFbGVtZW50ID09PSAkaXNTY3JvbGxhYmxlVGFibGVzQWN0aXZlKCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNIVE1MRGl2RWxlbWVudChkb20pKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRhYmxlV3JhcHBlcihwcmV2Tm9kZSwgZG9tLCB0YWJsZUVsZW1lbnQsIGNvbmZpZyk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlVGFibGVFbGVtZW50KHByZXZOb2RlLCB0YWJsZUVsZW1lbnQsIGNvbmZpZyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGV4cG9ydERPTShlZGl0b3IpIHtcbiAgICBjb25zdCBzdXBlckV4cG9ydCA9IHN1cGVyLmV4cG9ydERPTShlZGl0b3IpO1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gc3VwZXJFeHBvcnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFmdGVyOiB0YWJsZUVsZW1lbnQgPT4ge1xuICAgICAgICBpZiAoc3VwZXJFeHBvcnQuYWZ0ZXIpIHtcbiAgICAgICAgICB0YWJsZUVsZW1lbnQgPSBzdXBlckV4cG9ydC5hZnRlcih0YWJsZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNIVE1MVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCkgJiYgaXNIVE1MRWxlbWVudCQxKHRhYmxlRWxlbWVudCkpIHtcbiAgICAgICAgICB0YWJsZUVsZW1lbnQgPSB0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndGFibGUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSFRNTFRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQpKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYWxpZ25UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50LCBlZGl0b3IuX2NvbmZpZywgdGhpcy5nZXRGb3JtYXRUeXBlKCkpO1xuXG4gICAgICAgIC8vIFNjYW4gdGhlIHRhYmxlIG1hcCB0byBidWlsZCBhIG1hcCBvZiB0YWJsZSBjZWxsIGtleSB0byB0aGUgY29sdW1ucyBpdCBuZWVkc1xuICAgICAgICBjb25zdCBbdGFibGVNYXBdID0gJGNvbXB1dGVUYWJsZU1hcFNraXBDZWxsQ2hlY2sodGhpcywgbnVsbCwgbnVsbCk7XG4gICAgICAgIGNvbnN0IGNlbGxWYWx1ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgbWFwUm93IG9mIHRhYmxlTWFwKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBtYXBWYWx1ZSBvZiBtYXBSb3cpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IG1hcFZhbHVlLmNlbGwuZ2V0S2V5KCk7XG4gICAgICAgICAgICBpZiAoIWNlbGxWYWx1ZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgY2VsbFZhbHVlcy5zZXQoa2V5LCB7XG4gICAgICAgICAgICAgICAgY29sU3BhbjogbWFwVmFsdWUuY2VsbC5nZXRDb2xTcGFuKCksXG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IG1hcFZhbHVlLnN0YXJ0Q29sdW1uXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjYW4gdGhlIERPTSB0byBmaW5kIHRoZSB0YWJsZSBjZWxsIGtleXMgdGhhdCB3ZXJlIHVzZWQgYW5kIG1hcmsgdGhvc2UgY29sdW1uc1xuICAgICAgICBjb25zdCBrbm93bkNvbHVtbnMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgY2VsbERPTSBvZiB0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnOnNjb3BlID4gdHIgPiBbZGF0YS10ZW1wb3JhcnktdGFibGUtY2VsbC1sZXhpY2FsLWtleV0nKSkge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGNlbGxET00uZ2V0QXR0cmlidXRlKCdkYXRhLXRlbXBvcmFyeS10YWJsZS1jZWxsLWxleGljYWwta2V5Jyk7XG4gICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgY29uc3QgY2VsbFNwYW4gPSBjZWxsVmFsdWVzLmdldChrZXkpO1xuICAgICAgICAgICAgY2VsbERPTS5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtdGVtcG9yYXJ5LXRhYmxlLWNlbGwtbGV4aWNhbC1rZXknKTtcbiAgICAgICAgICAgIGlmIChjZWxsU3Bhbikge1xuICAgICAgICAgICAgICBjZWxsVmFsdWVzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbGxTcGFuLmNvbFNwYW47IGkrKykge1xuICAgICAgICAgICAgICAgIGtub3duQ29sdW1ucy5hZGQoaSArIGNlbGxTcGFuLnN0YXJ0Q29sdW1uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbXB1dGUgdGhlIGNvbGdyb3VwIGFuZCBjb2x1bW5zIGluIHRoZSBleHBvcnRcbiAgICAgICAgY29uc3QgY29sR3JvdXAgPSB0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvcignOnNjb3BlID4gY29sZ3JvdXAnKTtcbiAgICAgICAgaWYgKGNvbEdyb3VwKSB7XG4gICAgICAgICAgLy8gT25seSBpbmNsdWRlIHRoZSA8Y29sIC8+IGZvciByb3dzIHRoYXQgYXJlIGluIHRoZSBvdXRwdXRcbiAgICAgICAgICBjb25zdCBjb2xzID0gQXJyYXkuZnJvbSh0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnOnNjb3BlID4gY29sZ3JvdXAgPiBjb2wnKSkuZmlsdGVyKChkb20sIGkpID0+IGtub3duQ29sdW1ucy5oYXMoaSkpO1xuICAgICAgICAgIGNvbEdyb3VwLnJlcGxhY2VDaGlsZHJlbiguLi5jb2xzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyYXAgZGlyZWN0IGRlc2NlbmRhbnQgcm93cyBpbiBhIHRib2R5IGZvciBleHBvcnRcbiAgICAgICAgY29uc3Qgcm93cyA9IHRhYmxlRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCc6c2NvcGUgPiB0cicpO1xuICAgICAgICBpZiAocm93cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgdEJvZHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0Ym9keScpO1xuICAgICAgICAgIGZvciAoY29uc3Qgcm93IG9mIHJvd3MpIHtcbiAgICAgICAgICAgIHRCb2R5LmFwcGVuZENoaWxkKHJvdyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRhYmxlRWxlbWVudC5hcHBlbmQodEJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YWJsZUVsZW1lbnQ7XG4gICAgICB9LFxuICAgICAgZWxlbWVudDogIWlzSFRNTFRhYmxlRWxlbWVudChlbGVtZW50KSAmJiBpc0hUTUxFbGVtZW50JDEoZWxlbWVudCkgPyBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJykgOiBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc1NoYWRvd1Jvb3QoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0Q29yZHNGcm9tQ2VsbE5vZGUodGFibGVDZWxsTm9kZSwgdGFibGUpIHtcbiAgICBjb25zdCB7XG4gICAgICByb3dzLFxuICAgICAgZG9tUm93c1xuICAgIH0gPSB0YWJsZTtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHJvd3M7IHkrKykge1xuICAgICAgY29uc3Qgcm93ID0gZG9tUm93c1t5XTtcbiAgICAgIGlmIChyb3cgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgcm93Lmxlbmd0aDsgeCsrKSB7XG4gICAgICAgIGNvbnN0IGNlbGwgPSByb3dbeF07XG4gICAgICAgIGlmIChjZWxsID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZWxlbVxuICAgICAgICB9ID0gY2VsbDtcbiAgICAgICAgY29uc3QgY2VsbE5vZGUgPSAkZ2V0TmVhcmVzdFRhYmxlQ2VsbEluVGFibGVGcm9tRE9NTm9kZSh0aGlzLCBlbGVtKTtcbiAgICAgICAgaWYgKGNlbGxOb2RlICE9PSBudWxsICYmIHRhYmxlQ2VsbE5vZGUuaXMoY2VsbE5vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlbGwgbm90IGZvdW5kIGluIHRhYmxlLicpO1xuICB9XG4gIGdldERPTUNlbGxGcm9tQ29yZHMoeCwgeSwgdGFibGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBkb21Sb3dzXG4gICAgfSA9IHRhYmxlO1xuICAgIGNvbnN0IHJvdyA9IGRvbVJvd3NbeV07XG4gICAgaWYgKHJvdyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaW5kZXggPSB4IDwgcm93Lmxlbmd0aCA/IHggOiByb3cubGVuZ3RoIC0gMTtcbiAgICBjb25zdCBjZWxsID0gcm93W2luZGV4XTtcbiAgICBpZiAoY2VsbCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNlbGw7XG4gIH1cbiAgZ2V0RE9NQ2VsbEZyb21Db3Jkc09yVGhyb3coeCwgeSwgdGFibGUpIHtcbiAgICBjb25zdCBjZWxsID0gdGhpcy5nZXRET01DZWxsRnJvbUNvcmRzKHgsIHksIHRhYmxlKTtcbiAgICBpZiAoIWNlbGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2VsbCBub3QgZm91bmQgYXQgY29yZHMuJyk7XG4gICAgfVxuICAgIHJldHVybiBjZWxsO1xuICB9XG4gIGdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHksIHRhYmxlKSB7XG4gICAgY29uc3QgY2VsbCA9IHRoaXMuZ2V0RE9NQ2VsbEZyb21Db3Jkcyh4LCB5LCB0YWJsZSk7XG4gICAgaWYgKGNlbGwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShjZWxsLmVsZW0pO1xuICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0Q2VsbE5vZGVGcm9tQ29yZHNPclRocm93KHgsIHksIHRhYmxlKSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCwgeSwgdGFibGUpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlIGF0IGNvcmRzIG5vdCBUYWJsZUNlbGxOb2RlLicpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBnZXRSb3dTdHJpcGluZygpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLmdldExhdGVzdCgpLl9fcm93U3RyaXBpbmcpO1xuICB9XG4gIHNldFJvd1N0cmlwaW5nKG5ld1Jvd1N0cmlwaW5nKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fcm93U3RyaXBpbmcgPSBuZXdSb3dTdHJpcGluZztcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBzZXRGcm96ZW5Db2x1bW5zKGNvbHVtbkNvdW50KSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fZnJvemVuQ29sdW1uQ291bnQgPSBjb2x1bW5Db3VudDtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBnZXRGcm96ZW5Db2x1bW5zKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fZnJvemVuQ29sdW1uQ291bnQ7XG4gIH1cbiAgc2V0RnJvemVuUm93cyhyb3dDb3VudCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2Zyb3plblJvd0NvdW50ID0gcm93Q291bnQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0RnJvemVuUm93cygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2Zyb3plblJvd0NvdW50O1xuICB9XG4gIGNhblNlbGVjdEJlZm9yZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldENvbHVtbkNvdW50KCkge1xuICAgIGNvbnN0IGZpcnN0Um93ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKCFmaXJzdFJvdykge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGxldCBjb2x1bW5Db3VudCA9IDA7XG4gICAgZmlyc3RSb3cuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNlbGwgPT4ge1xuICAgICAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUoY2VsbCkpIHtcbiAgICAgICAgY29sdW1uQ291bnQgKz0gY2VsbC5nZXRDb2xTcGFuKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbHVtbkNvdW50O1xuICB9XG59XG5mdW5jdGlvbiAkZ2V0RWxlbWVudEZvclRhYmxlTm9kZShlZGl0b3IsIHRhYmxlTm9kZSkge1xuICBjb25zdCB0YWJsZUVsZW1lbnQgPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRhYmxlTm9kZS5nZXRLZXkoKSk7XG4gIGlmICghKHRhYmxlRWxlbWVudCAhPT0gbnVsbCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRnZXRFbGVtZW50Rm9yVGFibGVOb2RlOiBUYWJsZSBFbGVtZW50IE5vdCBGb3VuZGApO1xuICB9XG4gIHJldHVybiBnZXRUYWJsZSh0YWJsZU5vZGUsIHRhYmxlRWxlbWVudCk7XG59XG5mdW5jdGlvbiAkY29udmVydFRhYmxlRWxlbWVudChkb21Ob2RlKSB7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRjcmVhdGVUYWJsZU5vZGUoKTtcbiAgaWYgKGRvbU5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLWxleGljYWwtcm93LXN0cmlwaW5nJykpIHtcbiAgICB0YWJsZU5vZGUuc2V0Um93U3RyaXBpbmcodHJ1ZSk7XG4gIH1cbiAgaWYgKGRvbU5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLWxleGljYWwtZnJvemVuLWNvbHVtbicpKSB7XG4gICAgdGFibGVOb2RlLnNldEZyb3plbkNvbHVtbnMoMSk7XG4gIH1cbiAgaWYgKGRvbU5vZGUuaGFzQXR0cmlidXRlKCdkYXRhLWxleGljYWwtZnJvemVuLXJvdycpKSB7XG4gICAgdGFibGVOb2RlLnNldEZyb3plblJvd3MoMSk7XG4gIH1cbiAgY29uc3QgY29sR3JvdXAgPSBkb21Ob2RlLnF1ZXJ5U2VsZWN0b3IoJzpzY29wZSA+IGNvbGdyb3VwJyk7XG4gIGlmIChjb2xHcm91cCkge1xuICAgIGxldCBjb2x1bW5zID0gW107XG4gICAgZm9yIChjb25zdCBjb2wgb2YgY29sR3JvdXAucXVlcnlTZWxlY3RvckFsbCgnOnNjb3BlID4gY29sJykpIHtcbiAgICAgIGxldCB3aWR0aCA9IGNvbC5zdHlsZS53aWR0aCB8fCAnJztcbiAgICAgIGlmICghUElYRUxfVkFMVUVfUkVHX0VYUC50ZXN0KHdpZHRoKSkge1xuICAgICAgICAvLyBBbHNvIHN1cHBvcnQgZGVwcmVjYXRlZCB3aWR0aCBhdHRyaWJ1dGUgZm9yIGdvb2dsZSBkb2NzXG4gICAgICAgIHdpZHRoID0gY29sLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSB8fCAnJztcbiAgICAgICAgaWYgKCEvXlxcZCskLy50ZXN0KHdpZHRoKSkge1xuICAgICAgICAgIGNvbHVtbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbHVtbnMucHVzaChwYXJzZUZsb2F0KHdpZHRoKSk7XG4gICAgfVxuICAgIGlmIChjb2x1bW5zKSB7XG4gICAgICB0YWJsZU5vZGUuc2V0Q29sV2lkdGhzKGNvbHVtbnMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGFmdGVyOiBjaGlsZHJlbiA9PiAkZGVzY2VuZGFudHNNYXRjaGluZyhjaGlsZHJlbiwgJGlzVGFibGVSb3dOb2RlKSxcbiAgICBub2RlOiB0YWJsZU5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZU5vZGUoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFRhYmxlTm9kZSgpKTtcbn1cbmZ1bmN0aW9uICRpc1RhYmxlTm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGFibGVOb2RlO1xufVxuXG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVDb21tYW5kTGlzdGVuZXIoe1xuICByb3dzLFxuICBjb2x1bW5zLFxuICBpbmNsdWRlSGVhZGVyc1xufSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkgfHwgJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gIGlmICghc2VsZWN0aW9uIHx8ICEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gUHJldmVudCBuZXN0ZWQgdGFibGVzIGJ5IGNoZWNraW5nIGlmIHdlJ3JlIGFscmVhZHkgaW5zaWRlIGEgdGFibGVcbiAgaWYgKCRmaW5kVGFibGVOb2RlKHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB0YWJsZU5vZGUgPSAkY3JlYXRlVGFibGVOb2RlV2l0aERpbWVuc2lvbnMoTnVtYmVyKHJvd3MpLCBOdW1iZXIoY29sdW1ucyksIGluY2x1ZGVIZWFkZXJzKTtcbiAgJGluc2VydE5vZGVUb05lYXJlc3RSb290KHRhYmxlTm9kZSk7XG4gIGNvbnN0IGZpcnN0RGVzY2VuZGFudCA9IHRhYmxlTm9kZS5nZXRGaXJzdERlc2NlbmRhbnQoKTtcbiAgaWYgKCRpc1RleHROb2RlKGZpcnN0RGVzY2VuZGFudCkpIHtcbiAgICBmaXJzdERlc2NlbmRhbnQuc2VsZWN0KCk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiAkdGFibGVDZWxsVHJhbnNmb3JtKG5vZGUpIHtcbiAgaWYgKCEkaXNUYWJsZVJvd05vZGUobm9kZS5nZXRQYXJlbnQoKSkpIHtcbiAgICAvLyBUYWJsZUNlbGxOb2RlIG11c3QgYmUgYSBjaGlsZCBvZiBUYWJsZVJvd05vZGUuXG4gICAgbm9kZS5yZW1vdmUoKTtcbiAgfSBlbHNlIGlmIChub2RlLmlzRW1wdHkoKSkge1xuICAgIC8vIFRhYmxlQ2VsbE5vZGUgc2hvdWxkIG5ldmVyIGJlIGVtcHR5XG4gICAgbm9kZS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uICR0YWJsZVJvd1RyYW5zZm9ybShub2RlKSB7XG4gIGlmICghJGlzVGFibGVOb2RlKG5vZGUuZ2V0UGFyZW50KCkpKSB7XG4gICAgLy8gVGFibGVSb3dOb2RlIG11c3QgYmUgYSBjaGlsZCBvZiBUYWJsZU5vZGUuXG4gICAgLy8gVE9ETzogRnV0dXJlIHN1cHBvcnQgb2YgdGJvZHkvdGhlYWQvdGZvb3QgbWF5IGNoYW5nZSB0aGlzXG4gICAgbm9kZS5yZW1vdmUoKTtcbiAgfSBlbHNlIHtcbiAgICAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHMobm9kZSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gIH1cbn1cbmZ1bmN0aW9uICR0YWJsZVRyYW5zZm9ybShub2RlKSB7XG4gIC8vIFRhYmxlUm93Tm9kZSBpcyB0aGUgb25seSB2YWxpZCBjaGlsZCBmb3IgVGFibGVOb2RlXG4gIC8vIFRPRE86IEZ1dHVyZSBzdXBwb3J0IG9mIHRib2R5L3RoZWFkL3Rmb290L2NhcHRpb24gbWF5IGNoYW5nZSB0aGlzXG4gICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50cyhub2RlLCAkaXNUYWJsZVJvd05vZGUpO1xuICBjb25zdCBbZ3JpZE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwU2tpcENlbGxDaGVjayhub2RlLCBudWxsLCBudWxsKTtcbiAgY29uc3QgbWF4Um93TGVuZ3RoID0gZ3JpZE1hcC5yZWR1Y2UoKGN1ckxlbmd0aCwgcm93KSA9PiB7XG4gICAgcmV0dXJuIE1hdGgubWF4KGN1ckxlbmd0aCwgcm93Lmxlbmd0aCk7XG4gIH0sIDApO1xuICBjb25zdCByb3dOb2RlcyA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBncmlkTWFwLmxlbmd0aDsgKytpKSB7XG4gICAgY29uc3Qgcm93Tm9kZSA9IHJvd05vZGVzW2ldO1xuICAgIGlmICghcm93Tm9kZSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICghJGlzVGFibGVSb3dOb2RlKHJvd05vZGUpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFRhYmxlUGx1Z2luOiBFeHBlY3RpbmcgYWxsIGNoaWxkcmVuIG9mIFRhYmxlTm9kZSB0byBiZSBUYWJsZVJvd05vZGUsIGZvdW5kICR7cm93Tm9kZS5jb25zdHJ1Y3Rvci5uYW1lfSAodHlwZSAke3Jvd05vZGUuZ2V0VHlwZSgpfSlgKTtcbiAgICB9XG4gICAgY29uc3Qgcm93TGVuZ3RoID0gZ3JpZE1hcFtpXS5yZWR1Y2UoKGFjYywgY2VsbCkgPT4gY2VsbCA/IDEgKyBhY2MgOiBhY2MsIDApO1xuICAgIGlmIChyb3dMZW5ndGggPT09IG1heFJvd0xlbmd0aCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSByb3dMZW5ndGg7IGogPCBtYXhSb3dMZW5ndGg7ICsraikge1xuICAgICAgLy8gVE9ETzogaW5oZXJpdCBoZWFkZXIgc3RhdGUgZnJvbSBhbm90aGVyIGhlYWRlciBvciBib2R5XG4gICAgICBjb25zdCBuZXdDZWxsID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoKTtcbiAgICAgIG5ld0NlbGwuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICAgICAgcm93Tm9kZS5hcHBlbmQobmV3Q2VsbCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkdGFibGVDbGlja0NvbW1hbmQoZXZlbnQpIHtcbiAgaWYgKGV2ZW50LmRldGFpbCA8IDMgfHwgIWlzRE9NTm9kZShldmVudC50YXJnZXQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHN0YXJ0Tm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGV2ZW50LnRhcmdldCk7XG4gIGlmIChzdGFydE5vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYmxvY2tOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzdGFydE5vZGUsIG5vZGUgPT4gJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgIW5vZGUuaXNJbmxpbmUoKSk7XG4gIGlmIChibG9ja05vZGUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgcm9vdE5vZGUgPSBibG9ja05vZGUuZ2V0UGFyZW50KCk7XG4gIGlmICghJGlzVGFibGVDZWxsTm9kZShyb290Tm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgYmxvY2tOb2RlLnNlbGVjdCgwKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgYSB0cmFuc2Zvcm0gdG8gZW5zdXJlIHRoYXQgYWxsIFRhYmxlQ2VsbE5vZGUgaGF2ZSBhIGNvbFNwYW4gYW5kIHJvd1NwYW4gb2YgMS5cbiAqIFRoaXMgc2hvdWxkIG9ubHkgYmUgcmVnaXN0ZXJlZCB3aGVuIHlvdSBkbyBub3Qgd2FudCB0byBzdXBwb3J0IG1lcmdlZCBjZWxscy5cbiAqXG4gKiBAcGFyYW0gZWRpdG9yIFRoZSBlZGl0b3JcbiAqIEByZXR1cm5zIEFuIHVucmVnaXN0ZXIgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJUYWJsZUNlbGxVbm1lcmdlVHJhbnNmb3JtKGVkaXRvcikge1xuICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybShUYWJsZUNlbGxOb2RlLCBub2RlID0+IHtcbiAgICBpZiAobm9kZS5nZXRDb2xTcGFuKCkgPiAxIHx8IG5vZGUuZ2V0Um93U3BhbigpID4gMSkge1xuICAgICAgLy8gV2hlbiB3ZSBoYXZlIHJvd1NwYW4gd2UgaGF2ZSB0byBtYXAgdGhlIGVudGlyZSBUYWJsZSB0byB1bmRlcnN0YW5kIHdoZXJlIHRoZSBuZXcgQ2VsbHNcbiAgICAgIC8vIGZpdCBiZXN0OyBsZXQncyBhbmFseXplIGFsbCBDZWxscyBhdCBvbmNlIHRvIHNhdmUgdXMgZnJvbSBmdXJ0aGVyIHRyYW5zZm9ybSBpdGVyYXRpb25zXG4gICAgICBjb25zdCBbLCwgZ3JpZE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KG5vZGUpO1xuICAgICAgY29uc3QgW2dyaWRNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkTm9kZSwgbm9kZSwgbm9kZSk7XG4gICAgICAvLyBUT0RPIHRoaXMgZnVuY3Rpb24gZXhwZWN0cyBUYWJsZXMgdG8gYmUgbm9ybWFsaXplZC4gTG9vayBpbnRvIHRoaXMgb25jZSBpdCBleGlzdHNcbiAgICAgIGNvbnN0IHJvd3NDb3VudCA9IGdyaWRNYXAubGVuZ3RoO1xuICAgICAgY29uc3QgY29sdW1uc0NvdW50ID0gZ3JpZE1hcFswXS5sZW5ndGg7XG4gICAgICBsZXQgcm93ID0gZ3JpZE5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKCEkaXNUYWJsZVJvd05vZGUocm93KSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIFRhYmxlTm9kZSBmaXJzdCBjaGlsZCB0byBiZSBhIFJvd05vZGVgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVubWVyZ2VkID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3NDb3VudDsgaSsrKSB7XG4gICAgICAgIGlmIChpICE9PSAwKSB7XG4gICAgICAgICAgcm93ID0gcm93LmdldE5leHRTaWJsaW5nKCk7XG4gICAgICAgICAgaWYgKCEkaXNUYWJsZVJvd05vZGUocm93KSkge1xuICAgICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZU5vZGUgZmlyc3QgY2hpbGQgdG8gYmUgYSBSb3dOb2RlYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBsYXN0Um93Q2VsbCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uc0NvdW50OyBqKyspIHtcbiAgICAgICAgICBjb25zdCBjZWxsTWFwID0gZ3JpZE1hcFtpXVtqXTtcbiAgICAgICAgICBjb25zdCBjZWxsID0gY2VsbE1hcC5jZWxsO1xuICAgICAgICAgIGlmIChjZWxsTWFwLnN0YXJ0Um93ID09PSBpICYmIGNlbGxNYXAuc3RhcnRDb2x1bW4gPT09IGopIHtcbiAgICAgICAgICAgIGxhc3RSb3dDZWxsID0gY2VsbDtcbiAgICAgICAgICAgIHVubWVyZ2VkLnB1c2goY2VsbCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjZWxsLmdldENvbFNwYW4oKSA+IDEgfHwgY2VsbC5nZXRSb3dTcGFuKCkgPiAxKSB7XG4gICAgICAgICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoY2VsbCkpIHtcbiAgICAgICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZU5vZGUgY2VsbCB0byBiZSBhIFRhYmxlQ2VsbE5vZGVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld0NlbGwgPSAkY3JlYXRlVGFibGVDZWxsTm9kZShjZWxsLl9faGVhZGVyU3RhdGUpO1xuICAgICAgICAgICAgaWYgKGxhc3RSb3dDZWxsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGxhc3RSb3dDZWxsLmluc2VydEFmdGVyKG5ld0NlbGwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgJGluc2VydEZpcnN0JDEocm93LCBuZXdDZWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgY2VsbCBvZiB1bm1lcmdlZCkge1xuICAgICAgICBjZWxsLnNldENvbFNwYW4oMSk7XG4gICAgICAgIGNlbGwuc2V0Um93U3BhbigxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVnaXN0ZXJUYWJsZVNlbGVjdGlvbk9ic2VydmVyKGVkaXRvciwgaGFzVGFiSGFuZGxlciA9IHRydWUpIHtcbiAgY29uc3QgdGFibGVTZWxlY3Rpb25zID0gbmV3IE1hcCgpO1xuICBjb25zdCBpbml0aWFsaXplVGFibGVOb2RlID0gKHRhYmxlTm9kZSwgbm9kZUtleSwgZG9tKSA9PiB7XG4gICAgY29uc3QgdGFibGVFbGVtZW50ID0gZ2V0VGFibGVFbGVtZW50KHRhYmxlTm9kZSwgZG9tKTtcbiAgICBjb25zdCB0YWJsZVNlbGVjdGlvbiA9IGFwcGx5VGFibGVIYW5kbGVycyh0YWJsZU5vZGUsIHRhYmxlRWxlbWVudCwgZWRpdG9yLCBoYXNUYWJIYW5kbGVyKTtcbiAgICB0YWJsZVNlbGVjdGlvbnMuc2V0KG5vZGVLZXksIFt0YWJsZVNlbGVjdGlvbiwgdGFibGVFbGVtZW50XSk7XG4gIH07XG4gIGNvbnN0IHVucmVnaXN0ZXJNdXRhdGlvbkxpc3RlbmVyID0gZWRpdG9yLnJlZ2lzdGVyTXV0YXRpb25MaXN0ZW5lcihUYWJsZU5vZGUsIG5vZGVNdXRhdGlvbnMgPT4ge1xuICAgIGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBbbm9kZUtleSwgbXV0YXRpb25dIG9mIG5vZGVNdXRhdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdGFibGVTZWxlY3Rpb24gPSB0YWJsZVNlbGVjdGlvbnMuZ2V0KG5vZGVLZXkpO1xuICAgICAgICBpZiAobXV0YXRpb24gPT09ICdjcmVhdGVkJyB8fCBtdXRhdGlvbiA9PT0gJ3VwZGF0ZWQnKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdGFibGVOb2RlLFxuICAgICAgICAgICAgdGFibGVFbGVtZW50XG4gICAgICAgICAgfSA9ICRnZXRUYWJsZUFuZEVsZW1lbnRCeUtleShub2RlS2V5KTtcbiAgICAgICAgICBpZiAodGFibGVTZWxlY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaW5pdGlhbGl6ZVRhYmxlTm9kZSh0YWJsZU5vZGUsIG5vZGVLZXksIHRhYmxlRWxlbWVudCk7XG4gICAgICAgICAgfSBlbHNlIGlmICh0YWJsZUVsZW1lbnQgIT09IHRhYmxlU2VsZWN0aW9uWzFdKSB7XG4gICAgICAgICAgICAvLyBUaGUgdXBkYXRlIGNyZWF0ZWQgYSBuZXcgRE9NIG5vZGUsIGRlc3Ryb3kgdGhlIGV4aXN0aW5nIFRhYmxlT2JzZXJ2ZXJcbiAgICAgICAgICAgIHRhYmxlU2VsZWN0aW9uWzBdLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgdGFibGVTZWxlY3Rpb25zLmRlbGV0ZShub2RlS2V5KTtcbiAgICAgICAgICAgIGluaXRpYWxpemVUYWJsZU5vZGUodGFibGVOb2RlLCBub2RlS2V5LCB0YWJsZUVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtdXRhdGlvbiA9PT0gJ2Rlc3Ryb3llZCcpIHtcbiAgICAgICAgICBpZiAodGFibGVTZWxlY3Rpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGFibGVTZWxlY3Rpb25bMF0ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICB0YWJsZVNlbGVjdGlvbnMuZGVsZXRlKG5vZGVLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGVkaXRvclxuICAgIH0pO1xuICB9LCB7XG4gICAgc2tpcEluaXRpYWxpemF0aW9uOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB1bnJlZ2lzdGVyTXV0YXRpb25MaXN0ZW5lcigpO1xuICAgIC8vIEhvb2sgbWlnaHQgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHNvIGNsZWFuaW5nIHVwIHRhYmxlcyBsaXN0ZW5lcnMgYXMgd2VsbCxcbiAgICAvLyBhcyBpdCdsbCBiZSByZWluaXRpYWxpemVkIGR1cmluZyByZWN1cnJpbmcgY2FsbFxuICAgIGZvciAoY29uc3QgWywgW3RhYmxlU2VsZWN0aW9uXV0gb2YgdGFibGVTZWxlY3Rpb25zKSB7XG4gICAgICB0YWJsZVNlbGVjdGlvbi5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogUmVnaXN0ZXIgdGhlIElOU0VSVF9UQUJMRV9DT01NQU5EIGxpc3RlbmVyIGFuZCB0aGUgdGFibGUgaW50ZWdyaXR5IHRyYW5zZm9ybXMuIFRoZVxuICogdGFibGUgc2VsZWN0aW9uIG9ic2VydmVyIHNob3VsZCBiZSByZWdpc3RlcmVkIHNlcGFyYXRlbHkgYWZ0ZXIgdGhpcyB3aXRoXG4gKiB7QGxpbmsgcmVnaXN0ZXJUYWJsZVNlbGVjdGlvbk9ic2VydmVyfS5cbiAqXG4gKiBAcGFyYW0gZWRpdG9yIFRoZSBlZGl0b3JcbiAqIEByZXR1cm5zIEFuIHVucmVnaXN0ZXIgY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJUYWJsZVBsdWdpbihlZGl0b3IpIHtcbiAgaWYgKCFlZGl0b3IuaGFzTm9kZXMoW1RhYmxlTm9kZV0pKSB7XG4gICAge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBUYWJsZVBsdWdpbjogVGFibGVOb2RlIGlzIG5vdCByZWdpc3RlcmVkIG9uIGVkaXRvcmApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOU0VSVF9UQUJMRV9DT01NQU5ELCAkaW5zZXJ0VGFibGVDb21tYW5kTGlzdGVuZXIsIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChTRUxFQ1RJT05fSU5TRVJUX0NMSVBCT0FSRF9OT0RFU19DT01NQU5ELCAoe1xuICAgIG5vZGVzLFxuICAgIHNlbGVjdGlvblxuICB9LCBkaXNwYXRjaEVkaXRvcikgPT4ge1xuICAgIGlmIChlZGl0b3IgIT09IGRpc3BhdGNoRWRpdG9yIHx8ICEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGlzSW5zaWRlVGFibGVDZWxsID0gJGZpbmRUYWJsZU5vZGUoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpICE9PSBudWxsO1xuICAgIHJldHVybiBpc0luc2lkZVRhYmxlQ2VsbCAmJiBub2Rlcy5zb21lKCRpc1RhYmxlTm9kZSk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDTElDS19DT01NQU5ELCAkdGFibGVDbGlja0NvbW1hbmQsIENPTU1BTkRfUFJJT1JJVFlfRURJVE9SKSwgZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybShUYWJsZU5vZGUsICR0YWJsZVRyYW5zZm9ybSksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oVGFibGVSb3dOb2RlLCAkdGFibGVSb3dUcmFuc2Zvcm0pLCBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKFRhYmxlQ2VsbE5vZGUsICR0YWJsZUNlbGxUcmFuc2Zvcm0pKTtcbn1cblxuZXhwb3J0IHsgJGNvbXB1dGVUYWJsZU1hcCwgJGNvbXB1dGVUYWJsZU1hcFNraXBDZWxsQ2hlY2ssICRjcmVhdGVUYWJsZUNlbGxOb2RlLCAkY3JlYXRlVGFibGVOb2RlLCAkY3JlYXRlVGFibGVOb2RlV2l0aERpbWVuc2lvbnMsICRjcmVhdGVUYWJsZVJvd05vZGUsICRjcmVhdGVUYWJsZVNlbGVjdGlvbiwgJGNyZWF0ZVRhYmxlU2VsZWN0aW9uRnJvbSwgJGRlbGV0ZVRhYmxlQ29sdW1uLCAkZGVsZXRlVGFibGVDb2x1bW5BdFNlbGVjdGlvbiwgJGRlbGV0ZVRhYmxlQ29sdW1uX19FWFBFUklNRU5UQUwsICRkZWxldGVUYWJsZVJvd0F0U2VsZWN0aW9uLCAkZGVsZXRlVGFibGVSb3dfX0VYUEVSSU1FTlRBTCwgJGZpbmRDZWxsTm9kZSwgJGZpbmRUYWJsZU5vZGUsICRnZXRFbGVtZW50Rm9yVGFibGVOb2RlLCAkZ2V0Tm9kZVRyaXBsZXQsICRnZXRUYWJsZUFuZEVsZW1lbnRCeUtleSwgJGdldFRhYmxlQ2VsbE5vZGVGcm9tTGV4aWNhbE5vZGUsICRnZXRUYWJsZUNlbGxOb2RlUmVjdCwgJGdldFRhYmxlQ29sdW1uSW5kZXhGcm9tVGFibGVDZWxsTm9kZSwgJGdldFRhYmxlTm9kZUZyb21MZXhpY2FsTm9kZU9yVGhyb3csICRnZXRUYWJsZVJvd0luZGV4RnJvbVRhYmxlQ2VsbE5vZGUsICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3csICRpbnNlcnRUYWJsZUNvbHVtbiwgJGluc2VydFRhYmxlQ29sdW1uQXRTZWxlY3Rpb24sICRpbnNlcnRUYWJsZUNvbHVtbl9fRVhQRVJJTUVOVEFMLCAkaW5zZXJ0VGFibGVSb3csICRpbnNlcnRUYWJsZVJvd0F0U2VsZWN0aW9uLCAkaW5zZXJ0VGFibGVSb3dfX0VYUEVSSU1FTlRBTCwgJGlzU2Nyb2xsYWJsZVRhYmxlc0FjdGl2ZSwgJGlzVGFibGVDZWxsTm9kZSwgJGlzVGFibGVOb2RlLCAkaXNUYWJsZVJvd05vZGUsICRpc1RhYmxlU2VsZWN0aW9uLCAkbWVyZ2VDZWxscywgJHJlbW92ZVRhYmxlUm93QXRJbmRleCwgJHVubWVyZ2VDZWxsLCBJTlNFUlRfVEFCTEVfQ09NTUFORCwgVGFibGVDZWxsSGVhZGVyU3RhdGVzLCBUYWJsZUNlbGxOb2RlLCBUYWJsZU5vZGUsIFRhYmxlT2JzZXJ2ZXIsIFRhYmxlUm93Tm9kZSwgYXBwbHlUYWJsZUhhbmRsZXJzLCBnZXRET01DZWxsRnJvbVRhcmdldCwgZ2V0VGFibGVFbGVtZW50LCBnZXRUYWJsZU9ic2VydmVyRnJvbVRhYmxlRWxlbWVudCwgcmVnaXN0ZXJUYWJsZUNlbGxVbm1lcmdlVHJhbnNmb3JtLCByZWdpc3RlclRhYmxlUGx1Z2luLCByZWdpc3RlclRhYmxlU2VsZWN0aW9uT2JzZXJ2ZXIsIHNldFNjcm9sbGFibGVUYWJsZXNBY3RpdmUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@lexical+table@0.35.0/node_modules/@lexical/table/LexicalTable.dev.mjs\n");

/***/ })

};
;