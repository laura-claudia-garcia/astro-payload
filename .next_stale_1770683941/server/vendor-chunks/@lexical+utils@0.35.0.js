"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+utils@0.35.0";
exports.ids = ["vendor-chunks/@lexical+utils@0.35.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@lexical+utils@0.35.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+utils@0.35.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $descendantsMatching: () => (/* binding */ $descendantsMatching),\n/* harmony export */   $dfs: () => (/* binding */ $dfs),\n/* harmony export */   $dfsIterator: () => (/* binding */ $dfsIterator),\n/* harmony export */   $filter: () => (/* binding */ $filter),\n/* harmony export */   $findMatchingParent: () => (/* binding */ $findMatchingParent),\n/* harmony export */   $firstToLastIterator: () => (/* binding */ $firstToLastIterator),\n/* harmony export */   $getAdjacentCaret: () => (/* binding */ $getAdjacentCaret),\n/* harmony export */   $getAdjacentSiblingOrParentSiblingCaret: () => (/* binding */ $getAdjacentSiblingOrParentSiblingCaret),\n/* harmony export */   $getDepth: () => (/* binding */ $getDepth),\n/* harmony export */   $getNearestBlockElementAncestorOrThrow: () => (/* binding */ $getNearestBlockElementAncestorOrThrow),\n/* harmony export */   $getNearestNodeOfType: () => (/* binding */ $getNearestNodeOfType),\n/* harmony export */   $getNextRightPreorderNode: () => (/* binding */ $getNextRightPreorderNode),\n/* harmony export */   $getNextSiblingOrParentSibling: () => (/* binding */ $getNextSiblingOrParentSibling),\n/* harmony export */   $insertFirst: () => (/* binding */ $insertFirst),\n/* harmony export */   $insertNodeToNearestRoot: () => (/* binding */ $insertNodeToNearestRoot),\n/* harmony export */   $insertNodeToNearestRootAtCaret: () => (/* binding */ $insertNodeToNearestRootAtCaret),\n/* harmony export */   $isEditorIsNestedEditor: () => (/* binding */ $isEditorIsNestedEditor),\n/* harmony export */   $lastToFirstIterator: () => (/* binding */ $lastToFirstIterator),\n/* harmony export */   $restoreEditorState: () => (/* binding */ $restoreEditorState),\n/* harmony export */   $reverseDfs: () => (/* binding */ $reverseDfs),\n/* harmony export */   $reverseDfsIterator: () => (/* binding */ $reverseDfsIterator),\n/* harmony export */   $splitNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$splitNode),\n/* harmony export */   $unwrapAndFilterDescendants: () => (/* binding */ $unwrapAndFilterDescendants),\n/* harmony export */   $unwrapNode: () => (/* binding */ $unwrapNode),\n/* harmony export */   $wrapNodeInElement: () => (/* binding */ $wrapNodeInElement),\n/* harmony export */   CAN_USE_BEFORE_INPUT: () => (/* binding */ CAN_USE_BEFORE_INPUT),\n/* harmony export */   CAN_USE_DOM: () => (/* binding */ CAN_USE_DOM),\n/* harmony export */   IS_ANDROID: () => (/* binding */ IS_ANDROID),\n/* harmony export */   IS_ANDROID_CHROME: () => (/* binding */ IS_ANDROID_CHROME),\n/* harmony export */   IS_APPLE: () => (/* binding */ IS_APPLE),\n/* harmony export */   IS_APPLE_WEBKIT: () => (/* binding */ IS_APPLE_WEBKIT),\n/* harmony export */   IS_CHROME: () => (/* binding */ IS_CHROME),\n/* harmony export */   IS_FIREFOX: () => (/* binding */ IS_FIREFOX),\n/* harmony export */   IS_IOS: () => (/* binding */ IS_IOS),\n/* harmony export */   IS_SAFARI: () => (/* binding */ IS_SAFARI),\n/* harmony export */   addClassNamesToElement: () => (/* binding */ addClassNamesToElement),\n/* harmony export */   calculateZoomLevel: () => (/* binding */ calculateZoomLevel),\n/* harmony export */   isBlockDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isBlockDomNode),\n/* harmony export */   isHTMLAnchorElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement),\n/* harmony export */   isHTMLElement: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement),\n/* harmony export */   isInlineDomNode: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.isInlineDomNode),\n/* harmony export */   isMimeType: () => (/* binding */ isMimeType),\n/* harmony export */   makeStateWrapper: () => (/* binding */ makeStateWrapper),\n/* harmony export */   markSelection: () => (/* binding */ markSelection),\n/* harmony export */   mediaFileReader: () => (/* binding */ mediaFileReader),\n/* harmony export */   mergeRegister: () => (/* binding */ mergeRegister),\n/* harmony export */   objectKlassEquals: () => (/* binding */ objectKlassEquals),\n/* harmony export */   positionNodeOnRange: () => (/* binding */ mlcPositionNodeOnRange),\n/* harmony export */   registerNestedElementResolver: () => (/* binding */ registerNestedElementResolver),\n/* harmony export */   removeClassNamesFromElement: () => (/* binding */ removeClassNamesFromElement),\n/* harmony export */   selectionAlwaysOnDisplay: () => (/* binding */ selectionAlwaysOnDisplay)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/selection */ \"(rsc)/./node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM$1 = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM$1 && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\nconst IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);\n\n// Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\nconst IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);\n// export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_ANDROID_CHROME$1 = CAN_USE_DOM$1 && IS_ANDROID$1 && IS_CHROME$1;\nconst IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the component it resides in unmounts.\n * Note the functions don't necessarily need to be in an array as all arguments\n * are considered to be the func argument and spread from there.\n * The order of cleanup is the reverse of the argument order. Generally it is\n * expected that the first \"acquire\" will be \"released\" last (LIFO order),\n * because a later step may have some dependency on an earlier one.\n * @param func - An array of cleanup functions meant to be executed by the returned function.\n * @returns the function which executes all the passed cleanup functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    for (let i = func.length - 1; i >= 0; i--) {\n      func[i]();\n    }\n    // Clean up the references and make future calls a no-op\n    func.length = 0;\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction px(value) {\n  return `${value}px`;\n}\n\nconst mutationObserverConfig = {\n  attributes: true,\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction prependDOMNode(parent, node) {\n  parent.insertBefore(node, parent.firstChild);\n}\n\n/**\n * Place one or multiple newly created Nodes at the passed Range's position.\n * Multiple nodes will only be created when the Range spans multiple lines (aka\n * client rects).\n *\n * This function can come particularly useful to highlight particular parts of\n * the text without interfering with the EditorState, that will often replicate\n * the state across collab and clipboard.\n *\n * This function accounts for DOM updates which can modify the passed Range.\n * Hence, the function return to remove the listener.\n */\nfunction mlcPositionNodeOnRange(editor, range, onReposition) {\n  let rootDOMNode = null;\n  let parentDOMNode = null;\n  let observer = null;\n  let lastNodes = [];\n  const wrapperNode = document.createElement('div');\n  wrapperNode.style.position = 'relative';\n  function position() {\n    if (!(rootDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null rootDOMNode`);\n    }\n    if (!(parentDOMNode !== null)) {\n      formatDevErrorMessage(`Unexpected null parentDOMNode`);\n    }\n    const {\n      left: parentLeft,\n      top: parentTop\n    } = parentDOMNode.getBoundingClientRect();\n    const rects = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_1__.createRectsFromDOMRange)(editor, range);\n    if (!wrapperNode.isConnected) {\n      prependDOMNode(parentDOMNode, wrapperNode);\n    }\n    let hasRepositioned = false;\n    for (let i = 0; i < rects.length; i++) {\n      const rect = rects[i];\n      // Try to reuse the previously created Node when possible, no need to\n      // remove/create on the most common case reposition case\n      const rectNode = lastNodes[i] || document.createElement('div');\n      const rectNodeStyle = rectNode.style;\n      if (rectNodeStyle.position !== 'absolute') {\n        rectNodeStyle.position = 'absolute';\n        hasRepositioned = true;\n      }\n      const left = px(rect.left - parentLeft);\n      if (rectNodeStyle.left !== left) {\n        rectNodeStyle.left = left;\n        hasRepositioned = true;\n      }\n      const top = px(rect.top - parentTop);\n      if (rectNodeStyle.top !== top) {\n        rectNode.style.top = top;\n        hasRepositioned = true;\n      }\n      const width = px(rect.width);\n      if (rectNodeStyle.width !== width) {\n        rectNode.style.width = width;\n        hasRepositioned = true;\n      }\n      const height = px(rect.height);\n      if (rectNodeStyle.height !== height) {\n        rectNode.style.height = height;\n        hasRepositioned = true;\n      }\n      if (rectNode.parentNode !== wrapperNode) {\n        wrapperNode.append(rectNode);\n        hasRepositioned = true;\n      }\n      lastNodes[i] = rectNode;\n    }\n    while (lastNodes.length > rects.length) {\n      lastNodes.pop();\n    }\n    if (hasRepositioned) {\n      onReposition(lastNodes);\n    }\n  }\n  function stop() {\n    parentDOMNode = null;\n    rootDOMNode = null;\n    if (observer !== null) {\n      observer.disconnect();\n    }\n    observer = null;\n    wrapperNode.remove();\n    for (const node of lastNodes) {\n      node.remove();\n    }\n    lastNodes = [];\n  }\n  function restart() {\n    const currentRootDOMNode = editor.getRootElement();\n    if (currentRootDOMNode === null) {\n      return stop();\n    }\n    const currentParentDOMNode = currentRootDOMNode.parentElement;\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(currentParentDOMNode)) {\n      return stop();\n    }\n    stop();\n    rootDOMNode = currentRootDOMNode;\n    parentDOMNode = currentParentDOMNode;\n    observer = new MutationObserver(mutations => {\n      const nextRootDOMNode = editor.getRootElement();\n      const nextParentDOMNode = nextRootDOMNode && nextRootDOMNode.parentElement;\n      if (nextRootDOMNode !== rootDOMNode || nextParentDOMNode !== parentDOMNode) {\n        return restart();\n      }\n      for (const mutation of mutations) {\n        if (!wrapperNode.contains(mutation.target)) {\n          // TODO throttle\n          return position();\n        }\n      }\n    });\n    observer.observe(currentParentDOMNode, mutationObserverConfig);\n    position();\n  }\n  const removeRootListener = editor.registerRootListener(restart);\n  return () => {\n    removeRootListener();\n    stop();\n  };\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $getOrderedSelectionPoints(selection) {\n  const points = selection.getStartEndPoints();\n  return selection.isBackward() ? [points[1], points[0]] : points;\n}\nfunction rangeTargetFromPoint(point, node, dom) {\n  if (point.type === 'text' || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    const textDOM = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMTextNode)(dom) || dom;\n    return [textDOM, point.offset];\n  } else {\n    const slot = node.getDOMSlot(dom);\n    return [slot.element, slot.getFirstChildOffset() + point.offset];\n  }\n}\nfunction rangeFromPoints(editor, start, startNode, startDOM, end, endNode, endDOM) {\n  const editorDocument = editor._window ? editor._window.document : document;\n  const range = editorDocument.createRange();\n  range.setStart(...rangeTargetFromPoint(start, startNode, startDOM));\n  range.setEnd(...rangeTargetFromPoint(end, endNode, endDOM));\n  return range;\n}\n/**\n * Place one or multiple newly created Nodes at the current selection. Multiple\n * nodes will only be created when the selection spans multiple lines (aka\n * client rects).\n *\n * This function can come useful when you want to show the selection but the\n * editor has been focused away.\n */\nfunction markSelection(editor, onReposition) {\n  let previousAnchorNode = null;\n  let previousAnchorNodeDOM = null;\n  let previousAnchorOffset = null;\n  let previousFocusNode = null;\n  let previousFocusNodeDOM = null;\n  let previousFocusOffset = null;\n  let removeRangeListener = () => {};\n  function compute(editorState) {\n    editorState.read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        // TODO\n        previousAnchorNode = null;\n        previousAnchorOffset = null;\n        previousFocusNode = null;\n        previousFocusOffset = null;\n        removeRangeListener();\n        removeRangeListener = () => {};\n        return;\n      }\n      const [start, end] = $getOrderedSelectionPoints(selection);\n      const currentStartNode = start.getNode();\n      const currentStartNodeKey = currentStartNode.getKey();\n      const currentStartOffset = start.offset;\n      const currentEndNode = end.getNode();\n      const currentEndNodeKey = currentEndNode.getKey();\n      const currentEndOffset = end.offset;\n      const currentStartNodeDOM = editor.getElementByKey(currentStartNodeKey);\n      const currentEndNodeDOM = editor.getElementByKey(currentEndNodeKey);\n      const differentStartDOM = previousAnchorNode === null || currentStartNodeDOM !== previousAnchorNodeDOM || currentStartOffset !== previousAnchorOffset || currentStartNodeKey !== previousAnchorNode.getKey();\n      const differentEndDOM = previousFocusNode === null || currentEndNodeDOM !== previousFocusNodeDOM || currentEndOffset !== previousFocusOffset || currentEndNodeKey !== previousFocusNode.getKey();\n      if ((differentStartDOM || differentEndDOM) && currentStartNodeDOM !== null && currentEndNodeDOM !== null) {\n        const range = rangeFromPoints(editor, start, currentStartNode, currentStartNodeDOM, end, currentEndNode, currentEndNodeDOM);\n        removeRangeListener();\n        removeRangeListener = mlcPositionNodeOnRange(editor, range, domNodes => {\n          if (onReposition === undefined) {\n            for (const domNode of domNodes) {\n              const domNodeStyle = domNode.style;\n              if (domNodeStyle.background !== 'Highlight') {\n                domNodeStyle.background = 'Highlight';\n              }\n              if (domNodeStyle.color !== 'HighlightText') {\n                domNodeStyle.color = 'HighlightText';\n              }\n              if (domNodeStyle.marginTop !== px(-1.5)) {\n                domNodeStyle.marginTop = px(-1.5);\n              }\n              if (domNodeStyle.paddingTop !== px(4)) {\n                domNodeStyle.paddingTop = px(4);\n              }\n              if (domNodeStyle.paddingBottom !== px(0)) {\n                domNodeStyle.paddingBottom = px(0);\n              }\n            }\n          } else {\n            onReposition(domNodes);\n          }\n        });\n      }\n      previousAnchorNode = currentStartNode;\n      previousAnchorNodeDOM = currentStartNodeDOM;\n      previousAnchorOffset = currentStartOffset;\n      previousFocusNode = currentEndNode;\n      previousFocusNodeDOM = currentEndNodeDOM;\n      previousFocusOffset = currentEndOffset;\n    });\n  }\n  compute(editor.getEditorState());\n  return mergeRegister(editor.registerUpdateListener(({\n    editorState\n  }) => compute(editorState)), () => {\n    removeRangeListener();\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction selectionAlwaysOnDisplay(editor) {\n  let removeSelectionMark = null;\n  const onSelectionChange = () => {\n    const domSelection = getSelection();\n    const domAnchorNode = domSelection && domSelection.anchorNode;\n    const editorRootElement = editor.getRootElement();\n    const isSelectionInsideEditor = domAnchorNode !== null && editorRootElement !== null && editorRootElement.contains(domAnchorNode);\n    if (isSelectionInsideEditor) {\n      if (removeSelectionMark !== null) {\n        removeSelectionMark();\n        removeSelectionMark = null;\n      }\n    } else {\n      if (removeSelectionMark === null) {\n        removeSelectionMark = markSelection(editor);\n      }\n    }\n  };\n  document.addEventListener('selectionchange', onSelectionChange);\n  return () => {\n    if (removeSelectionMark !== null) {\n      removeSelectionMark();\n    }\n    document.removeEventListener('selectionchange', onSelectionChange);\n  };\n}\n\n// Hotfix to export these with inlined types #5918\nconst CAN_USE_BEFORE_INPUT = CAN_USE_BEFORE_INPUT$1;\nconst CAN_USE_DOM = CAN_USE_DOM$1;\nconst IS_ANDROID = IS_ANDROID$1;\nconst IS_ANDROID_CHROME = IS_ANDROID_CHROME$1;\nconst IS_APPLE = IS_APPLE$1;\nconst IS_APPLE_WEBKIT = IS_APPLE_WEBKIT$1;\nconst IS_CHROME = IS_CHROME$1;\nconst IS_FIREFOX = IS_FIREFOX$1;\nconst IS_IOS = IS_IOS$1;\nconst IS_SAFARI = IS_SAFARI$1;\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  const classesToAdd = normalizeClassNames(...classNames);\n  if (classesToAdd.length > 0) {\n    element.classList.add(...classesToAdd);\n  }\n}\n\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\nfunction removeClassNamesFromElement(element, ...classNames) {\n  const classesToRemove = normalizeClassNames(...classNames);\n  if (classesToRemove.length > 0) {\n    element.classList.remove(...classesToRemove);\n  }\n}\n\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', \\\\{\n *   src: file.result,\n * \\\\}));\n */\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n      if (done) {\n        return resolve(processed);\n      }\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n        handleNextFile();\n      });\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * \\\\{depth: number, node: LexicalNode\\\\} It will always return at least 1 node (the start node).\n */\nfunction $dfs(startNode, endNode) {\n  return Array.from($dfsIterator(startNode, endNode));\n}\n\n/**\n * Get the adjacent caret in the same direction\n *\n * @param caret A caret or null\n * @returns `caret.getAdjacentCaret()` or `null`\n */\nfunction $getAdjacentCaret(caret) {\n  return caret ? caret.getAdjacentCaret() : null;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfs(startNode, endNode) {\n  return Array.from($reverseDfsIterator(startNode, endNode));\n}\n\n/**\n * $dfs iterator (left to right). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $dfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('next', startNode, endNode);\n}\nfunction $getEndCaret(startNode, direction) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(startNode, direction));\n  return rval && rval[0];\n}\nfunction $dfsCaretIterator(direction, startNode, endNode) {\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const start = startNode || root;\n  const startCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(start) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(start, direction) : (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(start, direction);\n  const startDepth = $getDepth(start);\n  const endCaret = endNode ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaretOrSelf)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(endNode, direction))) : $getEndCaret(start, direction);\n  let depth = startDepth;\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.makeStepwiseIterator)({\n    hasNext: state => state !== null,\n    initial: startCaret,\n    map: state => ({\n      depth,\n      node: state.origin\n    }),\n    step: state => {\n      if (state.isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(state)) {\n        depth++;\n      }\n      const rval = $getAdjacentSiblingOrParentSiblingCaret(state);\n      if (!rval || rval[0].isSameNodeCaret(endCaret)) {\n        return null;\n      }\n      depth += rval[1];\n      return rval[0];\n    }\n  });\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getNextSiblingOrParentSibling(node) {\n  const rval = $getAdjacentSiblingOrParentSiblingCaret((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(node, 'next'));\n  return rval && [rval[0].origin, rval[1]];\n}\nfunction $getDepth(node) {\n  let depth = -1;\n  for (let innerNode = node; innerNode !== null; innerNode = innerNode.getParent()) {\n    depth++;\n  }\n  return depth;\n}\n\n/**\n * Performs a right-to-left preorder tree traversal.\n * From the starting node it goes to the rightmost child, than backtracks to parent and finds new rightmost path.\n * It will return the next node in traversal sequence after the startingNode.\n * The traversal is similar to $dfs functions above, but the nodes are visited right-to-left, not left-to-right.\n * @param startingNode - The node to start the search.\n * @returns The next node in pre-order right to left traversal sequence or `null`, if the node does not exist\n */\nfunction $getNextRightPreorderNode(startingNode) {\n  const startCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaretOrSelf)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(startingNode, 'previous'));\n  const next = $getAdjacentSiblingOrParentSiblingCaret(startCaret, 'root');\n  return next && next[0].origin;\n}\n\n/**\n * $dfs iterator (right to left). Tree traversal is done on the fly as new values are requested with O(1) memory.\n * @param startNode - The node to start the search, if omitted, it will start at the root node.\n * @param endNode - The node to end the search, if omitted, it will find all descendants of the startingNode.\n * @returns An iterator, each yielded value is a DFSNode. It will always return at least 1 node (the start node).\n */\nfunction $reverseDfsIterator(startNode, endNode) {\n  return $dfsCaretIterator('previous', startNode, endNode);\n}\n\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n    parent = parent.getParent();\n  }\n  return null;\n}\n\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(blockNode)) {\n    {\n      formatDevErrorMessage(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n  return blockNode;\n}\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nconst $findMatchingParent = (startingNode, findFn) => {\n  let curr = startingNode;\n  while (curr !== (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n    curr = curr.getParent();\n  }\n  return null;\n};\n\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n    let parentNode = node;\n    let childNode = node;\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n    return null;\n  };\n  const $elementNodeTransform = node => {\n    const match = $findMatch(node);\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match;\n\n      // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(targetNode, $elementNodeTransform);\n}\n\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n  for (const [key, node] of editorState._nodeMap) {\n    nodeMap.set(key, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties)(node));\n  }\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n  editor._dirtyType = FULL_RECONCILE;\n  const selection = editorState._selection;\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection === null ? null : selection.clone());\n}\n\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRoot(node) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  let initialCaret;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    initialCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$caretFromPoint)(selection.focus, 'next');\n  } else {\n    if (selection != null) {\n      const nodes = selection.getNodes();\n      const lastNode = nodes[nodes.length - 1];\n      if (lastNode) {\n        initialCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(lastNode, 'next');\n      }\n    }\n    initialCaret = initialCaret || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)(), 'previous').getFlipped().insert((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n  }\n  const insertCaret = $insertNodeToNearestRootAtCaret(node, initialCaret);\n  const adjacent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(insertCaret);\n  const selectionCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(adjacent) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)(adjacent) : insertCaret;\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelectionFromCaretRange)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCollapsedCaretRange)(selectionCaret));\n  return node.getLatest();\n}\n\n/**\n * If the insertion caret is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be inserted there, otherwise the parent nodes will be split according to the\n * given options.\n * @param node - The node to be inserted\n * @param caret - The location to insert or split from\n * @returns The node after its insertion\n */\nfunction $insertNodeToNearestRootAtCaret(node, caret, options) {\n  let insertCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCaretInDirection)(caret, 'next');\n  for (let nextCaret = insertCaret; nextCaret; nextCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$splitAtPointCaretNext)(nextCaret, options)) {\n    insertCaret = nextCaret;\n  }\n  if (!!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextPointCaret)(insertCaret)) {\n    formatDevErrorMessage(`$insertNodeToNearestRootAtCaret: An unattached TextNode can not be split`);\n  }\n  insertCaret.insert(node.isInline() ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)().append(node) : node);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCaretInDirection)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(node.getLatest(), 'next'), caret.direction);\n}\n\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexical element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexical element with the previous node appended within (as a child, including its children).\n */\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframes)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\nfunction $insertFirst(parent, node) {\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(parent, 'next').insert(node);\n}\nlet NEEDS_MANUAL_ZOOM = IS_FIREFOX || !CAN_USE_DOM ? false : undefined;\nfunction needsManualZoom() {\n  if (NEEDS_MANUAL_ZOOM === undefined) {\n    // If the browser implements standardized CSS zoom, then the client rect\n    // will be wider after zoom is applied\n    // https://chromestatus.com/feature/5198254868529152\n    // https://github.com/facebook/lexical/issues/6863\n    const div = document.createElement('div');\n    div.style.cssText = 'position: absolute; opacity: 0; width: 100px; left: -1000px;';\n    document.body.appendChild(div);\n    const noZoom = div.getBoundingClientRect();\n    div.style.setProperty('zoom', '2');\n    NEEDS_MANUAL_ZOOM = div.getBoundingClientRect().width === noZoom.width;\n    document.body.removeChild(div);\n  }\n  return NEEDS_MANUAL_ZOOM;\n}\n\n/**\n * Calculates the zoom level of an element as a result of using\n * css zoom property. For browsers that implement standardized CSS\n * zoom (Firefox, Chrome >= 128), this will always return 1.\n * @param element\n */\nfunction calculateZoomLevel(element) {\n  let zoom = 1;\n  if (needsManualZoom()) {\n    while (element) {\n      zoom *= Number(window.getComputedStyle(element).getPropertyValue('zoom'));\n      element = element.parentElement;\n    }\n  }\n  return zoom;\n}\n\n/**\n * Checks if the editor is a nested editor created by LexicalNestedComposer\n */\nfunction $isEditorIsNestedEditor(editor) {\n  return editor._parentEditor !== null;\n}\n\n/**\n * A depth first last-to-first traversal of root that stops at each node that matches\n * $predicate and ensures that its parent is root. This is typically used to discard\n * invalid or unsupported wrapping nodes. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * @param root The root to start the traversal\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns true if this unwrapped or removed any nodes\n */\nfunction $unwrapAndFilterDescendants(root, $predicate) {\n  return $unwrapAndFilterDescendantsImpl(root, $predicate, null);\n}\nfunction $unwrapAndFilterDescendantsImpl(root, $predicate, $onSuccess) {\n  let didMutate = false;\n  for (const node of $lastToFirstIterator(root)) {\n    if ($predicate(node)) {\n      if ($onSuccess !== null) {\n        $onSuccess(node);\n      }\n      continue;\n    }\n    didMutate = true;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      $unwrapAndFilterDescendantsImpl(node, $predicate, $onSuccess || (child => node.insertAfter(child)));\n    }\n    node.remove();\n  }\n  return didMutate;\n}\n\n/**\n * A depth first traversal of the children array that stops at and collects\n * each node that `$predicate` matches. This is typically used to discard\n * invalid or unsupported wrapping nodes on a children array in the `after`\n * of an {@link lexical!DOMConversionOutput}. For example, a TableNode must only have\n * TableRowNode as children, but an importer might add invalid nodes based on\n * caption, tbody, thead, etc. and this will unwrap and discard those.\n *\n * This function is read-only and performs no mutation operations, which makes\n * it suitable for import and export purposes but likely not for any in-place\n * mutation. You should use {@link $unwrapAndFilterDescendants} for in-place\n * mutations such as node transforms.\n *\n * @param children The children to traverse\n * @param $predicate Should return true for nodes that are permitted to be children of root\n * @returns The children or their descendants that match $predicate\n */\n\nfunction $descendantsMatching(children, $predicate) {\n  const result = [];\n  const stack = Array.from(children).reverse();\n  for (let child = stack.pop(); child !== undefined; child = stack.pop()) {\n    if ($predicate(child)) {\n      result.push(child);\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n      for (const grandchild of $lastToFirstIterator(child)) {\n        stack.push(grandchild);\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Return an iterator that yields each child of node from first to last, taking\n * care to preserve the next sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $firstToLastIterator(node) {\n  return $childIterator((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(node, 'next'));\n}\n\n/**\n * Return an iterator that yields each child of node from last to first, taking\n * care to preserve the previous sibling before yielding the value in case the caller\n * removes the yielded node.\n *\n * @param node The node whose children to iterate\n * @returns An iterator of the node's children\n */\nfunction $lastToFirstIterator(node) {\n  return $childIterator((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(node, 'previous'));\n}\nfunction $childIterator(startCaret) {\n  const seen = new Set() ;\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.makeStepwiseIterator)({\n    hasNext: lexical__WEBPACK_IMPORTED_MODULE_0__.$isSiblingCaret,\n    initial: startCaret.getAdjacentCaret(),\n    map: caret => {\n      const origin = caret.origin.getLatest();\n      if (seen !== null) {\n        const key = origin.getKey();\n        if (!!seen.has(key)) {\n          formatDevErrorMessage(`$childIterator: Cycle detected, node with key ${String(key)} has already been traversed`);\n        }\n        seen.add(key);\n      }\n      return origin;\n    },\n    step: caret => caret.getAdjacentCaret()\n  });\n}\n\n/**\n * Replace this node with its children\n *\n * @param node The ElementNode to unwrap and remove\n */\nfunction $unwrapNode(node) {\n  (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$rewindSiblingCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(node, 'next')).splice(1, node.getChildren());\n}\n\n/**\n * Returns the Node sibling when this exists, otherwise the closest parent sibling. For example\n * R -> P -> T1, T2\n *   -> P2\n * returns T2 for node T1, P2 for node T2, and null for node P2.\n * @param node LexicalNode.\n * @returns An array (tuple) containing the found Lexical node and the depth difference, or null, if this node doesn't exist.\n */\nfunction $getAdjacentSiblingOrParentSiblingCaret(startCaret, rootMode = 'root') {\n  let depthDiff = 0;\n  let caret = startCaret;\n  let nextCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(caret);\n  while (nextCaret === null) {\n    depthDiff--;\n    nextCaret = caret.getParentCaret(rootMode);\n    if (!nextCaret) {\n      return null;\n    }\n    caret = nextCaret;\n    nextCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(caret);\n  }\n  return nextCaret && [nextCaret, depthDiff];\n}\n\n/**\n * A wrapper that creates bound functions and methods for the\n * StateConfig to save some boilerplate when defining methods\n * or exporting only the accessors from your modules rather\n * than exposing the StateConfig directly.\n */\n\n/**\n * EXPERIMENTAL\n *\n * A convenience interface for working with {@link $getState} and\n * {@link $setState}.\n *\n * @param stateConfig The stateConfig to wrap with convenience functionality\n * @returns a StateWrapper\n */\nfunction makeStateWrapper(stateConfig) {\n  const $get = node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getState)(node, stateConfig);\n  const $set = (node, valueOrUpdater) => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setState)(node, stateConfig, valueOrUpdater);\n  return {\n    $get,\n    $set,\n    accessors: [$get, $set],\n    makeGetterMethod: () => function $getter() {\n      return $get(this);\n    },\n    makeSetterMethod: () => function $setter(valueOrUpdater) {\n      return $set(this, valueOrUpdater);\n    },\n    stateConfig\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrdXRpbHNAMC4zNS4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC91dGlscy9MZXhpY2FsVXRpbHMuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnaEI7QUFDdGE7QUFDN0M7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLE1BQU07QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0JBQWtCLDJFQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNEQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdURBQWM7QUFDOUMsb0JBQW9CLHVEQUFjO0FBQ2xDO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQWE7QUFDckMsV0FBVywwREFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNO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QUNBLGtCQUFrQiwrREFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQXNCO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGlCQUFpQjtBQUM5RCxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtEQUFTO0FBQ2hDLHlDQUF5QyxrREFBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRTg2QiIsInNvdXJjZXMiOlsiL1VzZXJzL2xhdXJhZ2FyY2lhL2tpc3NsYWJzL3BheWxvYWQvYXN0cm8tcGF5bG9hZC9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrdXRpbHNAMC4zNS4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC91dGlscy9MZXhpY2FsVXRpbHMuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQsICRnZXRTZWxlY3Rpb24sICRpc1JhbmdlU2VsZWN0aW9uLCAkaXNFbGVtZW50Tm9kZSwgZ2V0RE9NVGV4dE5vZGUsICRnZXRSb290LCAkZ2V0Q2hpbGRDYXJldCwgJGdldFNpYmxpbmdDYXJldCwgJGdldEFkamFjZW50Q2hpbGRDYXJldCwgJGdldENoaWxkQ2FyZXRPclNlbGYsIG1ha2VTdGVwd2lzZUl0ZXJhdG9yLCAkaXNDaGlsZENhcmV0LCAkY2xvbmVXaXRoUHJvcGVydGllcywgJHNldFNlbGVjdGlvbiwgJGdldFByZXZpb3VzU2VsZWN0aW9uLCAkY2FyZXRGcm9tUG9pbnQsICRjcmVhdGVQYXJhZ3JhcGhOb2RlLCAkbm9ybWFsaXplQ2FyZXQsICRzZXRTZWxlY3Rpb25Gcm9tQ2FyZXRSYW5nZSwgJGdldENvbGxhcHNlZENhcmV0UmFuZ2UsICRnZXRDYXJldEluRGlyZWN0aW9uLCAkc3BsaXRBdFBvaW50Q2FyZXROZXh0LCAkaXNUZXh0UG9pbnRDYXJldCwgJGlzU2libGluZ0NhcmV0LCAkcmV3aW5kU2libGluZ0NhcmV0LCAkZ2V0U3RhdGUsICRzZXRTdGF0ZSB9IGZyb20gJ2xleGljYWwnO1xuZXhwb3J0IHsgJHNwbGl0Tm9kZSwgaXNCbG9ja0RvbU5vZGUsIGlzSFRNTEFuY2hvckVsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzSW5saW5lRG9tTm9kZSB9IGZyb20gJ2xleGljYWwnO1xuaW1wb3J0IHsgY3JlYXRlUmVjdHNGcm9tRE9NUmFuZ2UgfSBmcm9tICdAbGV4aWNhbC9zZWxlY3Rpb24nO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzLlxuXG5mdW5jdGlvbiBmb3JtYXREZXZFcnJvck1lc3NhZ2UobWVzc2FnZSkge1xuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgQ0FOX1VTRV9ET00kMSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuY29uc3QgZG9jdW1lbnRNb2RlID0gQ0FOX1VTRV9ET00kMSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IG51bGw7XG5jb25zdCBJU19BUFBMRSQxID0gQ0FOX1VTRV9ET00kMSAmJiAvTWFjfGlQb2R8aVBob25lfGlQYWQvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbmNvbnN0IElTX0ZJUkVGT1gkMSA9IENBTl9VU0VfRE9NJDEgJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3gpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuY29uc3QgQ0FOX1VTRV9CRUZPUkVfSU5QVVQkMSA9IENBTl9VU0VfRE9NJDEgJiYgJ0lucHV0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlID8gJ2dldFRhcmdldFJhbmdlcycgaW4gbmV3IHdpbmRvdy5JbnB1dEV2ZW50KCdpbnB1dCcpIDogZmFsc2U7XG5jb25zdCBJU19TQUZBUkkkMSA9IENBTl9VU0VfRE9NJDEgJiYgL1ZlcnNpb25cXC9bXFxkLl0rLipTYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5jb25zdCBJU19JT1MkMSA9IENBTl9VU0VfRE9NJDEgJiYgL2lQYWR8aVBob25lfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbTtcbmNvbnN0IElTX0FORFJPSUQkMSA9IENBTl9VU0VfRE9NJDEgJiYgL0FuZHJvaWQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8vIEtlZXAgdGhlc2UgaW4gY2FzZSB3ZSBuZWVkIHRvIHVzZSB0aGVtIGluIHRoZSBmdXR1cmUuXG4vLyBleHBvcnQgY29uc3QgSVNfV0lORE9XUzogYm9vbGVhbiA9IENBTl9VU0VfRE9NICYmIC9XaW4vLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbmNvbnN0IElTX0NIUk9NRSQxID0gQ0FOX1VTRV9ET00kMSAmJiAvXig/PS4qQ2hyb21lKS4qL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbi8vIGV4cG9ydCBjb25zdCBjYW5Vc2VUZXh0SW5wdXRFdmVudDogYm9vbGVhbiA9IENBTl9VU0VfRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlO1xuXG5jb25zdCBJU19BTkRST0lEX0NIUk9NRSQxID0gQ0FOX1VTRV9ET00kMSAmJiBJU19BTkRST0lEJDEgJiYgSVNfQ0hST01FJDE7XG5jb25zdCBJU19BUFBMRV9XRUJLSVQkMSA9IENBTl9VU0VfRE9NJDEgJiYgL0FwcGxlV2ViS2l0XFwvW1xcZC5dKy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhSVNfQ0hST01FJDE7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IHJ2YWwgPSBbXTtcbiAgZm9yIChjb25zdCBjbGFzc05hbWUgb2YgY2xhc3NOYW1lcykge1xuICAgIGlmIChjbGFzc05hbWUgJiYgdHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAoY29uc3QgW3NdIG9mIGNsYXNzTmFtZS5tYXRjaEFsbCgvXFxTKy9nKSkge1xuICAgICAgICBydmFsLnB1c2gocyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBleGVjdXRlIGFsbCBmdW5jdGlvbnMgcGFzc2VkIHdoZW4gY2FsbGVkLiBJdCBpcyBnZW5lcmFsbHkgdXNlZFxuICogdG8gcmVnaXN0ZXIgbXVsdGlwbGUgbGV4aWNhbCBsaXN0ZW5lcnMgYW5kIHRoZW4gdGVhciB0aGVtIGRvd24gd2l0aCBhIHNpbmdsZSBmdW5jdGlvbiBjYWxsLCBzdWNoXG4gKiBhcyBSZWFjdCdzIHVzZUVmZmVjdCBob29rLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiB1c2VFZmZlY3QoKCkgPT4ge1xuICogICByZXR1cm4gbWVyZ2VSZWdpc3RlcihcbiAqICAgICBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKC4uLnJlZ2lzdGVyQ29tbWFuZDEgbG9naWMpLFxuICogICAgIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoLi4ucmVnaXN0ZXJDb21tYW5kMiBsb2dpYyksXG4gKiAgICAgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZCguLi5yZWdpc3RlckNvbW1hbmQzIGxvZ2ljKVxuICogICApXG4gKiB9LCBbZWRpdG9yXSlcbiAqIGBgYFxuICogSW4gdGhpcyBjYXNlLCB1c2VFZmZlY3QgaXMgcmV0dXJuaW5nIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBtZXJnZVJlZ2lzdGVyIGFzIGEgY2xlYW51cFxuICogZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgZWl0aGVyIHRoZSB1c2VFZmZlY3QgcnVucyBhZ2FpbiAoZHVlIHRvIG9uZSBvZiBpdHMgZGVwZW5kZW5jaWVzXG4gKiB1cGRhdGluZykgb3IgdGhlIGNvbXBvbmVudCBpdCByZXNpZGVzIGluIHVubW91bnRzLlxuICogTm90ZSB0aGUgZnVuY3Rpb25zIGRvbid0IG5lY2Vzc2FyaWx5IG5lZWQgdG8gYmUgaW4gYW4gYXJyYXkgYXMgYWxsIGFyZ3VtZW50c1xuICogYXJlIGNvbnNpZGVyZWQgdG8gYmUgdGhlIGZ1bmMgYXJndW1lbnQgYW5kIHNwcmVhZCBmcm9tIHRoZXJlLlxuICogVGhlIG9yZGVyIG9mIGNsZWFudXAgaXMgdGhlIHJldmVyc2Ugb2YgdGhlIGFyZ3VtZW50IG9yZGVyLiBHZW5lcmFsbHkgaXQgaXNcbiAqIGV4cGVjdGVkIHRoYXQgdGhlIGZpcnN0IFwiYWNxdWlyZVwiIHdpbGwgYmUgXCJyZWxlYXNlZFwiIGxhc3QgKExJRk8gb3JkZXIpLFxuICogYmVjYXVzZSBhIGxhdGVyIHN0ZXAgbWF5IGhhdmUgc29tZSBkZXBlbmRlbmN5IG9uIGFuIGVhcmxpZXIgb25lLlxuICogQHBhcmFtIGZ1bmMgLSBBbiBhcnJheSBvZiBjbGVhbnVwIGZ1bmN0aW9ucyBtZWFudCB0byBiZSBleGVjdXRlZCBieSB0aGUgcmV0dXJuZWQgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB0aGUgZnVuY3Rpb24gd2hpY2ggZXhlY3V0ZXMgYWxsIHRoZSBwYXNzZWQgY2xlYW51cCBmdW5jdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlUmVnaXN0ZXIoLi4uZnVuYykge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGZvciAobGV0IGkgPSBmdW5jLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBmdW5jW2ldKCk7XG4gICAgfVxuICAgIC8vIENsZWFuIHVwIHRoZSByZWZlcmVuY2VzIGFuZCBtYWtlIGZ1dHVyZSBjYWxscyBhIG5vLW9wXG4gICAgZnVuYy5sZW5ndGggPSAwO1xuICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uIHB4KHZhbHVlKSB7XG4gIHJldHVybiBgJHt2YWx1ZX1weGA7XG59XG5cbmNvbnN0IG11dGF0aW9uT2JzZXJ2ZXJDb25maWcgPSB7XG4gIGF0dHJpYnV0ZXM6IHRydWUsXG4gIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gIGNoaWxkTGlzdDogdHJ1ZSxcbiAgc3VidHJlZTogdHJ1ZVxufTtcbmZ1bmN0aW9uIHByZXBlbmRET01Ob2RlKHBhcmVudCwgbm9kZSkge1xuICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUsIHBhcmVudC5maXJzdENoaWxkKTtcbn1cblxuLyoqXG4gKiBQbGFjZSBvbmUgb3IgbXVsdGlwbGUgbmV3bHkgY3JlYXRlZCBOb2RlcyBhdCB0aGUgcGFzc2VkIFJhbmdlJ3MgcG9zaXRpb24uXG4gKiBNdWx0aXBsZSBub2RlcyB3aWxsIG9ubHkgYmUgY3JlYXRlZCB3aGVuIHRoZSBSYW5nZSBzcGFucyBtdWx0aXBsZSBsaW5lcyAoYWthXG4gKiBjbGllbnQgcmVjdHMpLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGNvbWUgcGFydGljdWxhcmx5IHVzZWZ1bCB0byBoaWdobGlnaHQgcGFydGljdWxhciBwYXJ0cyBvZlxuICogdGhlIHRleHQgd2l0aG91dCBpbnRlcmZlcmluZyB3aXRoIHRoZSBFZGl0b3JTdGF0ZSwgdGhhdCB3aWxsIG9mdGVuIHJlcGxpY2F0ZVxuICogdGhlIHN0YXRlIGFjcm9zcyBjb2xsYWIgYW5kIGNsaXBib2FyZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY291bnRzIGZvciBET00gdXBkYXRlcyB3aGljaCBjYW4gbW9kaWZ5IHRoZSBwYXNzZWQgUmFuZ2UuXG4gKiBIZW5jZSwgdGhlIGZ1bmN0aW9uIHJldHVybiB0byByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICovXG5mdW5jdGlvbiBtbGNQb3NpdGlvbk5vZGVPblJhbmdlKGVkaXRvciwgcmFuZ2UsIG9uUmVwb3NpdGlvbikge1xuICBsZXQgcm9vdERPTU5vZGUgPSBudWxsO1xuICBsZXQgcGFyZW50RE9NTm9kZSA9IG51bGw7XG4gIGxldCBvYnNlcnZlciA9IG51bGw7XG4gIGxldCBsYXN0Tm9kZXMgPSBbXTtcbiAgY29uc3Qgd3JhcHBlck5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgd3JhcHBlck5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICBmdW5jdGlvbiBwb3NpdGlvbigpIHtcbiAgICBpZiAoIShyb290RE9NTm9kZSAhPT0gbnVsbCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgVW5leHBlY3RlZCBudWxsIHJvb3RET01Ob2RlYCk7XG4gICAgfVxuICAgIGlmICghKHBhcmVudERPTU5vZGUgIT09IG51bGwpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFVuZXhwZWN0ZWQgbnVsbCBwYXJlbnRET01Ob2RlYCk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGxlZnQ6IHBhcmVudExlZnQsXG4gICAgICB0b3A6IHBhcmVudFRvcFxuICAgIH0gPSBwYXJlbnRET01Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IHJlY3RzID0gY3JlYXRlUmVjdHNGcm9tRE9NUmFuZ2UoZWRpdG9yLCByYW5nZSk7XG4gICAgaWYgKCF3cmFwcGVyTm9kZS5pc0Nvbm5lY3RlZCkge1xuICAgICAgcHJlcGVuZERPTU5vZGUocGFyZW50RE9NTm9kZSwgd3JhcHBlck5vZGUpO1xuICAgIH1cbiAgICBsZXQgaGFzUmVwb3NpdGlvbmVkID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVjdCA9IHJlY3RzW2ldO1xuICAgICAgLy8gVHJ5IHRvIHJldXNlIHRoZSBwcmV2aW91c2x5IGNyZWF0ZWQgTm9kZSB3aGVuIHBvc3NpYmxlLCBubyBuZWVkIHRvXG4gICAgICAvLyByZW1vdmUvY3JlYXRlIG9uIHRoZSBtb3N0IGNvbW1vbiBjYXNlIHJlcG9zaXRpb24gY2FzZVxuICAgICAgY29uc3QgcmVjdE5vZGUgPSBsYXN0Tm9kZXNbaV0gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb25zdCByZWN0Tm9kZVN0eWxlID0gcmVjdE5vZGUuc3R5bGU7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS5wb3NpdGlvbiAhPT0gJ2Fic29sdXRlJykge1xuICAgICAgICByZWN0Tm9kZVN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxlZnQgPSBweChyZWN0LmxlZnQgLSBwYXJlbnRMZWZ0KTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLmxlZnQgIT09IGxlZnQpIHtcbiAgICAgICAgcmVjdE5vZGVTdHlsZS5sZWZ0ID0gbGVmdDtcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRvcCA9IHB4KHJlY3QudG9wIC0gcGFyZW50VG9wKTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLnRvcCAhPT0gdG9wKSB7XG4gICAgICAgIHJlY3ROb2RlLnN0eWxlLnRvcCA9IHRvcDtcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHdpZHRoID0gcHgocmVjdC53aWR0aCk7XG4gICAgICBpZiAocmVjdE5vZGVTdHlsZS53aWR0aCAhPT0gd2lkdGgpIHtcbiAgICAgICAgcmVjdE5vZGUuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhlaWdodCA9IHB4KHJlY3QuaGVpZ2h0KTtcbiAgICAgIGlmIChyZWN0Tm9kZVN0eWxlLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgIHJlY3ROb2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgaGFzUmVwb3NpdGlvbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChyZWN0Tm9kZS5wYXJlbnROb2RlICE9PSB3cmFwcGVyTm9kZSkge1xuICAgICAgICB3cmFwcGVyTm9kZS5hcHBlbmQocmVjdE5vZGUpO1xuICAgICAgICBoYXNSZXBvc2l0aW9uZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgbGFzdE5vZGVzW2ldID0gcmVjdE5vZGU7XG4gICAgfVxuICAgIHdoaWxlIChsYXN0Tm9kZXMubGVuZ3RoID4gcmVjdHMubGVuZ3RoKSB7XG4gICAgICBsYXN0Tm9kZXMucG9wKCk7XG4gICAgfVxuICAgIGlmIChoYXNSZXBvc2l0aW9uZWQpIHtcbiAgICAgIG9uUmVwb3NpdGlvbihsYXN0Tm9kZXMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHBhcmVudERPTU5vZGUgPSBudWxsO1xuICAgIHJvb3RET01Ob2RlID0gbnVsbDtcbiAgICBpZiAob2JzZXJ2ZXIgIT09IG51bGwpIHtcbiAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gICAgb2JzZXJ2ZXIgPSBudWxsO1xuICAgIHdyYXBwZXJOb2RlLnJlbW92ZSgpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBsYXN0Tm9kZXMpIHtcbiAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgfVxuICAgIGxhc3ROb2RlcyA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHJlc3RhcnQoKSB7XG4gICAgY29uc3QgY3VycmVudFJvb3RET01Ob2RlID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gICAgaWYgKGN1cnJlbnRSb290RE9NTm9kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFBhcmVudERPTU5vZGUgPSBjdXJyZW50Um9vdERPTU5vZGUucGFyZW50RWxlbWVudDtcbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoY3VycmVudFBhcmVudERPTU5vZGUpKSB7XG4gICAgICByZXR1cm4gc3RvcCgpO1xuICAgIH1cbiAgICBzdG9wKCk7XG4gICAgcm9vdERPTU5vZGUgPSBjdXJyZW50Um9vdERPTU5vZGU7XG4gICAgcGFyZW50RE9NTm9kZSA9IGN1cnJlbnRQYXJlbnRET01Ob2RlO1xuICAgIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zID0+IHtcbiAgICAgIGNvbnN0IG5leHRSb290RE9NTm9kZSA9IGVkaXRvci5nZXRSb290RWxlbWVudCgpO1xuICAgICAgY29uc3QgbmV4dFBhcmVudERPTU5vZGUgPSBuZXh0Um9vdERPTU5vZGUgJiYgbmV4dFJvb3RET01Ob2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICBpZiAobmV4dFJvb3RET01Ob2RlICE9PSByb290RE9NTm9kZSB8fCBuZXh0UGFyZW50RE9NTm9kZSAhPT0gcGFyZW50RE9NTm9kZSkge1xuICAgICAgICByZXR1cm4gcmVzdGFydCgpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKCF3cmFwcGVyTm9kZS5jb250YWlucyhtdXRhdGlvbi50YXJnZXQpKSB7XG4gICAgICAgICAgLy8gVE9ETyB0aHJvdHRsZVxuICAgICAgICAgIHJldHVybiBwb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShjdXJyZW50UGFyZW50RE9NTm9kZSwgbXV0YXRpb25PYnNlcnZlckNvbmZpZyk7XG4gICAgcG9zaXRpb24oKTtcbiAgfVxuICBjb25zdCByZW1vdmVSb290TGlzdGVuZXIgPSBlZGl0b3IucmVnaXN0ZXJSb290TGlzdGVuZXIocmVzdGFydCk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgcmVtb3ZlUm9vdExpc3RlbmVyKCk7XG4gICAgc3RvcCgpO1xuICB9O1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmZ1bmN0aW9uICRnZXRPcmRlcmVkU2VsZWN0aW9uUG9pbnRzKHNlbGVjdGlvbikge1xuICBjb25zdCBwb2ludHMgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbmRQb2ludHMoKTtcbiAgcmV0dXJuIHNlbGVjdGlvbi5pc0JhY2t3YXJkKCkgPyBbcG9pbnRzWzFdLCBwb2ludHNbMF1dIDogcG9pbnRzO1xufVxuZnVuY3Rpb24gcmFuZ2VUYXJnZXRGcm9tUG9pbnQocG9pbnQsIG5vZGUsIGRvbSkge1xuICBpZiAocG9pbnQudHlwZSA9PT0gJ3RleHQnIHx8ICEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgIGNvbnN0IHRleHRET00gPSBnZXRET01UZXh0Tm9kZShkb20pIHx8IGRvbTtcbiAgICByZXR1cm4gW3RleHRET00sIHBvaW50Lm9mZnNldF07XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2xvdCA9IG5vZGUuZ2V0RE9NU2xvdChkb20pO1xuICAgIHJldHVybiBbc2xvdC5lbGVtZW50LCBzbG90LmdldEZpcnN0Q2hpbGRPZmZzZXQoKSArIHBvaW50Lm9mZnNldF07XG4gIH1cbn1cbmZ1bmN0aW9uIHJhbmdlRnJvbVBvaW50cyhlZGl0b3IsIHN0YXJ0LCBzdGFydE5vZGUsIHN0YXJ0RE9NLCBlbmQsIGVuZE5vZGUsIGVuZERPTSkge1xuICBjb25zdCBlZGl0b3JEb2N1bWVudCA9IGVkaXRvci5fd2luZG93ID8gZWRpdG9yLl93aW5kb3cuZG9jdW1lbnQgOiBkb2N1bWVudDtcbiAgY29uc3QgcmFuZ2UgPSBlZGl0b3JEb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydCguLi5yYW5nZVRhcmdldEZyb21Qb2ludChzdGFydCwgc3RhcnROb2RlLCBzdGFydERPTSkpO1xuICByYW5nZS5zZXRFbmQoLi4ucmFuZ2VUYXJnZXRGcm9tUG9pbnQoZW5kLCBlbmROb2RlLCBlbmRET00pKTtcbiAgcmV0dXJuIHJhbmdlO1xufVxuLyoqXG4gKiBQbGFjZSBvbmUgb3IgbXVsdGlwbGUgbmV3bHkgY3JlYXRlZCBOb2RlcyBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uIE11bHRpcGxlXG4gKiBub2RlcyB3aWxsIG9ubHkgYmUgY3JlYXRlZCB3aGVuIHRoZSBzZWxlY3Rpb24gc3BhbnMgbXVsdGlwbGUgbGluZXMgKGFrYVxuICogY2xpZW50IHJlY3RzKS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBjb21lIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRvIHNob3cgdGhlIHNlbGVjdGlvbiBidXQgdGhlXG4gKiBlZGl0b3IgaGFzIGJlZW4gZm9jdXNlZCBhd2F5LlxuICovXG5mdW5jdGlvbiBtYXJrU2VsZWN0aW9uKGVkaXRvciwgb25SZXBvc2l0aW9uKSB7XG4gIGxldCBwcmV2aW91c0FuY2hvck5vZGUgPSBudWxsO1xuICBsZXQgcHJldmlvdXNBbmNob3JOb2RlRE9NID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzQW5jaG9yT2Zmc2V0ID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzRm9jdXNOb2RlID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzRm9jdXNOb2RlRE9NID0gbnVsbDtcbiAgbGV0IHByZXZpb3VzRm9jdXNPZmZzZXQgPSBudWxsO1xuICBsZXQgcmVtb3ZlUmFuZ2VMaXN0ZW5lciA9ICgpID0+IHt9O1xuICBmdW5jdGlvbiBjb21wdXRlKGVkaXRvclN0YXRlKSB7XG4gICAgZWRpdG9yU3RhdGUucmVhZCgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBwcmV2aW91c0FuY2hvck5vZGUgPSBudWxsO1xuICAgICAgICBwcmV2aW91c0FuY2hvck9mZnNldCA9IG51bGw7XG4gICAgICAgIHByZXZpb3VzRm9jdXNOb2RlID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXNGb2N1c09mZnNldCA9IG51bGw7XG4gICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIoKTtcbiAgICAgICAgcmVtb3ZlUmFuZ2VMaXN0ZW5lciA9ICgpID0+IHt9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSAkZ2V0T3JkZXJlZFNlbGVjdGlvblBvaW50cyhzZWxlY3Rpb24pO1xuICAgICAgY29uc3QgY3VycmVudFN0YXJ0Tm9kZSA9IHN0YXJ0LmdldE5vZGUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRTdGFydE5vZGVLZXkgPSBjdXJyZW50U3RhcnROb2RlLmdldEtleSgpO1xuICAgICAgY29uc3QgY3VycmVudFN0YXJ0T2Zmc2V0ID0gc3RhcnQub2Zmc2V0O1xuICAgICAgY29uc3QgY3VycmVudEVuZE5vZGUgPSBlbmQuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgY3VycmVudEVuZE5vZGVLZXkgPSBjdXJyZW50RW5kTm9kZS5nZXRLZXkoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRFbmRPZmZzZXQgPSBlbmQub2Zmc2V0O1xuICAgICAgY29uc3QgY3VycmVudFN0YXJ0Tm9kZURPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoY3VycmVudFN0YXJ0Tm9kZUtleSk7XG4gICAgICBjb25zdCBjdXJyZW50RW5kTm9kZURPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoY3VycmVudEVuZE5vZGVLZXkpO1xuICAgICAgY29uc3QgZGlmZmVyZW50U3RhcnRET00gPSBwcmV2aW91c0FuY2hvck5vZGUgPT09IG51bGwgfHwgY3VycmVudFN0YXJ0Tm9kZURPTSAhPT0gcHJldmlvdXNBbmNob3JOb2RlRE9NIHx8IGN1cnJlbnRTdGFydE9mZnNldCAhPT0gcHJldmlvdXNBbmNob3JPZmZzZXQgfHwgY3VycmVudFN0YXJ0Tm9kZUtleSAhPT0gcHJldmlvdXNBbmNob3JOb2RlLmdldEtleSgpO1xuICAgICAgY29uc3QgZGlmZmVyZW50RW5kRE9NID0gcHJldmlvdXNGb2N1c05vZGUgPT09IG51bGwgfHwgY3VycmVudEVuZE5vZGVET00gIT09IHByZXZpb3VzRm9jdXNOb2RlRE9NIHx8IGN1cnJlbnRFbmRPZmZzZXQgIT09IHByZXZpb3VzRm9jdXNPZmZzZXQgfHwgY3VycmVudEVuZE5vZGVLZXkgIT09IHByZXZpb3VzRm9jdXNOb2RlLmdldEtleSgpO1xuICAgICAgaWYgKChkaWZmZXJlbnRTdGFydERPTSB8fCBkaWZmZXJlbnRFbmRET00pICYmIGN1cnJlbnRTdGFydE5vZGVET00gIT09IG51bGwgJiYgY3VycmVudEVuZE5vZGVET00gIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSByYW5nZUZyb21Qb2ludHMoZWRpdG9yLCBzdGFydCwgY3VycmVudFN0YXJ0Tm9kZSwgY3VycmVudFN0YXJ0Tm9kZURPTSwgZW5kLCBjdXJyZW50RW5kTm9kZSwgY3VycmVudEVuZE5vZGVET00pO1xuICAgICAgICByZW1vdmVSYW5nZUxpc3RlbmVyKCk7XG4gICAgICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIgPSBtbGNQb3NpdGlvbk5vZGVPblJhbmdlKGVkaXRvciwgcmFuZ2UsIGRvbU5vZGVzID0+IHtcbiAgICAgICAgICBpZiAob25SZXBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZG9tTm9kZSBvZiBkb21Ob2Rlcykge1xuICAgICAgICAgICAgICBjb25zdCBkb21Ob2RlU3R5bGUgPSBkb21Ob2RlLnN0eWxlO1xuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLmJhY2tncm91bmQgIT09ICdIaWdobGlnaHQnKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLmJhY2tncm91bmQgPSAnSGlnaGxpZ2h0JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZG9tTm9kZVN0eWxlLmNvbG9yICE9PSAnSGlnaGxpZ2h0VGV4dCcpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUuY29sb3IgPSAnSGlnaGxpZ2h0VGV4dCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGRvbU5vZGVTdHlsZS5tYXJnaW5Ub3AgIT09IHB4KC0xLjUpKSB7XG4gICAgICAgICAgICAgICAgZG9tTm9kZVN0eWxlLm1hcmdpblRvcCA9IHB4KC0xLjUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucGFkZGluZ1RvcCAhPT0gcHgoNCkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUucGFkZGluZ1RvcCA9IHB4KDQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlU3R5bGUucGFkZGluZ0JvdHRvbSAhPT0gcHgoMCkpIHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlU3R5bGUucGFkZGluZ0JvdHRvbSA9IHB4KDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9uUmVwb3NpdGlvbihkb21Ob2Rlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzQW5jaG9yTm9kZSA9IGN1cnJlbnRTdGFydE5vZGU7XG4gICAgICBwcmV2aW91c0FuY2hvck5vZGVET00gPSBjdXJyZW50U3RhcnROb2RlRE9NO1xuICAgICAgcHJldmlvdXNBbmNob3JPZmZzZXQgPSBjdXJyZW50U3RhcnRPZmZzZXQ7XG4gICAgICBwcmV2aW91c0ZvY3VzTm9kZSA9IGN1cnJlbnRFbmROb2RlO1xuICAgICAgcHJldmlvdXNGb2N1c05vZGVET00gPSBjdXJyZW50RW5kTm9kZURPTTtcbiAgICAgIHByZXZpb3VzRm9jdXNPZmZzZXQgPSBjdXJyZW50RW5kT2Zmc2V0O1xuICAgIH0pO1xuICB9XG4gIGNvbXB1dGUoZWRpdG9yLmdldEVkaXRvclN0YXRlKCkpO1xuICByZXR1cm4gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJVcGRhdGVMaXN0ZW5lcigoe1xuICAgIGVkaXRvclN0YXRlXG4gIH0pID0+IGNvbXB1dGUoZWRpdG9yU3RhdGUpKSwgKCkgPT4ge1xuICAgIHJlbW92ZVJhbmdlTGlzdGVuZXIoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0aW9uQWx3YXlzT25EaXNwbGF5KGVkaXRvcikge1xuICBsZXQgcmVtb3ZlU2VsZWN0aW9uTWFyayA9IG51bGw7XG4gIGNvbnN0IG9uU2VsZWN0aW9uQ2hhbmdlID0gKCkgPT4ge1xuICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbigpO1xuICAgIGNvbnN0IGRvbUFuY2hvck5vZGUgPSBkb21TZWxlY3Rpb24gJiYgZG9tU2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gICAgY29uc3QgZWRpdG9yUm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgICBjb25zdCBpc1NlbGVjdGlvbkluc2lkZUVkaXRvciA9IGRvbUFuY2hvck5vZGUgIT09IG51bGwgJiYgZWRpdG9yUm9vdEVsZW1lbnQgIT09IG51bGwgJiYgZWRpdG9yUm9vdEVsZW1lbnQuY29udGFpbnMoZG9tQW5jaG9yTm9kZSk7XG4gICAgaWYgKGlzU2VsZWN0aW9uSW5zaWRlRWRpdG9yKSB7XG4gICAgICBpZiAocmVtb3ZlU2VsZWN0aW9uTWFyayAhPT0gbnVsbCkge1xuICAgICAgICByZW1vdmVTZWxlY3Rpb25NYXJrKCk7XG4gICAgICAgIHJlbW92ZVNlbGVjdGlvbk1hcmsgPSBudWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocmVtb3ZlU2VsZWN0aW9uTWFyayA9PT0gbnVsbCkge1xuICAgICAgICByZW1vdmVTZWxlY3Rpb25NYXJrID0gbWFya1NlbGVjdGlvbihlZGl0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2VsZWN0aW9uY2hhbmdlJywgb25TZWxlY3Rpb25DaGFuZ2UpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGlmIChyZW1vdmVTZWxlY3Rpb25NYXJrICE9PSBudWxsKSB7XG4gICAgICByZW1vdmVTZWxlY3Rpb25NYXJrKCk7XG4gICAgfVxuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIG9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgfTtcbn1cblxuLy8gSG90Zml4IHRvIGV4cG9ydCB0aGVzZSB3aXRoIGlubGluZWQgdHlwZXMgIzU5MThcbmNvbnN0IENBTl9VU0VfQkVGT1JFX0lOUFVUID0gQ0FOX1VTRV9CRUZPUkVfSU5QVVQkMTtcbmNvbnN0IENBTl9VU0VfRE9NID0gQ0FOX1VTRV9ET00kMTtcbmNvbnN0IElTX0FORFJPSUQgPSBJU19BTkRST0lEJDE7XG5jb25zdCBJU19BTkRST0lEX0NIUk9NRSA9IElTX0FORFJPSURfQ0hST01FJDE7XG5jb25zdCBJU19BUFBMRSA9IElTX0FQUExFJDE7XG5jb25zdCBJU19BUFBMRV9XRUJLSVQgPSBJU19BUFBMRV9XRUJLSVQkMTtcbmNvbnN0IElTX0NIUk9NRSA9IElTX0NIUk9NRSQxO1xuY29uc3QgSVNfRklSRUZPWCA9IElTX0ZJUkVGT1gkMTtcbmNvbnN0IElTX0lPUyA9IElTX0lPUyQxO1xuY29uc3QgSVNfU0FGQVJJID0gSVNfU0FGQVJJJDE7XG5cbi8qKlxuICogVGFrZXMgYW4gSFRNTCBlbGVtZW50IGFuZCBhZGRzIHRoZSBjbGFzc05hbWVzIHBhc3NlZCB3aXRoaW4gYW4gYXJyYXksXG4gKiBpZ25vcmluZyBhbnkgbm9uLXN0cmluZyB0eXBlcy4gQSBzcGFjZSBjYW4gYmUgdXNlZCB0byBhZGQgbXVsdGlwbGUgY2xhc3Nlc1xuICogZWcuIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgWydlbGVtZW50LWlubmVyIGFjdGl2ZScsIHRydWUsIG51bGxdKVxuICogd2lsbCBhZGQgYm90aCAnZWxlbWVudC1pbm5lcicgYW5kICdhY3RpdmUnIGFzIGNsYXNzZXMgdG8gdGhhdCBlbGVtZW50LlxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgY2xhc3NlcyBhcmUgYWRkZWRcbiAqIEBwYXJhbSBjbGFzc05hbWVzIC0gQW4gYXJyYXkgZGVmaW5pbmcgdGhlIGNsYXNzIG5hbWVzIHRvIGFkZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgY2xhc3Nlc1RvQWRkID0gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKTtcbiAgaWYgKGNsYXNzZXNUb0FkZC5sZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzZXNUb0FkZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUYWtlcyBhbiBIVE1MIGVsZW1lbnQgYW5kIHJlbW92ZXMgdGhlIGNsYXNzTmFtZXMgcGFzc2VkIHdpdGhpbiBhbiBhcnJheSxcbiAqIGlnbm9yaW5nIGFueSBub24tc3RyaW5nIHR5cGVzLiBBIHNwYWNlIGNhbiBiZSB1c2VkIHRvIHJlbW92ZSBtdWx0aXBsZSBjbGFzc2VzXG4gKiBlZy4gcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGVsZW1lbnQsIFsnYWN0aXZlIHNtYWxsJywgdHJ1ZSwgbnVsbF0pXG4gKiB3aWxsIHJlbW92ZSBib3RoIHRoZSAnYWN0aXZlJyBhbmQgJ3NtYWxsJyBjbGFzc2VzIGZyb20gdGhhdCBlbGVtZW50LlxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCBpbiB3aGljaCB0aGUgY2xhc3NlcyBhcmUgcmVtb3ZlZFxuICogQHBhcmFtIGNsYXNzTmFtZXMgLSBBbiBhcnJheSBkZWZpbmluZyB0aGUgY2xhc3MgbmFtZXMgdG8gcmVtb3ZlIGZyb20gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGVsZW1lbnQsIC4uLmNsYXNzTmFtZXMpIHtcbiAgY29uc3QgY2xhc3Nlc1RvUmVtb3ZlID0gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKTtcbiAgaWYgKGNsYXNzZXNUb1JlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKC4uLmNsYXNzZXNUb1JlbW92ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZpbGUgdHlwZSBtYXRjaGVzIHRoZSB0eXBlcyBwYXNzZWQgd2l0aGluIHRoZSBhY2NlcHRhYmxlTWltZVR5cGVzIGFycmF5LCBmYWxzZSBvdGhlcndpc2UuXG4gKiBUaGUgdHlwZXMgcGFzc2VkIG11c3QgYmUgc3RyaW5ncyBhbmQgYXJlIENBU0UtU0VOU0lUSVZFLlxuICogZWcuIGlmIGZpbGUgaXMgb2YgdHlwZSAndGV4dCcgYW5kIGFjY2VwdGFibGVNaW1lVHlwZXMgPSBbJ1RFWFQnLCAnSU1BR0UnXSB0aGUgZnVuY3Rpb24gd2lsbCByZXR1cm4gZmFsc2UuXG4gKiBAcGFyYW0gZmlsZSAtIFRoZSBmaWxlIHlvdSB3YW50IHRvIHR5cGUgY2hlY2suXG4gKiBAcGFyYW0gYWNjZXB0YWJsZU1pbWVUeXBlcyAtIEFuIGFycmF5IG9mIHN0cmluZ3Mgb2YgdHlwZXMgd2hpY2ggdGhlIGZpbGUgaXMgY2hlY2tlZCBhZ2FpbnN0LlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgZmlsZSBpcyBhbiBhY2NlcHRhYmxlIG1pbWUgdHlwZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc01pbWVUeXBlKGZpbGUsIGFjY2VwdGFibGVNaW1lVHlwZXMpIHtcbiAgZm9yIChjb25zdCBhY2NlcHRhYmxlVHlwZSBvZiBhY2NlcHRhYmxlTWltZVR5cGVzKSB7XG4gICAgaWYgKGZpbGUudHlwZS5zdGFydHNXaXRoKGFjY2VwdGFibGVUeXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBMZXhpY2FsIEZpbGUgUmVhZGVyIHdpdGg6XG4gKiAgMS4gTUlNRSB0eXBlIHN1cHBvcnRcbiAqICAyLiBiYXRjaGVkIHJlc3VsdHMgKEhpc3RvcnlQbHVnaW4gY29tcGF0aWJpbGl0eSlcbiAqICAzLiBPcmRlciBhd2FyZSAocmVzcGVjdHMgdGhlIG9yZGVyIHdoZW4gbXVsdGlwbGUgRmlsZXMgYXJlIHBhc3NlZClcbiAqXG4gKiBjb25zdCBmaWxlc1Jlc3VsdCA9IGF3YWl0IG1lZGlhRmlsZVJlYWRlcihmaWxlcywgWydpbWFnZS8nXSk7XG4gKiBmaWxlc1Jlc3VsdC5mb3JFYWNoKGZpbGUgPT4gZWRpdG9yLmRpc3BhdGNoQ29tbWFuZCgnSU5TRVJUX0lNQUdFJywgXFxcXHtcbiAqICAgc3JjOiBmaWxlLnJlc3VsdCxcbiAqIFxcXFx9KSk7XG4gKi9cbmZ1bmN0aW9uIG1lZGlhRmlsZVJlYWRlcihmaWxlcywgYWNjZXB0YWJsZU1pbWVUeXBlcykge1xuICBjb25zdCBmaWxlc0l0ZXJhdG9yID0gZmlsZXNbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHByb2Nlc3NlZCA9IFtdO1xuICAgIGNvbnN0IGhhbmRsZU5leHRGaWxlID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBkb25lLFxuICAgICAgICB2YWx1ZTogZmlsZVxuICAgICAgfSA9IGZpbGVzSXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmUocHJvY2Vzc2VkKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICBmaWxlUmVhZGVyLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZpbGVSZWFkZXIucmVzdWx0O1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBwcm9jZXNzZWQucHVzaCh7XG4gICAgICAgICAgICBmaWxlLFxuICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlTmV4dEZpbGUoKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzTWltZVR5cGUoZmlsZSwgYWNjZXB0YWJsZU1pbWVUeXBlcykpIHtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlTmV4dEZpbGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGhhbmRsZU5leHRGaWxlKCk7XG4gIH0pO1xufVxuLyoqXG4gKiBcIkRlcHRoLUZpcnN0IFNlYXJjaFwiIHN0YXJ0cyBhdCB0aGUgcm9vdC90b3Agbm9kZSBvZiBhIHRyZWUgYW5kIGdvZXMgYXMgZmFyIGFzIGl0IGNhbiBkb3duIGEgYnJhbmNoIGVuZFxuICogYmVmb3JlIGJhY2t0cmFja2luZyBhbmQgZmluZGluZyBhIG5ldyBwYXRoLiBDb25zaWRlciBzb2x2aW5nIGEgbWF6ZSBieSBodWdnaW5nIGVpdGhlciB3YWxsLCBtb3ZpbmcgZG93biBhXG4gKiBicmFuY2ggdW50aWwgeW91IGhpdCBhIGRlYWQtZW5kIChsZWFmKSBhbmQgYmFja3RyYWNraW5nIHRvIGZpbmQgdGhlIG5lYXJlc3QgYnJhbmNoaW5nIHBhdGggYW5kIHJlcGVhdC5cbiAqIEl0IHdpbGwgdGhlbiByZXR1cm4gYWxsIHRoZSBub2RlcyBmb3VuZCBpbiB0aGUgc2VhcmNoIGluIGFuIGFycmF5IG9mIG9iamVjdHMuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIG5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBzdGFydCBhdCB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIGVuZE5vZGUgLSBUaGUgbm9kZSB0byBlbmQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBmaW5kIGFsbCBkZXNjZW5kYW50cyBvZiB0aGUgc3RhcnRpbmdOb2RlLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygb2JqZWN0cyBvZiBhbGwgdGhlIG5vZGVzIGZvdW5kIGJ5IHRoZSBzZWFyY2gsIGluY2x1ZGluZyB0aGVpciBkZXB0aCBpbnRvIHRoZSB0cmVlLlxuICogXFxcXHtkZXB0aDogbnVtYmVyLCBub2RlOiBMZXhpY2FsTm9kZVxcXFx9IEl0IHdpbGwgYWx3YXlzIHJldHVybiBhdCBsZWFzdCAxIG5vZGUgKHRoZSBzdGFydCBub2RlKS5cbiAqL1xuZnVuY3Rpb24gJGRmcyhzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oJGRmc0l0ZXJhdG9yKHN0YXJ0Tm9kZSwgZW5kTm9kZSkpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgYWRqYWNlbnQgY2FyZXQgaW4gdGhlIHNhbWUgZGlyZWN0aW9uXG4gKlxuICogQHBhcmFtIGNhcmV0IEEgY2FyZXQgb3IgbnVsbFxuICogQHJldHVybnMgYGNhcmV0LmdldEFkamFjZW50Q2FyZXQoKWAgb3IgYG51bGxgXG4gKi9cbmZ1bmN0aW9uICRnZXRBZGphY2VudENhcmV0KGNhcmV0KSB7XG4gIHJldHVybiBjYXJldCA/IGNhcmV0LmdldEFkamFjZW50Q2FyZXQoKSA6IG51bGw7XG59XG5cbi8qKlxuICogJGRmcyBpdGVyYXRvciAocmlnaHQgdG8gbGVmdCkuIFRyZWUgdHJhdmVyc2FsIGlzIGRvbmUgb24gdGhlIGZseSBhcyBuZXcgdmFsdWVzIGFyZSByZXF1ZXN0ZWQgd2l0aCBPKDEpIG1lbW9yeS5cbiAqIEBwYXJhbSBzdGFydE5vZGUgLSBUaGUgbm9kZSB0byBzdGFydCB0aGUgc2VhcmNoLCBpZiBvbWl0dGVkLCBpdCB3aWxsIHN0YXJ0IGF0IHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0gZW5kTm9kZSAtIFRoZSBub2RlIHRvIGVuZCB0aGUgc2VhcmNoLCBpZiBvbWl0dGVkLCBpdCB3aWxsIGZpbmQgYWxsIGRlc2NlbmRhbnRzIG9mIHRoZSBzdGFydGluZ05vZGUuXG4gKiBAcmV0dXJucyBBbiBpdGVyYXRvciwgZWFjaCB5aWVsZGVkIHZhbHVlIGlzIGEgREZTTm9kZS4gSXQgd2lsbCBhbHdheXMgcmV0dXJuIGF0IGxlYXN0IDEgbm9kZSAodGhlIHN0YXJ0IG5vZGUpLlxuICovXG5mdW5jdGlvbiAkcmV2ZXJzZURmcyhzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oJHJldmVyc2VEZnNJdGVyYXRvcihzdGFydE5vZGUsIGVuZE5vZGUpKTtcbn1cblxuLyoqXG4gKiAkZGZzIGl0ZXJhdG9yIChsZWZ0IHRvIHJpZ2h0KS4gVHJlZSB0cmF2ZXJzYWwgaXMgZG9uZSBvbiB0aGUgZmx5IGFzIG5ldyB2YWx1ZXMgYXJlIHJlcXVlc3RlZCB3aXRoIE8oMSkgbWVtb3J5LlxuICogQHBhcmFtIHN0YXJ0Tm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgc3RhcnQgYXQgdGhlIHJvb3Qgbm9kZS5cbiAqIEBwYXJhbSBlbmROb2RlIC0gVGhlIG5vZGUgdG8gZW5kIHRoZSBzZWFyY2gsIGlmIG9taXR0ZWQsIGl0IHdpbGwgZmluZCBhbGwgZGVzY2VuZGFudHMgb2YgdGhlIHN0YXJ0aW5nTm9kZS5cbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yLCBlYWNoIHlpZWxkZWQgdmFsdWUgaXMgYSBERlNOb2RlLiBJdCB3aWxsIGFsd2F5cyByZXR1cm4gYXQgbGVhc3QgMSBub2RlICh0aGUgc3RhcnQgbm9kZSkuXG4gKi9cbmZ1bmN0aW9uICRkZnNJdGVyYXRvcihzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgcmV0dXJuICRkZnNDYXJldEl0ZXJhdG9yKCduZXh0Jywgc3RhcnROb2RlLCBlbmROb2RlKTtcbn1cbmZ1bmN0aW9uICRnZXRFbmRDYXJldChzdGFydE5vZGUsIGRpcmVjdGlvbikge1xuICBjb25zdCBydmFsID0gJGdldEFkamFjZW50U2libGluZ09yUGFyZW50U2libGluZ0NhcmV0KCRnZXRTaWJsaW5nQ2FyZXQoc3RhcnROb2RlLCBkaXJlY3Rpb24pKTtcbiAgcmV0dXJuIHJ2YWwgJiYgcnZhbFswXTtcbn1cbmZ1bmN0aW9uICRkZnNDYXJldEl0ZXJhdG9yKGRpcmVjdGlvbiwgc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIGNvbnN0IHJvb3QgPSAkZ2V0Um9vdCgpO1xuICBjb25zdCBzdGFydCA9IHN0YXJ0Tm9kZSB8fCByb290O1xuICBjb25zdCBzdGFydENhcmV0ID0gJGlzRWxlbWVudE5vZGUoc3RhcnQpID8gJGdldENoaWxkQ2FyZXQoc3RhcnQsIGRpcmVjdGlvbikgOiAkZ2V0U2libGluZ0NhcmV0KHN0YXJ0LCBkaXJlY3Rpb24pO1xuICBjb25zdCBzdGFydERlcHRoID0gJGdldERlcHRoKHN0YXJ0KTtcbiAgY29uc3QgZW5kQ2FyZXQgPSBlbmROb2RlID8gJGdldEFkamFjZW50Q2hpbGRDYXJldCgkZ2V0Q2hpbGRDYXJldE9yU2VsZigkZ2V0U2libGluZ0NhcmV0KGVuZE5vZGUsIGRpcmVjdGlvbikpKSA6ICRnZXRFbmRDYXJldChzdGFydCwgZGlyZWN0aW9uKTtcbiAgbGV0IGRlcHRoID0gc3RhcnREZXB0aDtcbiAgcmV0dXJuIG1ha2VTdGVwd2lzZUl0ZXJhdG9yKHtcbiAgICBoYXNOZXh0OiBzdGF0ZSA9PiBzdGF0ZSAhPT0gbnVsbCxcbiAgICBpbml0aWFsOiBzdGFydENhcmV0LFxuICAgIG1hcDogc3RhdGUgPT4gKHtcbiAgICAgIGRlcHRoLFxuICAgICAgbm9kZTogc3RhdGUub3JpZ2luXG4gICAgfSksXG4gICAgc3RlcDogc3RhdGUgPT4ge1xuICAgICAgaWYgKHN0YXRlLmlzU2FtZU5vZGVDYXJldChlbmRDYXJldCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoJGlzQ2hpbGRDYXJldChzdGF0ZSkpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJ2YWwgPSAkZ2V0QWRqYWNlbnRTaWJsaW5nT3JQYXJlbnRTaWJsaW5nQ2FyZXQoc3RhdGUpO1xuICAgICAgaWYgKCFydmFsIHx8IHJ2YWxbMF0uaXNTYW1lTm9kZUNhcmV0KGVuZENhcmV0KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGRlcHRoICs9IHJ2YWxbMV07XG4gICAgICByZXR1cm4gcnZhbFswXTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIE5vZGUgc2libGluZyB3aGVuIHRoaXMgZXhpc3RzLCBvdGhlcndpc2UgdGhlIGNsb3Nlc3QgcGFyZW50IHNpYmxpbmcuIEZvciBleGFtcGxlXG4gKiBSIC0+IFAgLT4gVDEsIFQyXG4gKiAgIC0+IFAyXG4gKiByZXR1cm5zIFQyIGZvciBub2RlIFQxLCBQMiBmb3Igbm9kZSBUMiwgYW5kIG51bGwgZm9yIG5vZGUgUDIuXG4gKiBAcGFyYW0gbm9kZSBMZXhpY2FsTm9kZS5cbiAqIEByZXR1cm5zIEFuIGFycmF5ICh0dXBsZSkgY29udGFpbmluZyB0aGUgZm91bmQgTGV4aWNhbCBub2RlIGFuZCB0aGUgZGVwdGggZGlmZmVyZW5jZSwgb3IgbnVsbCwgaWYgdGhpcyBub2RlIGRvZXNuJ3QgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uICRnZXROZXh0U2libGluZ09yUGFyZW50U2libGluZyhub2RlKSB7XG4gIGNvbnN0IHJ2YWwgPSAkZ2V0QWRqYWNlbnRTaWJsaW5nT3JQYXJlbnRTaWJsaW5nQ2FyZXQoJGdldFNpYmxpbmdDYXJldChub2RlLCAnbmV4dCcpKTtcbiAgcmV0dXJuIHJ2YWwgJiYgW3J2YWxbMF0ub3JpZ2luLCBydmFsWzFdXTtcbn1cbmZ1bmN0aW9uICRnZXREZXB0aChub2RlKSB7XG4gIGxldCBkZXB0aCA9IC0xO1xuICBmb3IgKGxldCBpbm5lck5vZGUgPSBub2RlOyBpbm5lck5vZGUgIT09IG51bGw7IGlubmVyTm9kZSA9IGlubmVyTm9kZS5nZXRQYXJlbnQoKSkge1xuICAgIGRlcHRoKys7XG4gIH1cbiAgcmV0dXJuIGRlcHRoO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGEgcmlnaHQtdG8tbGVmdCBwcmVvcmRlciB0cmVlIHRyYXZlcnNhbC5cbiAqIEZyb20gdGhlIHN0YXJ0aW5nIG5vZGUgaXQgZ29lcyB0byB0aGUgcmlnaHRtb3N0IGNoaWxkLCB0aGFuIGJhY2t0cmFja3MgdG8gcGFyZW50IGFuZCBmaW5kcyBuZXcgcmlnaHRtb3N0IHBhdGguXG4gKiBJdCB3aWxsIHJldHVybiB0aGUgbmV4dCBub2RlIGluIHRyYXZlcnNhbCBzZXF1ZW5jZSBhZnRlciB0aGUgc3RhcnRpbmdOb2RlLlxuICogVGhlIHRyYXZlcnNhbCBpcyBzaW1pbGFyIHRvICRkZnMgZnVuY3Rpb25zIGFib3ZlLCBidXQgdGhlIG5vZGVzIGFyZSB2aXNpdGVkIHJpZ2h0LXRvLWxlZnQsIG5vdCBsZWZ0LXRvLXJpZ2h0LlxuICogQHBhcmFtIHN0YXJ0aW5nTm9kZSAtIFRoZSBub2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2guXG4gKiBAcmV0dXJucyBUaGUgbmV4dCBub2RlIGluIHByZS1vcmRlciByaWdodCB0byBsZWZ0IHRyYXZlcnNhbCBzZXF1ZW5jZSBvciBgbnVsbGAsIGlmIHRoZSBub2RlIGRvZXMgbm90IGV4aXN0XG4gKi9cbmZ1bmN0aW9uICRnZXROZXh0UmlnaHRQcmVvcmRlck5vZGUoc3RhcnRpbmdOb2RlKSB7XG4gIGNvbnN0IHN0YXJ0Q2FyZXQgPSAkZ2V0Q2hpbGRDYXJldE9yU2VsZigkZ2V0U2libGluZ0NhcmV0KHN0YXJ0aW5nTm9kZSwgJ3ByZXZpb3VzJykpO1xuICBjb25zdCBuZXh0ID0gJGdldEFkamFjZW50U2libGluZ09yUGFyZW50U2libGluZ0NhcmV0KHN0YXJ0Q2FyZXQsICdyb290Jyk7XG4gIHJldHVybiBuZXh0ICYmIG5leHRbMF0ub3JpZ2luO1xufVxuXG4vKipcbiAqICRkZnMgaXRlcmF0b3IgKHJpZ2h0IHRvIGxlZnQpLiBUcmVlIHRyYXZlcnNhbCBpcyBkb25lIG9uIHRoZSBmbHkgYXMgbmV3IHZhbHVlcyBhcmUgcmVxdWVzdGVkIHdpdGggTygxKSBtZW1vcnkuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIG5vZGUgdG8gc3RhcnQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBzdGFydCBhdCB0aGUgcm9vdCBub2RlLlxuICogQHBhcmFtIGVuZE5vZGUgLSBUaGUgbm9kZSB0byBlbmQgdGhlIHNlYXJjaCwgaWYgb21pdHRlZCwgaXQgd2lsbCBmaW5kIGFsbCBkZXNjZW5kYW50cyBvZiB0aGUgc3RhcnRpbmdOb2RlLlxuICogQHJldHVybnMgQW4gaXRlcmF0b3IsIGVhY2ggeWllbGRlZCB2YWx1ZSBpcyBhIERGU05vZGUuIEl0IHdpbGwgYWx3YXlzIHJldHVybiBhdCBsZWFzdCAxIG5vZGUgKHRoZSBzdGFydCBub2RlKS5cbiAqL1xuZnVuY3Rpb24gJHJldmVyc2VEZnNJdGVyYXRvcihzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgcmV0dXJuICRkZnNDYXJldEl0ZXJhdG9yKCdwcmV2aW91cycsIHN0YXJ0Tm9kZSwgZW5kTm9kZSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBub2RlIGFuZCB0cmF2ZXJzZXMgdXAgaXRzIGFuY2VzdG9ycyAodG93YXJkIHRoZSByb290IG5vZGUpXG4gKiBpbiBvcmRlciB0byBmaW5kIGEgc3BlY2lmaWMgdHlwZSBvZiBub2RlLlxuICogQHBhcmFtIG5vZGUgLSB0aGUgbm9kZSB0byBiZWdpbiBzZWFyY2hpbmcuXG4gKiBAcGFyYW0ga2xhc3MgLSBhbiBpbnN0YW5jZSBvZiB0aGUgdHlwZSBvZiBub2RlIHRvIGxvb2sgZm9yLlxuICogQHJldHVybnMgdGhlIG5vZGUgb2YgdHlwZSBrbGFzcyB0aGF0IHdhcyBwYXNzZWQsIG9yIG51bGwgaWYgbm9uZSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3ROb2RlT2ZUeXBlKG5vZGUsIGtsYXNzKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICBpZiAocGFyZW50IGluc3RhbmNlb2Yga2xhc3MpIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbGVtZW50IG5vZGUgb2YgdGhlIG5lYXJlc3QgYW5jZXN0b3IsIG90aGVyd2lzZSB0aHJvd3MgYW4gZXJyb3IuXG4gKiBAcGFyYW0gc3RhcnROb2RlIC0gVGhlIHN0YXJ0aW5nIG5vZGUgb2YgdGhlIHNlYXJjaFxuICogQHJldHVybnMgVGhlIGFuY2VzdG9yIG5vZGUgZm91bmRcbiAqL1xuZnVuY3Rpb24gJGdldE5lYXJlc3RCbG9ja0VsZW1lbnRBbmNlc3Rvck9yVGhyb3coc3RhcnROb2RlKSB7XG4gIGNvbnN0IGJsb2NrTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnROb2RlLCBub2RlID0+ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuICBpZiAoISRpc0VsZW1lbnROb2RlKGJsb2NrTm9kZSkpIHtcbiAgICB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIG5vZGUgJHtzdGFydE5vZGUuX19rZXl9IHRvIGhhdmUgY2xvc2VzdCBibG9jayBlbGVtZW50IG5vZGUuYCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBibG9ja05vZGU7XG59XG4vKipcbiAqIFN0YXJ0cyB3aXRoIGEgbm9kZSBhbmQgbW92ZXMgdXAgdGhlIHRyZWUgKHRvd2FyZCB0aGUgcm9vdCBub2RlKSB0byBmaW5kIGEgbWF0Y2hpbmcgbm9kZSBiYXNlZCBvblxuICogdGhlIHNlYXJjaCBwYXJhbWV0ZXJzIG9mIHRoZSBmaW5kRm4uIChDb25zaWRlciBKYXZhU2NyaXB0cycgLmZpbmQoKSBmdW5jdGlvbiB3aGVyZSBhIHRlc3RpbmcgZnVuY3Rpb24gbXVzdCBiZVxuICogcGFzc2VkIGFzIGFuIGFyZ3VtZW50LiBlZy4gaWYoIChub2RlKSA9PiBub2RlLl9fdHlwZSA9PT0gJ2RpdicpICkgcmV0dXJuIHRydWU7IG90aGVyd2lzZSByZXR1cm4gZmFsc2VcbiAqIEBwYXJhbSBzdGFydGluZ05vZGUgLSBUaGUgbm9kZSB3aGVyZSB0aGUgc2VhcmNoIHN0YXJ0cy5cbiAqIEBwYXJhbSBmaW5kRm4gLSBBIHRlc3RpbmcgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgbm9kZSBzYXRpc2ZpZXMgdGhlIHRlc3RpbmcgcGFyYW1ldGVycy5cbiAqIEByZXR1cm5zIEEgcGFyZW50IG5vZGUgdGhhdCBtYXRjaGVzIHRoZSBmaW5kRm4gcGFyYW1ldGVycywgb3IgbnVsbCBpZiBvbmUgd2Fzbid0IGZvdW5kLlxuICovXG5jb25zdCAkZmluZE1hdGNoaW5nUGFyZW50ID0gKHN0YXJ0aW5nTm9kZSwgZmluZEZuKSA9PiB7XG4gIGxldCBjdXJyID0gc3RhcnRpbmdOb2RlO1xuICB3aGlsZSAoY3VyciAhPT0gJGdldFJvb3QoKSAmJiBjdXJyICE9IG51bGwpIHtcbiAgICBpZiAoZmluZEZuKGN1cnIpKSB7XG4gICAgICByZXR1cm4gY3VycjtcbiAgICB9XG4gICAgY3VyciA9IGN1cnIuZ2V0UGFyZW50KCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEF0dGVtcHRzIHRvIHJlc29sdmUgbmVzdGVkIGVsZW1lbnQgbm9kZXMgb2YgdGhlIHNhbWUgdHlwZSBpbnRvIGEgc2luZ2xlIG5vZGUgb2YgdGhhdCB0eXBlLlxuICogSXQgaXMgZ2VuZXJhbGx5IHVzZWQgZm9yIG1hcmtzL2NvbW1lbnRpbmdcbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3JcbiAqIEBwYXJhbSB0YXJnZXROb2RlIC0gVGhlIHRhcmdldCBmb3IgdGhlIG5lc3RlZCBlbGVtZW50IHRvIGJlIGV4dHJhY3RlZCBmcm9tLlxuICogQHBhcmFtIGNsb25lTm9kZSAtIFNlZSB7QGxpbmsgJGNyZWF0ZU1hcmtOb2RlfVxuICogQHBhcmFtIGhhbmRsZU92ZXJsYXAgLSBIYW5kbGVzIGFueSBvdmVybGFwIGJldHdlZW4gdGhlIG5vZGUgdG8gZXh0cmFjdCBhbmQgdGhlIHRhcmdldE5vZGVcbiAqIEByZXR1cm5zIFRoZSBsZXhpY2FsIGVkaXRvclxuICovXG5mdW5jdGlvbiByZWdpc3Rlck5lc3RlZEVsZW1lbnRSZXNvbHZlcihlZGl0b3IsIHRhcmdldE5vZGUsIGNsb25lTm9kZSwgaGFuZGxlT3ZlcmxhcCkge1xuICBjb25zdCAkaXNUYXJnZXROb2RlID0gbm9kZSA9PiB7XG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiB0YXJnZXROb2RlO1xuICB9O1xuICBjb25zdCAkZmluZE1hdGNoID0gbm9kZSA9PiB7XG4gICAgLy8gRmlyc3QgdmFsaWRhdGUgd2UgZG9uJ3QgaGF2ZSBhbnkgY2hpbGRyZW4gdGhhdCBhcmUgb2YgdGhlIHRhcmdldCxcbiAgICAvLyBhcyB3ZSBuZWVkIHRvIGhhbmRsZSB0aGVtIGZpcnN0LlxuICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBpZiAoJGlzVGFyZ2V0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBwYXJlbnROb2RlID0gbm9kZTtcbiAgICBsZXQgY2hpbGROb2RlID0gbm9kZTtcbiAgICB3aGlsZSAocGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2hpbGROb2RlID0gcGFyZW50Tm9kZTtcbiAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKCRpc1RhcmdldE5vZGUocGFyZW50Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGlsZDogY2hpbGROb2RlLFxuICAgICAgICAgIHBhcmVudDogcGFyZW50Tm9kZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgY29uc3QgJGVsZW1lbnROb2RlVHJhbnNmb3JtID0gbm9kZSA9PiB7XG4gICAgY29uc3QgbWF0Y2ggPSAkZmluZE1hdGNoKG5vZGUpO1xuICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjaGlsZCxcbiAgICAgICAgcGFyZW50XG4gICAgICB9ID0gbWF0Y2g7XG5cbiAgICAgIC8vIFNpbXBsZSBwYXRoLCB3ZSBjYW4gbW92ZSBjaGlsZCBvdXQgYW5kIHNpYmxpbmdzIGludG8gYSBuZXcgcGFyZW50LlxuXG4gICAgICBpZiAoY2hpbGQuaXMobm9kZSkpIHtcbiAgICAgICAgaGFuZGxlT3ZlcmxhcChwYXJlbnQsIG5vZGUpO1xuICAgICAgICBjb25zdCBuZXh0U2libGluZ3MgPSBjaGlsZC5nZXROZXh0U2libGluZ3MoKTtcbiAgICAgICAgY29uc3QgbmV4dFNpYmxpbmdzTGVuZ3RoID0gbmV4dFNpYmxpbmdzLmxlbmd0aDtcbiAgICAgICAgcGFyZW50Lmluc2VydEFmdGVyKGNoaWxkKTtcbiAgICAgICAgaWYgKG5leHRTaWJsaW5nc0xlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGNvbnN0IG5ld1BhcmVudCA9IGNsb25lTm9kZShwYXJlbnQpO1xuICAgICAgICAgIGNoaWxkLmluc2VydEFmdGVyKG5ld1BhcmVudCk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuZXh0U2libGluZ3NMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3UGFyZW50LmFwcGVuZChuZXh0U2libGluZ3NbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmVudC5jYW5CZUVtcHR5KCkgJiYgcGFyZW50LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgcGFyZW50LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybSh0YXJnZXROb2RlLCAkZWxlbWVudE5vZGVUcmFuc2Zvcm0pO1xufVxuXG4vKipcbiAqIENsb25lcyB0aGUgZWRpdG9yIGFuZCBtYXJrcyBpdCBhcyBkaXJ0eSB0byBiZSByZWNvbmNpbGVkLiBJZiB0aGVyZSB3YXMgYSBzZWxlY3Rpb24sXG4gKiBpdCB3b3VsZCBiZSBzZXQgYmFjayB0byBpdHMgcHJldmlvdXMgc3RhdGUsIG9yIG51bGwgb3RoZXJ3aXNlLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIGVkaXRvclN0YXRlIC0gVGhlIGVkaXRvcidzIHN0YXRlXG4gKi9cbmZ1bmN0aW9uICRyZXN0b3JlRWRpdG9yU3RhdGUoZWRpdG9yLCBlZGl0b3JTdGF0ZSkge1xuICBjb25zdCBGVUxMX1JFQ09OQ0lMRSA9IDI7XG4gIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwKCk7XG4gIGNvbnN0IGFjdGl2ZUVkaXRvclN0YXRlID0gZWRpdG9yLl9wZW5kaW5nRWRpdG9yU3RhdGU7XG4gIGZvciAoY29uc3QgW2tleSwgbm9kZV0gb2YgZWRpdG9yU3RhdGUuX25vZGVNYXApIHtcbiAgICBub2RlTWFwLnNldChrZXksICRjbG9uZVdpdGhQcm9wZXJ0aWVzKG5vZGUpKTtcbiAgfVxuICBpZiAoYWN0aXZlRWRpdG9yU3RhdGUpIHtcbiAgICBhY3RpdmVFZGl0b3JTdGF0ZS5fbm9kZU1hcCA9IG5vZGVNYXA7XG4gIH1cbiAgZWRpdG9yLl9kaXJ0eVR5cGUgPSBGVUxMX1JFQ09OQ0lMRTtcbiAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yU3RhdGUuX3NlbGVjdGlvbjtcbiAgJHNldFNlbGVjdGlvbihzZWxlY3Rpb24gPT09IG51bGwgPyBudWxsIDogc2VsZWN0aW9uLmNsb25lKCkpO1xufVxuXG4vKipcbiAqIElmIHRoZSBzZWxlY3RlZCBpbnNlcnRpb24gYXJlYSBpcyB0aGUgcm9vdC9zaGFkb3cgcm9vdCBub2RlIChzZWUge0BsaW5rIGxleGljYWwhJGlzUm9vdE9yU2hhZG93Um9vdH0pLFxuICogdGhlIG5vZGUgd2lsbCBiZSBhcHBlbmRlZCB0aGVyZSwgb3RoZXJ3aXNlLCBpdCB3aWxsIGJlIGluc2VydGVkIGJlZm9yZSB0aGUgaW5zZXJ0aW9uIGFyZWEuXG4gKiBJZiB0aGVyZSBpcyBubyBzZWxlY3Rpb24gd2hlcmUgdGhlIG5vZGUgaXMgdG8gYmUgaW5zZXJ0ZWQsIGl0IHdpbGwgYmUgYXBwZW5kZWQgYWZ0ZXIgYW55IGN1cnJlbnQgbm9kZXNcbiAqIHdpdGhpbiB0aGUgdHJlZSwgYXMgYSBjaGlsZCBvZiB0aGUgcm9vdCBub2RlLiBBIHBhcmFncmFwaCB3aWxsIHRoZW4gYmUgYWRkZWQgYWZ0ZXIgdGhlIGluc2VydGVkIG5vZGUgYW5kIHNlbGVjdGVkLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBpbnNlcnRlZFxuICogQHJldHVybnMgVGhlIG5vZGUgYWZ0ZXIgaXRzIGluc2VydGlvblxuICovXG5mdW5jdGlvbiAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3Qobm9kZSkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCkgfHwgJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gIGxldCBpbml0aWFsQ2FyZXQ7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgaW5pdGlhbENhcmV0ID0gJGNhcmV0RnJvbVBvaW50KHNlbGVjdGlvbi5mb2N1cywgJ25leHQnKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoc2VsZWN0aW9uICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgICBjb25zdCBsYXN0Tm9kZSA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3ROb2RlKSB7XG4gICAgICAgIGluaXRpYWxDYXJldCA9ICRnZXRTaWJsaW5nQ2FyZXQobGFzdE5vZGUsICduZXh0Jyk7XG4gICAgICB9XG4gICAgfVxuICAgIGluaXRpYWxDYXJldCA9IGluaXRpYWxDYXJldCB8fCAkZ2V0Q2hpbGRDYXJldCgkZ2V0Um9vdCgpLCAncHJldmlvdXMnKS5nZXRGbGlwcGVkKCkuaW5zZXJ0KCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICB9XG4gIGNvbnN0IGluc2VydENhcmV0ID0gJGluc2VydE5vZGVUb05lYXJlc3RSb290QXRDYXJldChub2RlLCBpbml0aWFsQ2FyZXQpO1xuICBjb25zdCBhZGphY2VudCA9ICRnZXRBZGphY2VudENoaWxkQ2FyZXQoaW5zZXJ0Q2FyZXQpO1xuICBjb25zdCBzZWxlY3Rpb25DYXJldCA9ICRpc0NoaWxkQ2FyZXQoYWRqYWNlbnQpID8gJG5vcm1hbGl6ZUNhcmV0KGFkamFjZW50KSA6IGluc2VydENhcmV0O1xuICAkc2V0U2VsZWN0aW9uRnJvbUNhcmV0UmFuZ2UoJGdldENvbGxhcHNlZENhcmV0UmFuZ2Uoc2VsZWN0aW9uQ2FyZXQpKTtcbiAgcmV0dXJuIG5vZGUuZ2V0TGF0ZXN0KCk7XG59XG5cbi8qKlxuICogSWYgdGhlIGluc2VydGlvbiBjYXJldCBpcyB0aGUgcm9vdC9zaGFkb3cgcm9vdCBub2RlIChzZWUge0BsaW5rIGxleGljYWwhJGlzUm9vdE9yU2hhZG93Um9vdH0pLFxuICogdGhlIG5vZGUgd2lsbCBiZSBpbnNlcnRlZCB0aGVyZSwgb3RoZXJ3aXNlIHRoZSBwYXJlbnQgbm9kZXMgd2lsbCBiZSBzcGxpdCBhY2NvcmRpbmcgdG8gdGhlXG4gKiBnaXZlbiBvcHRpb25zLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBpbnNlcnRlZFxuICogQHBhcmFtIGNhcmV0IC0gVGhlIGxvY2F0aW9uIHRvIGluc2VydCBvciBzcGxpdCBmcm9tXG4gKiBAcmV0dXJucyBUaGUgbm9kZSBhZnRlciBpdHMgaW5zZXJ0aW9uXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdEF0Q2FyZXQobm9kZSwgY2FyZXQsIG9wdGlvbnMpIHtcbiAgbGV0IGluc2VydENhcmV0ID0gJGdldENhcmV0SW5EaXJlY3Rpb24oY2FyZXQsICduZXh0Jyk7XG4gIGZvciAobGV0IG5leHRDYXJldCA9IGluc2VydENhcmV0OyBuZXh0Q2FyZXQ7IG5leHRDYXJldCA9ICRzcGxpdEF0UG9pbnRDYXJldE5leHQobmV4dENhcmV0LCBvcHRpb25zKSkge1xuICAgIGluc2VydENhcmV0ID0gbmV4dENhcmV0O1xuICB9XG4gIGlmICghISRpc1RleHRQb2ludENhcmV0KGluc2VydENhcmV0KSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGluc2VydE5vZGVUb05lYXJlc3RSb290QXRDYXJldDogQW4gdW5hdHRhY2hlZCBUZXh0Tm9kZSBjYW4gbm90IGJlIHNwbGl0YCk7XG4gIH1cbiAgaW5zZXJ0Q2FyZXQuaW5zZXJ0KG5vZGUuaXNJbmxpbmUoKSA/ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkuYXBwZW5kKG5vZGUpIDogbm9kZSk7XG4gIHJldHVybiAkZ2V0Q2FyZXRJbkRpcmVjdGlvbigkZ2V0U2libGluZ0NhcmV0KG5vZGUuZ2V0TGF0ZXN0KCksICduZXh0JyksIGNhcmV0LmRpcmVjdGlvbik7XG59XG5cbi8qKlxuICogV3JhcHMgdGhlIG5vZGUgaW50byBhbm90aGVyIG5vZGUgY3JlYXRlZCBmcm9tIGEgY3JlYXRlRWxlbWVudE5vZGUgZnVuY3Rpb24sIGVnLiAkY3JlYXRlUGFyYWdyYXBoTm9kZVxuICogQHBhcmFtIG5vZGUgLSBOb2RlIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudE5vZGUgLSBDcmVhdGVzIGEgbmV3IGxleGljYWwgZWxlbWVudCB0byB3cmFwIHRoZSB0by1iZS13cmFwcGVkIG5vZGUgYW5kIHJldHVybnMgaXQuXG4gKiBAcmV0dXJucyBBIG5ldyBsZXhpY2FsIGVsZW1lbnQgd2l0aCB0aGUgcHJldmlvdXMgbm9kZSBhcHBlbmRlZCB3aXRoaW4gKGFzIGEgY2hpbGQsIGluY2x1ZGluZyBpdHMgY2hpbGRyZW4pLlxuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVJbkVsZW1lbnQobm9kZSwgY3JlYXRlRWxlbWVudE5vZGUpIHtcbiAgY29uc3QgZWxlbWVudE5vZGUgPSBjcmVhdGVFbGVtZW50Tm9kZSgpO1xuICBub2RlLnJlcGxhY2UoZWxlbWVudE5vZGUpO1xuICBlbGVtZW50Tm9kZS5hcHBlbmQobm9kZSk7XG4gIHJldHVybiBlbGVtZW50Tm9kZTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuLyoqXG4gKiBAcGFyYW0gb2JqZWN0ID0gVGhlIGluc3RhbmNlIG9mIHRoZSB0eXBlXG4gKiBAcGFyYW0gb2JqZWN0Q2xhc3MgPSBUaGUgY2xhc3Mgb2YgdGhlIHR5cGVcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIG9iamVjdCBpcyBoYXMgdGhlIHNhbWUgS2xhc3Mgb2YgdGhlIG9iamVjdENsYXNzLCBpZ25vcmluZyB0aGUgZGlmZmVyZW5jZSBhY3Jvc3Mgd2luZG93IChlLmcuIGRpZmZlcmVudCBpZnJhbWVzKVxuICovXG5mdW5jdGlvbiBvYmplY3RLbGFzc0VxdWFscyhvYmplY3QsIG9iamVjdENsYXNzKSB7XG4gIHJldHVybiBvYmplY3QgIT09IG51bGwgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KS5jb25zdHJ1Y3Rvci5uYW1lID09PSBvYmplY3RDbGFzcy5uYW1lIDogZmFsc2U7XG59XG5cbi8qKlxuICogRmlsdGVyIHRoZSBub2Rlc1xuICogQHBhcmFtIG5vZGVzIEFycmF5IG9mIG5vZGVzIHRoYXQgbmVlZHMgdG8gYmUgZmlsdGVyZWRcbiAqIEBwYXJhbSBmaWx0ZXJGbiBBIGZpbHRlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgbm9kZSBpZiB0aGUgY3VycmVudCBub2RlIHNhdGlzZmllcyB0aGUgY29uZGl0aW9uIG90aGVyd2lzZSBudWxsXG4gKiBAcmV0dXJucyBBcnJheSBvZiBmaWx0ZXJlZCBub2Rlc1xuICovXG5cbmZ1bmN0aW9uICRmaWx0ZXIobm9kZXMsIGZpbHRlckZuKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IGZpbHRlckZuKG5vZGVzW2ldKTtcbiAgICBpZiAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEFwcGVuZHMgdGhlIG5vZGUgYmVmb3JlIHRoZSBmaXJzdCBjaGlsZCBvZiB0aGUgcGFyZW50IG5vZGVcbiAqIEBwYXJhbSBwYXJlbnQgQSBwYXJlbnQgbm9kZVxuICogQHBhcmFtIG5vZGUgTm9kZSB0aGF0IG5lZWRzIHRvIGJlIGFwcGVuZGVkXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnRGaXJzdChwYXJlbnQsIG5vZGUpIHtcbiAgJGdldENoaWxkQ2FyZXQocGFyZW50LCAnbmV4dCcpLmluc2VydChub2RlKTtcbn1cbmxldCBORUVEU19NQU5VQUxfWk9PTSA9IElTX0ZJUkVGT1ggfHwgIUNBTl9VU0VfRE9NID8gZmFsc2UgOiB1bmRlZmluZWQ7XG5mdW5jdGlvbiBuZWVkc01hbnVhbFpvb20oKSB7XG4gIGlmIChORUVEU19NQU5VQUxfWk9PTSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gSWYgdGhlIGJyb3dzZXIgaW1wbGVtZW50cyBzdGFuZGFyZGl6ZWQgQ1NTIHpvb20sIHRoZW4gdGhlIGNsaWVudCByZWN0XG4gICAgLy8gd2lsbCBiZSB3aWRlciBhZnRlciB6b29tIGlzIGFwcGxpZWRcbiAgICAvLyBodHRwczovL2Nocm9tZXN0YXR1cy5jb20vZmVhdHVyZS81MTk4MjU0ODY4NTI5MTUyXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2xleGljYWwvaXNzdWVzLzY4NjNcbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjogYWJzb2x1dGU7IG9wYWNpdHk6IDA7IHdpZHRoOiAxMDBweDsgbGVmdDogLTEwMDBweDsnO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICBjb25zdCBub1pvb20gPSBkaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgZGl2LnN0eWxlLnNldFByb3BlcnR5KCd6b29tJywgJzInKTtcbiAgICBORUVEU19NQU5VQUxfWk9PTSA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA9PT0gbm9ab29tLndpZHRoO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgfVxuICByZXR1cm4gTkVFRFNfTUFOVUFMX1pPT007XG59XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgem9vbSBsZXZlbCBvZiBhbiBlbGVtZW50IGFzIGEgcmVzdWx0IG9mIHVzaW5nXG4gKiBjc3Mgem9vbSBwcm9wZXJ0eS4gRm9yIGJyb3dzZXJzIHRoYXQgaW1wbGVtZW50IHN0YW5kYXJkaXplZCBDU1NcbiAqIHpvb20gKEZpcmVmb3gsIENocm9tZSA+PSAxMjgpLCB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiAxLlxuICogQHBhcmFtIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlWm9vbUxldmVsKGVsZW1lbnQpIHtcbiAgbGV0IHpvb20gPSAxO1xuICBpZiAobmVlZHNNYW51YWxab29tKCkpIHtcbiAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgem9vbSAqPSBOdW1iZXIod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgnem9vbScpKTtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB6b29tO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZWRpdG9yIGlzIGEgbmVzdGVkIGVkaXRvciBjcmVhdGVkIGJ5IExleGljYWxOZXN0ZWRDb21wb3NlclxuICovXG5mdW5jdGlvbiAkaXNFZGl0b3JJc05lc3RlZEVkaXRvcihlZGl0b3IpIHtcbiAgcmV0dXJuIGVkaXRvci5fcGFyZW50RWRpdG9yICE9PSBudWxsO1xufVxuXG4vKipcbiAqIEEgZGVwdGggZmlyc3QgbGFzdC10by1maXJzdCB0cmF2ZXJzYWwgb2Ygcm9vdCB0aGF0IHN0b3BzIGF0IGVhY2ggbm9kZSB0aGF0IG1hdGNoZXNcbiAqICRwcmVkaWNhdGUgYW5kIGVuc3VyZXMgdGhhdCBpdHMgcGFyZW50IGlzIHJvb3QuIFRoaXMgaXMgdHlwaWNhbGx5IHVzZWQgdG8gZGlzY2FyZFxuICogaW52YWxpZCBvciB1bnN1cHBvcnRlZCB3cmFwcGluZyBub2Rlcy4gRm9yIGV4YW1wbGUsIGEgVGFibGVOb2RlIG11c3Qgb25seSBoYXZlXG4gKiBUYWJsZVJvd05vZGUgYXMgY2hpbGRyZW4sIGJ1dCBhbiBpbXBvcnRlciBtaWdodCBhZGQgaW52YWxpZCBub2RlcyBiYXNlZCBvblxuICogY2FwdGlvbiwgdGJvZHksIHRoZWFkLCBldGMuIGFuZCB0aGlzIHdpbGwgdW53cmFwIGFuZCBkaXNjYXJkIHRob3NlLlxuICpcbiAqIEBwYXJhbSByb290IFRoZSByb290IHRvIHN0YXJ0IHRoZSB0cmF2ZXJzYWxcbiAqIEBwYXJhbSAkcHJlZGljYXRlIFNob3VsZCByZXR1cm4gdHJ1ZSBmb3Igbm9kZXMgdGhhdCBhcmUgcGVybWl0dGVkIHRvIGJlIGNoaWxkcmVuIG9mIHJvb3RcbiAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyB1bndyYXBwZWQgb3IgcmVtb3ZlZCBhbnkgbm9kZXNcbiAqL1xuZnVuY3Rpb24gJHVud3JhcEFuZEZpbHRlckRlc2NlbmRhbnRzKHJvb3QsICRwcmVkaWNhdGUpIHtcbiAgcmV0dXJuICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50c0ltcGwocm9vdCwgJHByZWRpY2F0ZSwgbnVsbCk7XG59XG5mdW5jdGlvbiAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHNJbXBsKHJvb3QsICRwcmVkaWNhdGUsICRvblN1Y2Nlc3MpIHtcbiAgbGV0IGRpZE11dGF0ZSA9IGZhbHNlO1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgJGxhc3RUb0ZpcnN0SXRlcmF0b3Iocm9vdCkpIHtcbiAgICBpZiAoJHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgaWYgKCRvblN1Y2Nlc3MgIT09IG51bGwpIHtcbiAgICAgICAgJG9uU3VjY2Vzcyhub2RlKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBkaWRNdXRhdGUgPSB0cnVlO1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgJHVud3JhcEFuZEZpbHRlckRlc2NlbmRhbnRzSW1wbChub2RlLCAkcHJlZGljYXRlLCAkb25TdWNjZXNzIHx8IChjaGlsZCA9PiBub2RlLmluc2VydEFmdGVyKGNoaWxkKSkpO1xuICAgIH1cbiAgICBub2RlLnJlbW92ZSgpO1xuICB9XG4gIHJldHVybiBkaWRNdXRhdGU7XG59XG5cbi8qKlxuICogQSBkZXB0aCBmaXJzdCB0cmF2ZXJzYWwgb2YgdGhlIGNoaWxkcmVuIGFycmF5IHRoYXQgc3RvcHMgYXQgYW5kIGNvbGxlY3RzXG4gKiBlYWNoIG5vZGUgdGhhdCBgJHByZWRpY2F0ZWAgbWF0Y2hlcy4gVGhpcyBpcyB0eXBpY2FsbHkgdXNlZCB0byBkaXNjYXJkXG4gKiBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIHdyYXBwaW5nIG5vZGVzIG9uIGEgY2hpbGRyZW4gYXJyYXkgaW4gdGhlIGBhZnRlcmBcbiAqIG9mIGFuIHtAbGluayBsZXhpY2FsIURPTUNvbnZlcnNpb25PdXRwdXR9LiBGb3IgZXhhbXBsZSwgYSBUYWJsZU5vZGUgbXVzdCBvbmx5IGhhdmVcbiAqIFRhYmxlUm93Tm9kZSBhcyBjaGlsZHJlbiwgYnV0IGFuIGltcG9ydGVyIG1pZ2h0IGFkZCBpbnZhbGlkIG5vZGVzIGJhc2VkIG9uXG4gKiBjYXB0aW9uLCB0Ym9keSwgdGhlYWQsIGV0Yy4gYW5kIHRoaXMgd2lsbCB1bndyYXAgYW5kIGRpc2NhcmQgdGhvc2UuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyByZWFkLW9ubHkgYW5kIHBlcmZvcm1zIG5vIG11dGF0aW9uIG9wZXJhdGlvbnMsIHdoaWNoIG1ha2VzXG4gKiBpdCBzdWl0YWJsZSBmb3IgaW1wb3J0IGFuZCBleHBvcnQgcHVycG9zZXMgYnV0IGxpa2VseSBub3QgZm9yIGFueSBpbi1wbGFjZVxuICogbXV0YXRpb24uIFlvdSBzaG91bGQgdXNlIHtAbGluayAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHN9IGZvciBpbi1wbGFjZVxuICogbXV0YXRpb25zIHN1Y2ggYXMgbm9kZSB0cmFuc2Zvcm1zLlxuICpcbiAqIEBwYXJhbSBjaGlsZHJlbiBUaGUgY2hpbGRyZW4gdG8gdHJhdmVyc2VcbiAqIEBwYXJhbSAkcHJlZGljYXRlIFNob3VsZCByZXR1cm4gdHJ1ZSBmb3Igbm9kZXMgdGhhdCBhcmUgcGVybWl0dGVkIHRvIGJlIGNoaWxkcmVuIG9mIHJvb3RcbiAqIEByZXR1cm5zIFRoZSBjaGlsZHJlbiBvciB0aGVpciBkZXNjZW5kYW50cyB0aGF0IG1hdGNoICRwcmVkaWNhdGVcbiAqL1xuXG5mdW5jdGlvbiAkZGVzY2VuZGFudHNNYXRjaGluZyhjaGlsZHJlbiwgJHByZWRpY2F0ZSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBBcnJheS5mcm9tKGNoaWxkcmVuKS5yZXZlcnNlKCk7XG4gIGZvciAobGV0IGNoaWxkID0gc3RhY2sucG9wKCk7IGNoaWxkICE9PSB1bmRlZmluZWQ7IGNoaWxkID0gc3RhY2sucG9wKCkpIHtcbiAgICBpZiAoJHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICB9IGVsc2UgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSkge1xuICAgICAgZm9yIChjb25zdCBncmFuZGNoaWxkIG9mICRsYXN0VG9GaXJzdEl0ZXJhdG9yKGNoaWxkKSkge1xuICAgICAgICBzdGFjay5wdXNoKGdyYW5kY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBpdGVyYXRvciB0aGF0IHlpZWxkcyBlYWNoIGNoaWxkIG9mIG5vZGUgZnJvbSBmaXJzdCB0byBsYXN0LCB0YWtpbmdcbiAqIGNhcmUgdG8gcHJlc2VydmUgdGhlIG5leHQgc2libGluZyBiZWZvcmUgeWllbGRpbmcgdGhlIHZhbHVlIGluIGNhc2UgdGhlIGNhbGxlclxuICogcmVtb3ZlcyB0aGUgeWllbGRlZCBub2RlLlxuICpcbiAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHdob3NlIGNoaWxkcmVuIHRvIGl0ZXJhdGVcbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIG9mIHRoZSBub2RlJ3MgY2hpbGRyZW5cbiAqL1xuZnVuY3Rpb24gJGZpcnN0VG9MYXN0SXRlcmF0b3Iobm9kZSkge1xuICByZXR1cm4gJGNoaWxkSXRlcmF0b3IoJGdldENoaWxkQ2FyZXQobm9kZSwgJ25leHQnKSk7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGl0ZXJhdG9yIHRoYXQgeWllbGRzIGVhY2ggY2hpbGQgb2Ygbm9kZSBmcm9tIGxhc3QgdG8gZmlyc3QsIHRha2luZ1xuICogY2FyZSB0byBwcmVzZXJ2ZSB0aGUgcHJldmlvdXMgc2libGluZyBiZWZvcmUgeWllbGRpbmcgdGhlIHZhbHVlIGluIGNhc2UgdGhlIGNhbGxlclxuICogcmVtb3ZlcyB0aGUgeWllbGRlZCBub2RlLlxuICpcbiAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHdob3NlIGNoaWxkcmVuIHRvIGl0ZXJhdGVcbiAqIEByZXR1cm5zIEFuIGl0ZXJhdG9yIG9mIHRoZSBub2RlJ3MgY2hpbGRyZW5cbiAqL1xuZnVuY3Rpb24gJGxhc3RUb0ZpcnN0SXRlcmF0b3Iobm9kZSkge1xuICByZXR1cm4gJGNoaWxkSXRlcmF0b3IoJGdldENoaWxkQ2FyZXQobm9kZSwgJ3ByZXZpb3VzJykpO1xufVxuZnVuY3Rpb24gJGNoaWxkSXRlcmF0b3Ioc3RhcnRDYXJldCkge1xuICBjb25zdCBzZWVuID0gbmV3IFNldCgpIDtcbiAgcmV0dXJuIG1ha2VTdGVwd2lzZUl0ZXJhdG9yKHtcbiAgICBoYXNOZXh0OiAkaXNTaWJsaW5nQ2FyZXQsXG4gICAgaW5pdGlhbDogc3RhcnRDYXJldC5nZXRBZGphY2VudENhcmV0KCksXG4gICAgbWFwOiBjYXJldCA9PiB7XG4gICAgICBjb25zdCBvcmlnaW4gPSBjYXJldC5vcmlnaW4uZ2V0TGF0ZXN0KCk7XG4gICAgICBpZiAoc2VlbiAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBrZXkgPSBvcmlnaW4uZ2V0S2V5KCk7XG4gICAgICAgIGlmICghIXNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRjaGlsZEl0ZXJhdG9yOiBDeWNsZSBkZXRlY3RlZCwgbm9kZSB3aXRoIGtleSAke1N0cmluZyhrZXkpfSBoYXMgYWxyZWFkeSBiZWVuIHRyYXZlcnNlZGApO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH0sXG4gICAgc3RlcDogY2FyZXQgPT4gY2FyZXQuZ2V0QWRqYWNlbnRDYXJldCgpXG4gIH0pO1xufVxuXG4vKipcbiAqIFJlcGxhY2UgdGhpcyBub2RlIHdpdGggaXRzIGNoaWxkcmVuXG4gKlxuICogQHBhcmFtIG5vZGUgVGhlIEVsZW1lbnROb2RlIHRvIHVud3JhcCBhbmQgcmVtb3ZlXG4gKi9cbmZ1bmN0aW9uICR1bndyYXBOb2RlKG5vZGUpIHtcbiAgJHJld2luZFNpYmxpbmdDYXJldCgkZ2V0U2libGluZ0NhcmV0KG5vZGUsICduZXh0JykpLnNwbGljZSgxLCBub2RlLmdldENoaWxkcmVuKCkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIE5vZGUgc2libGluZyB3aGVuIHRoaXMgZXhpc3RzLCBvdGhlcndpc2UgdGhlIGNsb3Nlc3QgcGFyZW50IHNpYmxpbmcuIEZvciBleGFtcGxlXG4gKiBSIC0+IFAgLT4gVDEsIFQyXG4gKiAgIC0+IFAyXG4gKiByZXR1cm5zIFQyIGZvciBub2RlIFQxLCBQMiBmb3Igbm9kZSBUMiwgYW5kIG51bGwgZm9yIG5vZGUgUDIuXG4gKiBAcGFyYW0gbm9kZSBMZXhpY2FsTm9kZS5cbiAqIEByZXR1cm5zIEFuIGFycmF5ICh0dXBsZSkgY29udGFpbmluZyB0aGUgZm91bmQgTGV4aWNhbCBub2RlIGFuZCB0aGUgZGVwdGggZGlmZmVyZW5jZSwgb3IgbnVsbCwgaWYgdGhpcyBub2RlIGRvZXNuJ3QgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uICRnZXRBZGphY2VudFNpYmxpbmdPclBhcmVudFNpYmxpbmdDYXJldChzdGFydENhcmV0LCByb290TW9kZSA9ICdyb290Jykge1xuICBsZXQgZGVwdGhEaWZmID0gMDtcbiAgbGV0IGNhcmV0ID0gc3RhcnRDYXJldDtcbiAgbGV0IG5leHRDYXJldCA9ICRnZXRBZGphY2VudENoaWxkQ2FyZXQoY2FyZXQpO1xuICB3aGlsZSAobmV4dENhcmV0ID09PSBudWxsKSB7XG4gICAgZGVwdGhEaWZmLS07XG4gICAgbmV4dENhcmV0ID0gY2FyZXQuZ2V0UGFyZW50Q2FyZXQocm9vdE1vZGUpO1xuICAgIGlmICghbmV4dENhcmV0KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY2FyZXQgPSBuZXh0Q2FyZXQ7XG4gICAgbmV4dENhcmV0ID0gJGdldEFkamFjZW50Q2hpbGRDYXJldChjYXJldCk7XG4gIH1cbiAgcmV0dXJuIG5leHRDYXJldCAmJiBbbmV4dENhcmV0LCBkZXB0aERpZmZdO1xufVxuXG4vKipcbiAqIEEgd3JhcHBlciB0aGF0IGNyZWF0ZXMgYm91bmQgZnVuY3Rpb25zIGFuZCBtZXRob2RzIGZvciB0aGVcbiAqIFN0YXRlQ29uZmlnIHRvIHNhdmUgc29tZSBib2lsZXJwbGF0ZSB3aGVuIGRlZmluaW5nIG1ldGhvZHNcbiAqIG9yIGV4cG9ydGluZyBvbmx5IHRoZSBhY2Nlc3NvcnMgZnJvbSB5b3VyIG1vZHVsZXMgcmF0aGVyXG4gKiB0aGFuIGV4cG9zaW5nIHRoZSBTdGF0ZUNvbmZpZyBkaXJlY3RseS5cbiAqL1xuXG4vKipcbiAqIEVYUEVSSU1FTlRBTFxuICpcbiAqIEEgY29udmVuaWVuY2UgaW50ZXJmYWNlIGZvciB3b3JraW5nIHdpdGgge0BsaW5rICRnZXRTdGF0ZX0gYW5kXG4gKiB7QGxpbmsgJHNldFN0YXRlfS5cbiAqXG4gKiBAcGFyYW0gc3RhdGVDb25maWcgVGhlIHN0YXRlQ29uZmlnIHRvIHdyYXAgd2l0aCBjb252ZW5pZW5jZSBmdW5jdGlvbmFsaXR5XG4gKiBAcmV0dXJucyBhIFN0YXRlV3JhcHBlclxuICovXG5mdW5jdGlvbiBtYWtlU3RhdGVXcmFwcGVyKHN0YXRlQ29uZmlnKSB7XG4gIGNvbnN0ICRnZXQgPSBub2RlID0+ICRnZXRTdGF0ZShub2RlLCBzdGF0ZUNvbmZpZyk7XG4gIGNvbnN0ICRzZXQgPSAobm9kZSwgdmFsdWVPclVwZGF0ZXIpID0+ICRzZXRTdGF0ZShub2RlLCBzdGF0ZUNvbmZpZywgdmFsdWVPclVwZGF0ZXIpO1xuICByZXR1cm4ge1xuICAgICRnZXQsXG4gICAgJHNldCxcbiAgICBhY2Nlc3NvcnM6IFskZ2V0LCAkc2V0XSxcbiAgICBtYWtlR2V0dGVyTWV0aG9kOiAoKSA9PiBmdW5jdGlvbiAkZ2V0dGVyKCkge1xuICAgICAgcmV0dXJuICRnZXQodGhpcyk7XG4gICAgfSxcbiAgICBtYWtlU2V0dGVyTWV0aG9kOiAoKSA9PiBmdW5jdGlvbiAkc2V0dGVyKHZhbHVlT3JVcGRhdGVyKSB7XG4gICAgICByZXR1cm4gJHNldCh0aGlzLCB2YWx1ZU9yVXBkYXRlcik7XG4gICAgfSxcbiAgICBzdGF0ZUNvbmZpZ1xuICB9O1xufVxuXG5leHBvcnQgeyAkZGVzY2VuZGFudHNNYXRjaGluZywgJGRmcywgJGRmc0l0ZXJhdG9yLCAkZmlsdGVyLCAkZmluZE1hdGNoaW5nUGFyZW50LCAkZmlyc3RUb0xhc3RJdGVyYXRvciwgJGdldEFkamFjZW50Q2FyZXQsICRnZXRBZGphY2VudFNpYmxpbmdPclBhcmVudFNpYmxpbmdDYXJldCwgJGdldERlcHRoLCAkZ2V0TmVhcmVzdEJsb2NrRWxlbWVudEFuY2VzdG9yT3JUaHJvdywgJGdldE5lYXJlc3ROb2RlT2ZUeXBlLCAkZ2V0TmV4dFJpZ2h0UHJlb3JkZXJOb2RlLCAkZ2V0TmV4dFNpYmxpbmdPclBhcmVudFNpYmxpbmcsICRpbnNlcnRGaXJzdCwgJGluc2VydE5vZGVUb05lYXJlc3RSb290LCAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3RBdENhcmV0LCAkaXNFZGl0b3JJc05lc3RlZEVkaXRvciwgJGxhc3RUb0ZpcnN0SXRlcmF0b3IsICRyZXN0b3JlRWRpdG9yU3RhdGUsICRyZXZlcnNlRGZzLCAkcmV2ZXJzZURmc0l0ZXJhdG9yLCAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHMsICR1bndyYXBOb2RlLCAkd3JhcE5vZGVJbkVsZW1lbnQsIENBTl9VU0VfQkVGT1JFX0lOUFVULCBDQU5fVVNFX0RPTSwgSVNfQU5EUk9JRCwgSVNfQU5EUk9JRF9DSFJPTUUsIElTX0FQUExFLCBJU19BUFBMRV9XRUJLSVQsIElTX0NIUk9NRSwgSVNfRklSRUZPWCwgSVNfSU9TLCBJU19TQUZBUkksIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsIGNhbGN1bGF0ZVpvb21MZXZlbCwgaXNNaW1lVHlwZSwgbWFrZVN0YXRlV3JhcHBlciwgbWFya1NlbGVjdGlvbiwgbWVkaWFGaWxlUmVhZGVyLCBtZXJnZVJlZ2lzdGVyLCBvYmplY3RLbGFzc0VxdWFscywgbWxjUG9zaXRpb25Ob2RlT25SYW5nZSBhcyBwb3NpdGlvbk5vZGVPblJhbmdlLCByZWdpc3Rlck5lc3RlZEVsZW1lbnRSZXNvbHZlciwgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50LCBzZWxlY3Rpb25BbHdheXNPbkRpc3BsYXkgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@lexical+utils@0.35.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\n");

/***/ })

};
;